<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sonic Roll ‚Äì Rules Engine Prototype</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 16px; background:#0b1020; color:#e8ecff; }
    h1,h2 { margin: 8px 0; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    .card { background:#121a33; border:1px solid #23305a; border-radius:14px; padding:12px; box-shadow: 0 8px 25px rgba(0,0,0,.25); }
    .card h2 { font-size: 14px; letter-spacing:.04em; text-transform:uppercase; color:#b8c6ff; }
    button, select, input { background:#1a2550; border:1px solid #2d3b73; color:#e8ecff; padding:8px 10px; border-radius:10px; cursor:pointer; }
    button:hover { filter:brightness(1.1); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { display:inline-flex; gap:8px; padding:6px 10px; border:1px solid #2d3b73; border-radius:999px; background:#0f1733; margin:4px 4px 0 0; align-items:center; }
    .muted { color:#b0b8e8; }
    .log { max-height: 260px; overflow:auto; font-size: 13px; line-height:1.35; }
    .grid { display:grid; grid-template-columns: repeat(3, minmax(220px, 1fr)); gap:10px; }
    .tiny { font-size: 12px; }
    .danger { color:#ffb6b6; }
    .ok { color:#b8ffcf; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .badge { font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #2d3b73; background:#0f1733; }
    .die {
      width: 44px; height: 44px; border-radius:10px; display:inline-flex; align-items:center; justify-content:center;
      margin:4px; font-weight:700; border:1px solid #2d3b73; background:#0f1733;
    }
    .die.blue { outline:2px solid rgba(86,161,255,.65); }
    .die.yellow { outline:2px solid rgba(255,219,86,.65); }
    .die.red { outline:2px solid rgba(255,97,97,.65); }
    .die.black { outline:2px solid rgba(170,170,170,.35); }
    textarea { width:100%; min-height:120px; border-radius:10px; background:#0f1733; border:1px solid #2d3b73; color:#e8ecff; padding:10px; }
    .hr { height:1px; background:#23305a; margin:10px 0; }
  </style>
</head>
<body>
  <h1>Sonic Roll ‚Äì Rules Engine + Web App (Prototype)</h1>
  <p class="muted">Implements the core loop: Roll Action ‚Üí Spend ‚Üí (Reroll/Boost/Badnik/Hazard) ‚Üí End Turn. Built to be extended with real card data.</p>

  <div class="row">
    <div class="card" style="flex:1; min-width:320px;">
      <h2>Game Controls</h2>
      <div class="row">
        <button id="newGameBtn">New Game</button>
        <label class="pill tiny">Players
          <select id="playerCount">
            <option>1</option><option selected>2</option><option>3</option><option>4</option>
          </select>
        </label>
        <label class="pill tiny">Seed
          <input id="seed" value="12345" size="8" />
        </label>
      </div>
      <div class="hr"></div>
      <div id="gameSummary" class="tiny"></div>
      <div class="hr"></div>
      <div class="row">
        <button id="btnChooseRollAction">Choose Roll Action</button>
        <select id="rollActionSelect"></select>
        <button id="btnBuildPool">Roll / Build Dice Pool</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="btnBoostAfterRollAction">Spend Boost (After Roll Action ‚Üí Reroll Step)</button>
        <button id="btnSpendDie">Spend Selected Die</button>
        <button id="btnRerollStep">Reroll Step</button>
        <button id="btnBoostInReroll">Spend Boost (Reroll Again)</button>
        <button id="btnEndTurn">End Turn (Discard + Time)</button>
      </div>

      <div class="hr"></div>
      <div class="tiny">
        <div><span class="badge">Phase</span> <span id="phase"></span></div>
        <div><span class="badge">Active Player</span> <span id="activePlayer"></span></div>
        <div><span class="badge">Invulnerable</span> <span id="invuln"></span></div>
      </div>

      <div class="hr"></div>
      <h2>Dice Pool</h2>
      <div id="dicePool"></div>
      <div class="tiny muted">Click a die to select it for spending.</div>
    </div>

    <div class="card" style="flex:1; min-width:320px;">
      <h2>Zone (Simplified)</h2>
      <p class="tiny muted">This prototype uses a simplified 3-route ‚Äúchallenge track‚Äù so the rules engine can be exercised. You can replace the generator with real Zone Card data later.</p>
      <div id="zoneView" class="grid"></div>
    </div>

    <div class="card" style="flex:1; min-width:320px;">
      <h2>Badniks (Simplified)</h2>
      <p class="tiny muted">Badniks attack only on rerolled dice. Destroy/Avoid are simplified here.</p>
      <div id="badnikView"></div>
      <div class="hr"></div>
      <h2>Log</h2>
      <div id="log" class="log mono"></div>
    </div>
  </div>

  <div class="row" style="margin-top:12px;">
    <div class="card" style="flex:1; min-width:680px;">
      <h2>Config (Editable)</h2>
      <p class="tiny muted">You can edit roll actions and sample decks here, then click <span class="mono">Apply Config</span>.</p>
      <textarea id="configBox" class="mono"></textarea>
      <div class="row" style="margin-top:8px;">
        <button id="applyConfigBtn">Apply Config</button>
      </div>
    </div>
  </div>

<script>
/** -------------------------
 *  RNG (seeded)
 *  ------------------------- */
function mulberry32(seed) {
  let a = seed >>> 0;
  return function() {
    a += 0x6D2B79F5;
    let t = a;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function hashSeed(str) {
  // simple string->uint32
  let h = 2166136261 >>> 0;
  for (let i=0;i<str.length;i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

/** -------------------------
 *  Core Types
 *  ------------------------- */
const DieColor = Object.freeze({ BLUE:"blue", YELLOW:"yellow", RED:"red", BLACK:"black" });

function rollD6(rng){ return 1 + Math.floor(rng()*6); }

function makeDie(color, value, meta={}) {
  return { id: crypto.randomUUID(), color, value, meta };
}

function clone(obj) { return JSON.parse(JSON.stringify(obj)); }

/** -------------------------
 *  Default Config
 *  ------------------------- */
const DEFAULT_CONFIG = {
  // Roll actions are not fully visible in the PDF pages you shared; this is a sane placeholder set.
  // Replace with exact dashboard data later (this app is built for it).
  characters: {
    Sonic: {
      ability: "Insta-Shield (prototype stub)",
      rollActions: [
        { name:"Jump Dash", dice:{ blue:2, yellow:1, red:1 }, build:"rollAllOnce" },
        { name:"Spin It Out", dice:{ red:3, blue:1 }, build:"rollAllOnce" },
        { name:"Run Again", dice:{ blue:4 }, build:"rollAllOnce" }
      ]
    },
    Tails: {
      ability: "Buddy Flight (prototype stub)",
      rollActions: [
        { name:"Sky Lift", dice:{ yellow:2, blue:2 }, build:"rollAllOnce" },
        { name:"Gadget Roll", dice:{ blue:3, red:1 }, build:"rollAllOnce" },
        { name:"Assist Mode", dice:{ blue:2, yellow:1, red:1 }, build:"rollAllOnce" }
      ]
    },
    Knuckles: {
      ability: "Secret Passage (prototype stub)",
      rollActions: [
        { name:"Wall Climb (simplified)", dice:{ red:1, blue:1, yellow:1 }, build:"repeatKeepAscending", repeats:3, keepPerRepeat:1 },
        { name:"Punch Through", dice:{ red:3, yellow:1 }, build:"rollAllOnce" },
        { name:"Glide Route", dice:{ blue:2, yellow:2 }, build:"rollAllOnce" }
      ]
    },
    Amy: {
      ability: "Piko Piko Hammer (prototype stub)",
      rollActions: [
        { name:"Hammer Time", dice:{ red:2, yellow:1, blue:1 }, build:"rollAllOnce" },
        { name:"Heart Dash", dice:{ yellow:3, blue:1 }, build:"rollAllOnce" },
        { name:"Smash & Spin", dice:{ red:3, blue:1 }, build:"rollAllOnce" }
      ]
    }
  },

  // Simplified Badnik deck: attacks are (color,value) pairs. Penalty is 1 damage.
  badnikDeck: [
    { name:"Moto Bug", attacks:[{color:"blue", value:6},{color:"blue", value:3}], avoid:{color:"blue", value:1}, destroy:{color:"red", value:1} },
    { name:"Crabmeat", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:2} },
    { name:"Buzz Bomber", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:3} }
  ],

  // Simplified Zone: 3 routes, each a list of challenges. Each challenge: {n, color|null, reward}
  // reward types: rings, boost, hazard, badnik
  zoneGenerator: { challengesPerRoute: 6 }
};

/** -------------------------
 *  Engine: Game State
 *  ------------------------- */
function newGame({ playerCount, seedStr, config }) {
  const seed = hashSeed(seedStr);
  const rng = mulberry32(seed);

  const chars = Object.keys(config.characters);
  const players = Array.from({length: playerCount}, (_,i) => ({
    id: i,
    name: `P${i+1}`,
    character: chars[i % chars.length],
    lives: 3,            // per rulebook setup: 3 life tokens
    boost: 1,            // per rulebook setup: 1 boost token
    heldRings: 0,
    savedRings: 0,
    badniks: [],
    dicePool: [],
    invulnerable: false,
    selectedDieId: null,
    lastSpentWasRun: false
  }));

  const badnikDeck = shuffle(clone(config.badnikDeck), rng);
  const zone = generateZone(config.zoneGenerator, rng);

  return {
    config: clone(config),
    seedStr,
    rngSeed: seed,
    rngStateNote: "mulberry32(seed) - deterministic sequence",
    phase: "ROLL_ACTION", // ROLL_ACTION | SPENDING | REROLL | END_TURN | GAME_OVER
    activePlayer: 0,
    timeTokens: 7, // from setup; you can adjust per zone/act
    badnikDeck,
    badnikDiscard: [],
    zone,
    log: [`Game started (${playerCount}P), seed="${seedStr}"`],
  };
}

function shuffle(arr, rng) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function generateZone(genCfg, rng) {
  // 3 routes, each a list of challenges with occasional color requirement.
  const routes = ["Top","Mid","Bot"].map(routeName => {
    const challenges = [];
    for (let i=0;i<genCfg.challengesPerRoute;i++) {
      const n = rollD6(rng);
      const colorPick = rng();
      const color = colorPick < 0.2 ? DieColor.BLUE : colorPick < 0.4 ? DieColor.YELLOW : colorPick < 0.6 ? DieColor.RED : null;
      const rewardRoll = rng();
      const reward =
        rewardRoll < 0.55 ? { type:"rings", amount: (rng()<0.2?5:1) } :
        rewardRoll < 0.7  ? { type:"boost", amount:1 } :
        rewardRoll < 0.85 ? { type:"badnik", amount:1 } :
                            { type:"hazard", amount:1 };

      challenges.push({ id: crypto.randomUUID(), n, color, cleared:false, reward });
    }
    return { id: crypto.randomUUID(), name: routeName, idx: 0, challenges };
  });
  return { routes };
}

/** -------------------------
 *  Engine Helpers
 *  ------------------------- */
function getP(state){ return state.players ? state.players[state.activePlayer] : null; }
function withRng(state) {
  // recreate RNG each time from seed + "log length" is NOT safe; so we store a closure on window-level.
  // For this prototype: we keep a global rng closure per game instance.
  // See initGameRng() below.
  return state;
}

let __rng = null;
function initGameRng(state) {
  __rng = mulberry32(state.rngSeed);
  // Advance RNG by consuming a small number based on log length to keep determinism across refresh? Not needed here.
}
function rng(){ return __rng; }

function log(state, msg) {
  state.log.push(msg);
  return state;
}

function isGameOver(state) {
  if (state.timeTokens <= 0) return "Time ran out (0 Time Tokens)";
  for (const p of state.players) if (p.lives <= 0) return `${p.name} lost final Life`;
  return null;
}

/** -------------------------
 *  Damage rules (core)
 *  - Lose all held rings; if none, lose a life.
 *  - Clear badniks and dice pool; end turn without taking time token.
 *  - Become invulnerable until next spend/reroll/end-turn completes (prototype flag)
 *  ------------------------- */
function takeDamage(state, reason) {
  const p = state.players[state.activePlayer];

  if (p.invulnerable) {
    return log(state, `No damage (invulnerable): ${reason}`);
  }

  const lostHeld = p.heldRings;
  p.heldRings = 0;

  if (lostHeld === 0) {
    p.lives -= 1;
    log(state, `üí• DAMAGE (${reason}): No held rings ‚Üí ${p.name} loses 1 Life (now ${p.lives})`);
  } else {
    log(state, `üí• DAMAGE (${reason}): ${p.name} loses all Held Rings (${lostHeld})`);
  }

  // Clear badniks and dice pool and end turn (no time token)
  p.badniks = [];
  p.dicePool = [];
  p.selectedDieId = null;
  p.lastSpentWasRun = false;

  // Become invulnerable "for a moment" (until next spend/reroll/end turn makes them vulnerable again)
  p.invulnerable = true;

  state.phase = "END_TURN";
  const over = isGameOver(state);
  if (over) {
    state.phase = "GAME_OVER";
    log(state, `üõë GAME OVER: ${over}`);
  } else {
    log(state, `Turn ends immediately (no Time Token taken).`);
  }
  return state;
}

function makeVulnerable(p) { p.invulnerable = false; }

/** -------------------------
 *  Actions
 *  ------------------------- */
function chooseRollAction(state, actionName) {
  const p = state.players[state.activePlayer];
  p.chosenRollAction = actionName;
  log(state, `${p.name} chose Roll Action: ${actionName}`);
  return state;
}

function buildDicePool(state) {
  if (state.phase !== "ROLL_ACTION") {
    return log(state, `Cannot build pool: phase is ${state.phase}`);
  }
  const p = state.players[state.activePlayer];
  const charCfg = state.config.characters[p.character];
  const ra = charCfg.rollActions.find(x => x.name === p.chosenRollAction) || charCfg.rollActions[0];

  if (!ra) return log(state, `No roll action available.`);

  const pool = [];
  const r = rng();

  const diceCounts = ra.dice || {};
  const makeDiceBatch = () => {
    const batch = [];
    for (const [c, count] of Object.entries(diceCounts)) {
      for (let i=0;i<count;i++) batch.push(makeDie(c, rollD6(r)));
    }
    return batch;
  };

  if (ra.build === "rollAllOnce") {
    pool.push(...makeDiceBatch());
  } else if (ra.build === "repeatKeepAscending") {
    // simplified: each repeat roll batch, keep one die with value > last kept
    let last = 0;
    for (let rep=0; rep<(ra.repeats||3); rep++) {
      const batch = makeDiceBatch();
      batch.sort((a,b)=>a.value-b.value);
      const keep = batch.find(d => d.value > last);
      if (keep) {
        pool.push(keep);
        last = keep.value;
      } else {
        // if cannot keep, keep highest anyway (prototype-friendly)
        const fallback = batch[batch.length-1];
        pool.push(fallback);
        last = fallback.value;
      }
    }
  } else {
    pool.push(...makeDiceBatch());
  }

  p.dicePool = pool;
  p.selectedDieId = null;
  p.lastSpentWasRun = false;
  makeVulnerable(p); // building pool itself is "safe" but they aren't invulnerable unless damage happened

  state.phase = "SPENDING";
  log(state, `${p.name} built Dice Pool: ${pool.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);
  return state;
}

// Boost after Roll Action: reroll pool, immediately goes to REROLL step and becomes vulnerable to badnik attacks
function boostAfterRollAction(state) {
  const p = state.players[state.activePlayer];
  if (p.boost <= 0) return log(state, `${p.name} has no Boost tokens.`);
  if (!(state.phase === "SPENDING" || state.phase === "ROLL_ACTION")) return log(state, `Boost-after-roll-action is only meaningful right after building the pool (prototype allows in SPENDING).`);

  p.boost -= 1;
  log(state, `${p.name} spends 1 Boost (after Roll Action) ‚Üí reroll Dice Pool and enter REROLL step (Badnik-vulnerable).`);
  state.phase = "REROLL";
  return rerollStep(state, { fromBoost:true });
}

function spendSelectedDie(state) {
  const p = state.players[state.activePlayer];
  if (state.phase !== "SPENDING") return log(state, `Cannot spend: phase is ${state.phase}`);
  if (!p.dicePool.length) {
    state.phase = "END_TURN";
    return log(state, `No dice left ‚Üí End Turn`);
  }
  const die = p.dicePool.find(d => d.id === p.selectedDieId) || p.dicePool[0];

  // Determine legal spend in simplified model: you may spend on leftmost uncleared challenge of ANY route, if number matches and (if colored) color matches
  const legalTargets = [];
  for (const route of state.zone.routes) {
    const idx = route.challenges.findIndex(ch => !ch.cleared);
    if (idx === -1) continue;
    const ch = route.challenges[idx];
    const colorOk = (ch.color == null) || (ch.color === die.color);
    const numOk = (ch.n === die.value);
    if (colorOk && numOk) legalTargets.push({ route, ch });
  }

  // Also allow spending on badniks (simplified): match destroy/avoid exactly
  const legalBadnikTargets = [];
  for (let i=0;i<p.badniks.length;i++) {
    const b = p.badniks[i];
    const avoidOk = b.avoid && (b.avoid.color === die.color && b.avoid.value === die.value);
    const destroyOk = b.destroy && (die.color === DieColor.RED && b.destroy.value === die.value);
    if (avoidOk || destroyOk) legalBadnikTargets.push({ idx:i, badnik:b, mode: destroyOk ? "destroy" : "avoid" });
  }

  if (!legalTargets.length && !legalBadnikTargets.length) {
    // If cannot spend and no other way -> damage
    return takeDamage(state, "Could not spend a die during Spending Step");
  }

  // Choose a target automatically for prototype: prefer clearing zone, else badnik
  if (legalTargets.length) {
    const { route, ch } = legalTargets[0];
    ch.cleared = true;
    log(state, `${p.name} spends ${die.color.toUpperCase()}-${die.value} to clear ${route.name} challenge (requires ${ch.color?ch.color.toUpperCase()+"-":""}${ch.n}).`);

    // Apply reward
    applyReward(state, ch.reward);

  } else {
    const t = legalBadnikTargets[0];
    const b = t.badnik;
    if (t.mode === "destroy") {
      // Destroy with spin die (red) gives animal token (we just log)
      log(state, `${p.name} DESTROYS Badnik "${b.name}" with RED-${die.value} ‚Üí gains 1 Animal Token (scoring).`);
    } else {
      log(state, `${p.name} AVOIDS Badnik "${b.name}" with ${die.color.toUpperCase()}-${die.value}.`);
    }
    p.badniks.splice(t.idx, 1);
  }

  // Remove die from pool
  p.dicePool = p.dicePool.filter(d => d.id !== die.id);
  p.selectedDieId = null;

  // Dice properties
  p.lastSpentWasRun = (die.color === DieColor.BLUE);
  if (die.color === DieColor.YELLOW) {
    p.heldRings += 1;
    log(state, `+1 Ring (Jump die spent). Held Rings = ${p.heldRings}`);
  }

  // Spending makes player vulnerable again (per invulnerability rules)
  makeVulnerable(p);

  if (!p.dicePool.length) {
    state.phase = "END_TURN";
    return log(state, `Dice Pool empty ‚Üí End Turn`);
  }

  // Run die allows optional extra spend without reroll
  if (die.color === DieColor.BLUE) {
    log(state, `Run die property: ${p.name} may spend another die without rerolling.`);
    // remain in SPENDING, let user click spend again
    state.phase = "SPENDING";
    return state;
  }

  // Otherwise must proceed to reroll step
  state.phase = "REROLL";
  return log(state, `Must REROLL remaining dice before next spend.`);
}

function applyReward(state, reward) {
  const p = state.players[state.activePlayer];
  if (!reward) return;
  if (reward.type === "rings") {
    p.heldRings += reward.amount;
    log(state, `Reward: +${reward.amount} Rings (Held=${p.heldRings})`);
  } else if (reward.type === "boost") {
    p.boost += reward.amount;
    log(state, `Reward: +${reward.amount} Boost (Boost=${p.boost})`);
  } else if (reward.type === "badnik") {
    for (let i=0;i<reward.amount;i++) drawBadnik(state, p);
  } else if (reward.type === "hazard") {
    // immediate hazard roll(s)
    for (let i=0;i<reward.amount;i++) hazardRoll(state);
  }
}

function hazardRoll(state) {
  const p = state.players[state.activePlayer];
  const v = rollD6(rng());
  log(state, `‚ö†Ô∏è Hazard Die rolled: ${v}`);
  // If result matches ANY number currently in dice pool -> damage
  if (p.dicePool.some(d => d.value === v)) {
    takeDamage(state, `Hazard matched a die value (${v})`);
  } else {
    log(state, `Hazard did not match Dice Pool ‚Üí no damage.`);
  }
}

function drawBadnik(state, p) {
  if (p.badniks.length >= 3) {
    log(state, `${p.name} cannot draw more Badniks (already 3).`);
    return;
  }
  if (!state.badnikDeck.length) {
    state.badnikDeck = shuffle(state.badnikDiscard, rng());
    state.badnikDiscard = [];
    log(state, `Badnik deck reshuffled from discard.`);
  }
  const b = state.badnikDeck.shift();
  p.badniks.push(b);
  log(state, `${p.name} draws Badnik: ${b.name}`);
}

function rerollStep(state, { fromBoost=false } = {}) {
  const p = state.players[state.activePlayer];
  if (state.phase !== "REROLL") return log(state, `Cannot reroll: phase is ${state.phase}`);
  if (!p.dicePool.length) {
    state.phase = "END_TURN";
    return log(state, `No dice to reroll ‚Üí End Turn`);
  }

  // Reroll all remaining dice
  for (const d of p.dicePool) d.value = rollD6(rng());
  log(state, `${p.name} rerolls Dice Pool: ${p.dicePool.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);

  // After reroll, player becomes vulnerable again (reroll ends invulnerability window)
  makeVulnerable(p);

  // Badnik attacks apply to rerolled dice
  if (p.badniks.length) {
    const hits = [];
    for (const b of p.badniks) {
      for (const atk of (b.attacks||[])) {
        const matched = p.dicePool.some(d => d.color === atk.color && d.value === atk.value);
        if (matched) hits.push({ b, atk });
      }
    }
    if (hits.length) {
      // first hit deals damage; additional hits ignored until next spend/reroll/end (invulnerability rule)
      log(state, `üü• Badnik attack hits: ${hits.map(h=>`${h.b.name}(${h.atk.color[0].toUpperCase()}${h.atk.value})`).join(", ")}`);
      takeDamage(state, `Badnik attack`);
      return state;
    } else {
      log(state, `No Badnik attacks hit.`);
    }
  } else {
    log(state, `No Badniks in front of ${p.name}.`);
  }

  // Hazard dice are not automatically rolled every reroll in the real game; they occur from rewards and black dice.
  // Prototype leaves hazard to rewards only.

  // Return to spending
  state.phase = "SPENDING";
  return state;
}

function boostInReroll(state) {
  const p = state.players[state.activePlayer];
  if (state.phase !== "REROLL") return log(state, `Boost-in-reroll only usable in REROLL phase.`);
  if (p.boost <= 0) return log(state, `${p.name} has no Boost tokens.`);
  p.boost -= 1;
  log(state, `${p.name} spends 1 Boost ‚Üí immediately reroll Dice Pool again.`);
  // In the rulebook, Badnik REROLL abilities do not trigger on boost; we‚Äôre not modelling abilities here.
  return rerollStep(state, { fromBoost:true });
}

function endTurn(state, { dueToDamage=false } = {}) {
  const p = state.players[state.activePlayer];
  if (state.phase === "GAME_OVER") return state;

  if (!dueToDamage) {
    // If dice remain, discarding costs a time token (manual)
    if (p.dicePool.length) {
      p.dicePool = [];
      p.selectedDieId = null;
      state.timeTokens -= 1;
      log(state, `${p.name} ends turn with dice remaining ‚Üí discard dice and take 1 Time Token (Time left: ${state.timeTokens}).`);
    } else {
      log(state, `${p.name} ends turn.`);
    }
  }

  // Make vulnerable at end of turn (invulnerability ends after end turn / spend / reroll)
  makeVulnerable(p);
  p.lastSpentWasRun = false;

  const over = isGameOver(state);
  if (over) {
    state.phase = "GAME_OVER";
    log(state, `üõë GAME OVER: ${over}`);
    return state;
  }

  // Pass to next player
  state.activePlayer = (state.activePlayer + 1) % state.players.length;
  state.phase = "ROLL_ACTION";
  const np = state.players[state.activePlayer];
  np.chosenRollAction = np.chosenRollAction || state.config.characters[np.character].rollActions[0].name;
  log(state, `‚û°Ô∏è Turn passes to ${np.name} (${np.character}).`);
  return state;
}

/** -------------------------
 *  UI Wiring
 *  ------------------------- */
let STATE = null;

function render() {
  const s = STATE;
  if (!s) return;

  // Summary
  const p = s.players[s.activePlayer];
  document.getElementById("phase").textContent = s.phase;
  document.getElementById("activePlayer").textContent =
    `${p.name} (${p.character}) | Lives=${p.lives} | Boost=${p.boost} | HeldRings=${p.heldRings} | SavedRings=${p.savedRings} | Badniks=${p.badniks.length} | Time=${s.timeTokens}`;
  document.getElementById("invuln").textContent = p.invulnerable ? "YES" : "NO";

  // Buttons enable/disable
  const setDisabled = (id, dis) => document.getElementById(id).disabled = !!dis;

  setDisabled("btnChooseRollAction", s.phase !== "ROLL_ACTION");
  setDisabled("btnBuildPool", s.phase !== "ROLL_ACTION");
  setDisabled("btnBoostAfterRollAction", !(p.boost>0 && (s.phase==="SPENDING" || s.phase==="ROLL_ACTION") && p.dicePool.length));
  setDisabled("btnSpendDie", s.phase !== "SPENDING");
  setDisabled("btnRerollStep", s.phase !== "REROLL");
  setDisabled("btnBoostInReroll", !(s.phase==="REROLL" && p.boost>0));
  setDisabled("btnEndTurn", !(s.phase==="SPENDING" || s.phase==="REROLL" || s.phase==="END_TURN"));

  // Roll action select
  const raSel = document.getElementById("rollActionSelect");
  raSel.innerHTML = "";
  const raList = s.config.characters[p.character].rollActions;
  for (const ra of raList) {
    const opt = document.createElement("option");
    opt.value = ra.name;
    opt.textContent = ra.name;
    raSel.appendChild(opt);
  }
  raSel.value = p.chosenRollAction || raList[0].name;

  // Dice pool
  const dp = document.getElementById("dicePool");
  dp.innerHTML = "";
  for (const d of p.dicePool) {
    const el = document.createElement("div");
    el.className = `die ${d.color}`;
    el.textContent = d.value;
    el.title = d.color;
    el.style.opacity = (p.selectedDieId === d.id) ? "1" : "0.8";
    el.style.transform = (p.selectedDieId === d.id) ? "scale(1.05)" : "scale(1)";
    el.addEventListener("click", () => { p.selectedDieId = d.id; render(); });
    dp.appendChild(el);
  }

  // Zone view
  const zv = document.getElementById("zoneView");
  zv.innerHTML = "";
  for (const route of s.zone.routes) {
    const card = document.createElement("div");
    card.className = "card";
    const idx = route.challenges.findIndex(ch => !ch.cleared);
    const next = idx === -1 ? null : route.challenges[idx];
    card.innerHTML = `
      <h2>${route.name} Route</h2>
      <div class="tiny">
        Next challenge: ${
          next
            ? `<span class="pill">${next.color ? next.color.toUpperCase()+"-" : ""}${next.n}</span>
               <span class="muted">Reward:</span> <span class="pill">${next.reward.type}${next.reward.amount?(" x"+next.reward.amount):""}</span>`
            : `<span class="ok">Completed</span>`
        }
      </div>
      <div class="tiny muted" style="margin-top:8px;">Track:</div>
      <div class="tiny mono">${route.challenges.map(ch => ch.cleared ? "‚úì" : (ch.color?ch.color[0].toUpperCase():"_")+ch.n).join("  ")}</div>
    `;
    zv.appendChild(card);
  }

  // Badnik view
  const bv = document.getElementById("badnikView");
  bv.innerHTML = "";
  if (!p.badniks.length) {
    bv.innerHTML = `<div class="tiny muted">No Badniks.</div>`;
  } else {
    for (const b of p.badniks) {
      const el = document.createElement("div");
      el.className = "pill tiny";
      el.innerHTML = `<b>${b.name}</b>
        <span class="muted">attacks:</span> ${b.attacks.map(a=>`${a.color[0].toUpperCase()}${a.value}`).join(", ")}
        <span class="muted">avoid:</span> ${b.avoid.color[0].toUpperCase()}${b.avoid.value}
        <span class="muted">destroy:</span> R${b.destroy.value}`;
      bv.appendChild(el);
    }
  }

  // Log
  const logEl = document.getElementById("log");
  logEl.innerHTML = s.log.slice(-250).map(line => `<div>${escapeHtml(line)}</div>`).join("");
  logEl.scrollTop = logEl.scrollHeight;

  // Game summary
  document.getElementById("gameSummary").innerHTML =
    s.players.map(pp => `<div class="pill tiny"><b>${pp.name}</b> ${pp.character} | Lives=${pp.lives} | Boost=${pp.boost} | HeldR=${pp.heldRings} | Badniks=${pp.badniks.length}</div>`).join("");

  // Config box
  document.getElementById("configBox").value = JSON.stringify(s.config, null, 2);
}

function escapeHtml(str) {
  return str.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}

/** -------------------------
 *  UI Events
 *  ------------------------- */
document.getElementById("newGameBtn").addEventListener("click", () => {
  const playerCount = parseInt(document.getElementById("playerCount").value, 10);
  const seedStr = document.getElementById("seed").value || "12345";
  const config = STATE?.config ? STATE.config : clone(DEFAULT_CONFIG);

  STATE = newGame({ playerCount, seedStr, config });
  // attach players array in state (we created inside newGame, but omitted earlier for brevity)
  // fix: newGame returns without players? ensure it has players:
  // We'll rehydrate from log? Actually we need players in state, so patch:
  // (keeping safe: if missing, rebuild)
  if (!STATE.players) {
    // shouldn't happen
    console.warn("State.players missing; patching.");
  }
  // in our newGame, players are created in function scope but not returned due to oversight? Let's patch:
});

(function patchNewGameReturnBug() {
  const _newGame = newGame;
  newGame = function(args) {
    const state = _newGame(args);
    // The earlier newGame() created players but didn't return them ‚Äì fix by reconstructing here if needed.
    if (!state.players) {
      // reconstruct using config + args
      const { playerCount, config } = args;
      const chars = Object.keys(config.characters);
      state.players = Array.from({length: playerCount}, (_,i) => ({
        id: i,
        name: `P${i+1}`,
        character: chars[i % chars.length],
        lives: 3,
        boost: 1,
        heldRings: 0,
        savedRings: 0,
        badniks: [],
        dicePool: [],
        invulnerable: false,
        selectedDieId: null,
        lastSpentWasRun: false,
        chosenRollAction: config.characters[chars[i % chars.length]].rollActions[0].name
      }));
    }
    initGameRng(state);
    return state;
  };
})();

document.getElementById("newGameBtn").click();

document.getElementById("btnChooseRollAction").addEventListener("click", () => {
  const s = STATE;
  const p = s.players[s.activePlayer];
  const raName = document.getElementById("rollActionSelect").value;
  chooseRollAction(s, raName);
  render();
});

document.getElementById("btnBuildPool").addEventListener("click", () => {
  buildDicePool(STATE);
  render();
});

document.getElementById("btnBoostAfterRollAction").addEventListener("click", () => {
  boostAfterRollAction(STATE);
  render();
});

document.getElementById("btnSpendDie").addEventListener("click", () => {
  spendSelectedDie(STATE);
  render();
});

document.getElementById("btnRerollStep").addEventListener("click", () => {
  rerollStep(STATE);
  render();
});

document.getElementById("btnBoostInReroll").addEventListener("click", () => {
  boostInReroll(STATE);
  render();
});

document.getElementById("btnEndTurn").addEventListener("click", () => {
  endTurn(STATE);
  render();
});

document.getElementById("applyConfigBtn").addEventListener("click", () => {
  try {
    const parsed = JSON.parse(document.getElementById("configBox").value);
    STATE.config = parsed;
    log(STATE, "Config applied.");
    render();
  } catch (e) {
    alert("Invalid JSON in config box: " + e.message);
  }
});

render();
</script>
</body>
</html>
