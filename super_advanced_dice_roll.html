<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Physics Dice Tray (Three.js + cannon-es)</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #f6f7fb;
            font-family: system-ui, sans-serif;
        }

        canvas {
            display: block;
        }

        #ui {
            position: fixed;
            left: 12px;
            top: 12px;
            z-index: 20;
            background: rgba(255, 255, 255, .92);
            border: 1px solid #ddd;
            border-radius: 14px;
            padding: 10px 12px;
            box-shadow: 0 12px 28px rgba(0, 0, 0, .10);
            display: grid;
            gap: 8px;
            min-width: 280px;
            backdrop-filter: blur(6px);
        }

        #row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        button,
        select,
        input[type="checkbox"] {
            font: inherit;
        }

        button {
            padding: 8px 12px;
            border-radius: 12px;
            border: 1px solid #ccc;
            background: white;
            cursor: pointer;
            font-weight: 650;
        }

        button:active {
            transform: translateY(1px);
        }

        select {
            padding: 7px 10px;
            border-radius: 12px;
            border: 1px solid #ccc;
            background: white;
            font-weight: 600;
        }

        .label {
            font-size: 12px;
            color: #444;
        }

        #status {
            font-weight: 750;
        }

        #sum {
            font-weight: 850;
        }

        #history {
            max-height: 220px;
            overflow: auto;
            border-top: 1px solid #eee;
            padding-top: 8px;
            display: grid;
            gap: 6px;
            font-size: 13px;
        }

        .histItem {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            padding: 6px 8px;
            border: 1px solid #eee;
            border-radius: 12px;
            background: #fff;
        }

        .pill {
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid #eee;
            font-weight: 800;
        }

        #hint {
            position: fixed;
            right: 12px;
            bottom: 12px;
            z-index: 10;
            background: rgba(255, 255, 255, .86);
            border: 1px solid #ddd;
            border-radius: 14px;
            padding: 8px 10px;
            box-shadow: 0 12px 28px rgba(0, 0, 0, .08);
            font-size: 12px;
            color: #333;
        }
    </style>

    <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
      "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
    }
  }
  </script>
</head>

<body>
    <div id="ui">
        <div id="row">
            <button id="rollBtn">Roll üé≤</button>
            <button id="clearBtn">Clear</button>
        </div>

        <div id="row">
            <div>
                <div class="label">Dice</div>
                <select id="diceCount">
                    <option>1</option>
                    <option>2</option>
                    <option>3</option>
                    <option>4</option>
                    <option>5</option>
                    <option>1000</option>
                </select>
            </div>

            <div style="margin-left:auto; display:flex; flex-direction:column; gap:2px;">
                <div class="label">Status</div>
                <div id="status">Ready</div>
            </div>
        </div>

        <div id="row" style="align-items:center;">
            <label style="display:flex; align-items:center; gap:8px;">
                <input id="clickToRoll" type="checkbox" checked />
                <span class="label" style="font-size:13px;">Click tray to roll</span>
            </label>

            <label style="display:flex; align-items:center; gap:8px; margin-left:auto;">
                <input id="soundOn" type="checkbox" checked />
                <span class="label" style="font-size:13px;">Sound</span>
            </label>
        </div>

        <div id="row">
            <div>Last result: <span id="last" style="font-weight:850;">‚Äî</span></div>
            <div style="margin-left:auto;">Sum: <span id="sum">‚Äî</span></div>
        </div>

        <div id="history"></div>
    </div>

    <div id="hint">Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Space = roll</div>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { RoundedBoxGeometry } from "three/addons/geometries/RoundedBoxGeometry.js";
        import * as CANNON from "cannon-es";

        // ---------- Audio (simple "clack") ----------
        let audioCtx = null;
        function playClack(enabled) {
            if (!enabled) return;
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const ctx = audioCtx;

            const o = ctx.createOscillator();
            const g = ctx.createGain();

            o.type = "square";
            o.frequency.value = 180 + Math.random() * 140;

            // fast transient
            g.gain.setValueAtTime(0.0001, ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.15, ctx.currentTime + 0.01);
            g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.08);

            o.connect(g).connect(ctx.destination);
            o.start();
            o.stop(ctx.currentTime + 0.09);
        }

        // ---------- Three.js ----------
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf6f7fb);

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(7, 7, 9);
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.0, 0);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI * 0.49;
        controls.minDistance = 5;
        controls.maxDistance = 20;

        // Lighting
        const hemi = new THREE.HemisphereLight(0xffffff, 0x667788, 0.7);
        scene.add(hemi);

        const key = new THREE.DirectionalLight(0xffffff, 0.9);
        key.position.set(8, 12, 5);
        key.castShadow = true;
        key.shadow.mapSize.width = 2048;
        key.shadow.mapSize.height = 2048;
        key.shadow.camera.near = 0.5;
        key.shadow.camera.far = 50;
        key.shadow.camera.left = -12;
        key.shadow.camera.right = 12;
        key.shadow.camera.top = 12;
        key.shadow.camera.bottom = -12;
        scene.add(key);

        // ---------- Physics ----------
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
        world.allowSleep = true;

        const diceMat = new CANNON.Material("dice");
        const trayMat = new CANNON.Material("tray");

        // A touch of bounce, decent friction
        world.defaultContactMaterial = new CANNON.ContactMaterial(diceMat, trayMat, {
            friction: 0.45,
            restitution: 0.18,
        });

        // ---------- Dice Tray (visual + physics) ----------
        const tray = {
            innerW: 10,
            innerD: 10,
            wallT: 0.45,
            wallH: 1.1,
            baseY: 0,
        };

        // Visual: base (felt-ish)
        const baseGeo = new THREE.BoxGeometry(tray.innerW + tray.wallT * 2, 0.4, tray.innerD + tray.wallT * 2);
        const baseMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.95, metalness: 0.0 });
        const baseMesh = new THREE.Mesh(baseGeo, baseMat);
        baseMesh.position.set(0, tray.baseY - 0.2, 0);
        baseMesh.receiveShadow = true;
        baseMesh.castShadow = false;
        scene.add(baseMesh);

        // Visual: inner floor (slightly darker panel)
        const floorGeo = new THREE.PlaneGeometry(tray.innerW, tray.innerD);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.98, metalness: 0.0 });
        const floorMesh = new THREE.Mesh(floorGeo, floorMat);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = tray.baseY + 0.001;
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);

        // Visual: rim walls (4 boxes)
        const wallMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.75, metalness: 0.0 });
        function addWallMesh(w, h, d, x, y, z) {
            const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
            m.position.set(x, y, z);
            m.castShadow = true;
            m.receiveShadow = true;
            scene.add(m);
            return m;
        }

        const wallY = tray.baseY + tray.wallH / 2;
        addWallMesh(tray.innerW + tray.wallT * 2, tray.wallH, tray.wallT, 0, wallY, -(tray.innerD / 2 + tray.wallT / 2));
        addWallMesh(tray.innerW + tray.wallT * 2, tray.wallH, tray.wallT, 0, wallY, (tray.innerD / 2 + tray.wallT / 2));
        addWallMesh(tray.wallT, tray.wallH, tray.innerD, -(tray.innerW / 2 + tray.wallT / 2), wallY, 0);
        addWallMesh(tray.wallT, tray.wallH, tray.innerD, (tray.innerW / 2 + tray.wallT / 2), wallY, 0);

        // Physics: base plane
        const groundBody = new CANNON.Body({ type: CANNON.Body.STATIC, shape: new CANNON.Plane(), material: trayMat });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        groundBody.position.set(0, tray.baseY, 0);
        world.addBody(groundBody);

        // Physics: walls (4 static boxes)
        function addWallBody(w, h, d, x, y, z) {
            const body = new CANNON.Body({
                type: CANNON.Body.STATIC,
                shape: new CANNON.Box(new CANNON.Vec3(w / 2, h / 2, d / 2)),
                position: new CANNON.Vec3(x, y, z),
                material: trayMat
            });
            world.addBody(body);
            return body;
        }
        addWallBody(tray.innerW + tray.wallT * 2, tray.wallH, tray.wallT, 0, wallY, -(tray.innerD / 2 + tray.wallT / 2));
        addWallBody(tray.innerW + tray.wallT * 2, tray.wallH, tray.wallT, 0, wallY, (tray.innerD / 2 + tray.wallT / 2));
        addWallBody(tray.wallT, tray.wallH, tray.innerD, -(tray.innerW / 2 + tray.wallT / 2), wallY, 0);
        addWallBody(tray.wallT, tray.wallH, tray.innerD, (tray.innerW / 2 + tray.wallT / 2), wallY, 0);

        // ---------- Dice textures ----------
        function makeFaceTextures(pips) {
            const size = 256;

            // ---------- helpers ----------
            const makeCanvas = () => {
                const c = document.createElement("canvas");
                c.width = c.height = size;
                return c;
            };

            // Convert a grayscale height map to a normal map (Sobel-ish gradient)
            function heightToNormal(heightCtx, strength = 2.0) {
                const src = heightCtx.getImageData(0, 0, size, size);
                const out = heightCtx.createImageData(size, size);

                const getH = (x, y) => {
                    x = Math.max(0, Math.min(size - 1, x));
                    y = Math.max(0, Math.min(size - 1, y));
                    // Use red channel (grayscale)
                    return src.data[(y * size + x) * 4] / 255; // 0..1
                };

                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        // Central differences
                        const dx = (getH(x + 1, y) - getH(x - 1, y)) * strength;
                        const dy = (getH(x, y + 1) - getH(x, y - 1)) * strength;

                        // Normal points opposite gradient for "indent"
                        let nx = -dx;
                        let ny = -dy;
                        let nz = 1.0;

                        const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
                        nx /= len; ny /= len; nz /= len;

                        const i = (y * size + x) * 4;
                        out.data[i + 0] = Math.round((nx * 0.5 + 0.5) * 255);
                        out.data[i + 1] = Math.round((ny * 0.5 + 0.5) * 255);
                        out.data[i + 2] = Math.round((nz * 0.5 + 0.5) * 255);
                        out.data[i + 3] = 255;
                    }
                }

                return out;
            }

            // ---------- diffuse (red die + white pips) ----------
            const diffuse = makeCanvas();
            const dctx = diffuse.getContext("2d");

            // Red die body
            dctx.fillStyle = "#c01818"; // red
            dctx.fillRect(0, 0, size, size);

            // Subtle edge vignette for depth
            const vignette = dctx.createRadialGradient(size * 0.5, size * 0.5, size * 0.20, size * 0.5, size * 0.5, size * 0.75);
            vignette.addColorStop(0, "rgba(255,255,255,0.06)");
            vignette.addColorStop(1, "rgba(0,0,0,0.18)");
            dctx.fillStyle = vignette;
            dctx.fillRect(0, 0, size, size);

            // Rounded border (slightly darker red)
            dctx.lineWidth = 18;
            dctx.strokeStyle = "rgba(0,0,0,0.20)";
            dctx.strokeRect(10, 10, size - 20, size - 20);

            // Pip positions
            const r = 18;
            const positions = {
                tl: [size * 0.28, size * 0.28],
                tr: [size * 0.72, size * 0.28],
                ml: [size * 0.28, size * 0.50],
                mr: [size * 0.72, size * 0.50],
                bl: [size * 0.28, size * 0.72],
                br: [size * 0.72, size * 0.72],
                c: [size * 0.50, size * 0.50],
            };
            const layout = {
                1: ["c"],
                2: ["tr", "bl"],
                3: ["tr", "c", "bl"],
                4: ["tl", "tr", "bl", "br"],
                5: ["tl", "tr", "c", "bl", "br"],
                6: ["tl", "ml", "bl", "tr", "mr", "br"],
            }[pips];

            // Draw white pips with a tiny inner shadow to sell the dimple
            for (const key of layout) {
                const [x, y] = positions[key];

                // soft shadow (very subtle)
                dctx.beginPath();
                dctx.arc(x, y, r + 2, 0, Math.PI * 2);
                dctx.fillStyle = "rgba(0,0,0,0.18)";
                dctx.fill();

                // white pip
                dctx.beginPath();
                dctx.arc(x, y, r, 0, Math.PI * 2);
                dctx.fillStyle = "#ffffff";
                dctx.fill();

                // slight highlight (keeps it white but gives curvature)
                const hg = dctx.createRadialGradient(x - r * 0.35, y - r * 0.35, r * 0.2, x, y, r);
                hg.addColorStop(0, "rgba(255,255,255,0.65)");
                hg.addColorStop(1, "rgba(255,255,255,0.00)");
                dctx.beginPath();
                dctx.arc(x, y, r, 0, Math.PI * 2);
                dctx.fillStyle = hg;
                dctx.fill();
            }

            // ---------- height map for dimples (white=high, dark=low) ----------
            const height = makeCanvas();
            const hctx = height.getContext("2d");

            // Base is "flat high"
            hctx.fillStyle = "rgb(128,128,128)";
            hctx.fillRect(0, 0, size, size);

            // Each pip is an indentation: center darker, edges feathered
            for (const key of layout) {
                const [x, y] = positions[key];

                // Create a radial gradient where center is low (dark) and outside is flat (mid)
                const g = hctx.createRadialGradient(x, y, 0, x, y, r * 1.15);
                g.addColorStop(0.0, "rgb(35,35,35)");    // deepest
                g.addColorStop(0.55, "rgb(90,90,90)");   // slope
                g.addColorStop(1.0, "rgb(128,128,128)"); // flat
                hctx.fillStyle = g;
                hctx.beginPath();
                hctx.arc(x, y, r * 1.2, 0, Math.PI * 2);
                hctx.fill();
            }

            // Turn height into a normal map
            const normalImg = heightToNormal(hctx, 3.0);
            const normalCanvas = makeCanvas();
            normalCanvas.getContext("2d").putImageData(normalImg, 0, 0);

            // ---------- build Three textures ----------
            const map = new THREE.CanvasTexture(diffuse);
            map.anisotropy = renderer.capabilities.getMaxAnisotropy();
            map.needsUpdate = true;

            const normalMap = new THREE.CanvasTexture(normalCanvas);
            normalMap.anisotropy = renderer.capabilities.getMaxAnisotropy();
            normalMap.needsUpdate = true;

            return { map, normalMap };
        }

        // Three.js BoxGeometry material order: [right, left, top, bottom, front, back]
        function makeDiceMaterials() {
            const faces = {
                right: 3, left: 4, top: 2, bottom: 5, front: 1, back: 6
            };

            const fR = makeFaceTextures(faces.right);
            const fL = makeFaceTextures(faces.left);
            const fT = makeFaceTextures(faces.top);
            const fB = makeFaceTextures(faces.bottom);
            const fF = makeFaceTextures(faces.front);
            const fK = makeFaceTextures(faces.back);

            const baseProps = {
                roughness: 0.45,
                metalness: 0.05
            };

            return [
                new THREE.MeshStandardMaterial({ ...baseProps, map: fR.map, normalMap: fR.normalMap, normalScale: new THREE.Vector2(0.9, 0.9) }),
                new THREE.MeshStandardMaterial({ ...baseProps, map: fL.map, normalMap: fL.normalMap, normalScale: new THREE.Vector2(0.9, 0.9) }),
                new THREE.MeshStandardMaterial({ ...baseProps, map: fT.map, normalMap: fT.normalMap, normalScale: new THREE.Vector2(0.9, 0.9) }),
                new THREE.MeshStandardMaterial({ ...baseProps, map: fB.map, normalMap: fB.normalMap, normalScale: new THREE.Vector2(0.9, 0.9) }),
                new THREE.MeshStandardMaterial({ ...baseProps, map: fF.map, normalMap: fF.normalMap, normalScale: new THREE.Vector2(0.9, 0.9) }),
                new THREE.MeshStandardMaterial({ ...baseProps, map: fK.map, normalMap: fK.normalMap, normalScale: new THREE.Vector2(0.9, 0.9) }),
            ];
        }

        // ---------- Dice factory ----------
        const diceSize = 1.0;          // physics meters
        const diceRadius = 0.18;       // rounded corners (visual only)
        const diceSmoothness = 5;      // segments for RoundedBoxGeometry

        function topFaceFromQuaternion(q) {
            const up = new CANNON.Vec3(0, 1, 0);

            // +X => 3, -X => 4, +Y => 2, -Y => 5, +Z => 1, -Z => 6
            const axes = [
                { v: new CANNON.Vec3(1, 0, 0), face: 3 },
                { v: new CANNON.Vec3(-1, 0, 0), face: 4 },
                { v: new CANNON.Vec3(0, 1, 0), face: 2 },
                { v: new CANNON.Vec3(0, -1, 0), face: 5 },
                { v: new CANNON.Vec3(0, 0, 1), face: 1 },
                { v: new CANNON.Vec3(0, 0, -1), face: 6 },
            ];

            let best = { dot: -Infinity, face: 1 };
            for (const a of axes) {
                const worldAxis = q.vmult(a.v);
                const dot = worldAxis.dot(up);
                if (dot > best.dot) best = { dot, face: a.face };
            }
            return best.face;
        }

        function createDie() {
            // Visual: rounded cube (still uses 6 materials ‚Äî RoundedBoxGeometry supports groups)
            const geom = new RoundedBoxGeometry(diceSize, diceSize, diceSize, diceSmoothness, diceRadius);
            const mesh = new THREE.Mesh(geom, makeDiceMaterials());
            mesh.castShadow = true;
            mesh.receiveShadow = false;
            scene.add(mesh);

            // Physics: box (approx for rounded cube ‚Äî still ‚Äúreal tumble‚Äù)
            const body = new CANNON.Body({
                mass: 1,
                material: diceMat,
                shape: new CANNON.Box(new CANNON.Vec3(diceSize / 2, diceSize / 2, diceSize / 2)),
                angularDamping: 0.14,
                linearDamping: 0.04,
                sleepTimeLimit: 0.3,
                sleepSpeedLimit: 0.15,
            });
            world.addBody(body);

            // Track settle state per die
            return {
                mesh,
                body,
                settledFrames: 0,
                locked: false,
                value: null
            };
        }

        let dice = [];

        function syncDiceCount(n) {
            while (dice.length < n) dice.push(createDie());
            while (dice.length > n) {
                const d = dice.pop();
                scene.remove(d.mesh);
                world.removeBody(d.body);
                d.mesh.geometry.dispose();
                // materials have textures; leaving them is OK for this demo (browser will GC),
                // but if you want: dispose textures/materials too.
            }
        }

        // ---------- Roll logic ----------
        const statusEl = document.getElementById("status");
        const lastEl = document.getElementById("last");
        const sumEl = document.getElementById("sum");
        const historyEl = document.getElementById("history");

        const diceCountSel = document.getElementById("diceCount");
        const soundOn = document.getElementById("soundOn");
        const clickToRoll = document.getElementById("clickToRoll");

        function resetDie(d, x, z) {
            d.body.velocity.setZero();
            d.body.angularVelocity.setZero();

            d.body.position.set(x, 3.2 + Math.random() * 0.6, z);

            const q = new CANNON.Quaternion();
            q.setFromEuler(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            d.body.quaternion.copy(q);

            d.body.wakeUp();
            d.settledFrames = 0;
            d.locked = false;
            d.value = null;
        }

        function throwAllDice() {
            const n = Number(diceCountSel.value);
            syncDiceCount(n);

            // Spread start positions
            const spread = 2.2;
            const positions = [];
            for (let i = 0; i < n; i++) {
                const row = Math.floor(i / 3);
                const col = i % 3;
                positions.push({
                    x: (col - 1) * spread + (Math.random() - 0.5) * 0.3,
                    z: (row - 0.5) * spread + (Math.random() - 0.5) * 0.3
                });
            }

            for (let i = 0; i < n; i++) {
                const d = dice[i];
                resetDie(d, positions[i].x, positions[i].z);

                // Impulse + spin
                const impulse = new CANNON.Vec3(
                    (Math.random() - 0.5) * 7,
                    1.8 + Math.random() * 1.8,
                    (Math.random() - 0.5) * 7
                );
                d.body.applyImpulse(impulse, d.body.position);

                d.body.angularVelocity.set(
                    (Math.random() - 0.5) * 22,
                    (Math.random() - 0.5) * 22,
                    (Math.random() - 0.5) * 22
                );
            }

            statusEl.textContent = "Rolling‚Ä¶";
            lastEl.textContent = "‚Ä¶";
            sumEl.textContent = "‚Ä¶";
            playClack(soundOn.checked);
            rolling = true;
            rollLocked = false;
        }

        function computeAndLockIfSettled() {
            if (!rolling) return;

            // ‚ÄúStillness‚Äù thresholds
            const vThresh = 0.10;
            const wThresh = 0.20;

            let allLocked = true;

            for (const d of dice) {
                if (d.locked) continue;

                const v = d.body.velocity.length();
                const w = d.body.angularVelocity.length();
                const still = v < vThresh && w < wThresh;

                if (still) d.settledFrames++;
                else d.settledFrames = 0;

                // Require ~0.5s of stillness at 60fps
                if (d.settledFrames > 30) {
                    d.locked = true;
                    d.value = topFaceFromQuaternion(d.body.quaternion);
                } else {
                    allLocked = false;
                }
            }

            if (allLocked && !rollLocked) {
                rollLocked = true;
                rolling = false;

                const values = dice.map(d => d.value);
                const sum = values.reduce((a, b) => a + b, 0);

                statusEl.textContent = "Settled";
                lastEl.textContent = values.join(", ");
                sumEl.textContent = String(sum);
                addHistory(values, sum);
            }
        }

        function addHistory(values, sum) {
            const item = document.createElement("div");
            item.className = "histItem";

            const left = document.createElement("div");
            left.textContent = `${values.length}d6: [${values.join(", ")}]`;

            const right = document.createElement("div");
            right.className = "pill";
            right.textContent = sum;

            item.appendChild(left);
            item.appendChild(right);
            historyEl.prepend(item);
        }

        // ---------- UI events ----------
        document.getElementById("rollBtn").addEventListener("click", throwAllDice);
        document.getElementById("clearBtn").addEventListener("click", () => {
            historyEl.innerHTML = "";
            lastEl.textContent = "‚Äî";
            sumEl.textContent = "‚Äî";
            statusEl.textContent = "Ready";
        });

        window.addEventListener("keydown", (e) => {
            if (e.code === "Space") {
                e.preventDefault();
                throwAllDice();
            }
        });

        // Click tray to roll (raycast against floor mesh)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        renderer.domElement.addEventListener("pointerdown", (e) => {
            if (!clickToRoll.checked) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObject(floorMesh, false);
            if (hits.length) throwAllDice();
        });

        // ---------- Animation loop ----------
        const clock = new THREE.Clock();
        const fixedTimeStep = 1 / 60;
        let accumulator = 0;

        let rolling = false;
        let rollLocked = false;

        // Start with 2 dice by default
        diceCountSel.value = "2";
        syncDiceCount(2);

        // Position initial dice neatly
        resetDie(dice[0], -1.2, 0);
        resetDie(dice[1], 1.2, 0);
        statusEl.textContent = "Ready";

        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            const dt = Math.min(clock.getDelta(), 0.05);
            accumulator += dt;
            while (accumulator >= fixedTimeStep) {
                world.step(fixedTimeStep);
                accumulator -= fixedTimeStep;
                computeAndLockIfSettled();
            }

            // Sync dice meshes to physics bodies
            for (const d of dice) {
                d.mesh.position.copy(d.body.position);
                d.mesh.quaternion.copy(d.body.quaternion);
            }

            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>