<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sonic Roll – Simulation (UI + Turn Wizard + Boss)</title>
  <style>
    :root { --pad: 14px; --radius: 14px; --border: 1px solid rgba(0,0,0,.12); }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background: #f6f7fb; color: #111; }
    header { padding: 18px 16px; background: white; border-bottom: var(--border); position: sticky; top: 0; z-index: 10; }
    header h1 { margin: 0; font-size: 16px; font-weight: 650; }
    header .sub { margin-top: 6px; font-size: 13px; opacity: .85; display: flex; gap: 10px; flex-wrap: wrap; }

    main { padding: 16px; max-width: 1200px; margin: 0 auto; }
    .grid { display: grid; grid-template-columns: 380px 1fr; gap: 16px; align-items: start; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    .card { background: white; border: var(--border); border-radius: var(--radius); padding: var(--pad); box-shadow: 0 2px 10px rgba(0,0,0,.04); }
    .card h2 { margin: 0 0 10px; font-size: 14px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 0 0 auto; }

    button {
      border: var(--border);
      background: white;
      border-radius: 12px;
      padding: 10px 12px;
      cursor: pointer;
      font-weight: 700;
      font-size: 13px;
    }
    button:hover { background: #f2f4ff; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .primary { background: #2f5cff; color: white; border-color: rgba(0,0,0,.0); }
    .primary:hover { background: #2349d9; }
    .danger { background: #ffecec; border-color: rgba(255,0,0,.15); }
    .danger:hover { background: #ffdcdc; }
    .pill {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 10px; border-radius: 999px;
      border: var(--border); background: #fafafa; font-size: 13px;
    }
    .muted { opacity: .75; font-size: 12px; }
    .small { font-size: 12px; }
    .hr { height: 1px; background: rgba(0,0,0,.08); margin: 12px 0; }

    .diceRow { display: flex; gap: 10px; flex-wrap: wrap; }
    .die {
      width: 44px; height: 44px; border-radius: 12px;
      display: grid; place-items: center;
      border: var(--border);
      background: linear-gradient(#fff8d6, #ffe1a8);
      font-weight: 900; font-size: 18px;
      user-select: none;
      position: relative;
    }
    .die.selected { outline: 3px solid rgba(47,92,255,.55); }
    .die .idx { position: absolute; top: 6px; left: 8px; font-size: 10px; opacity: .5; font-weight: 800; }

    .list { display: grid; gap: 10px; }
    .item { border: var(--border); border-radius: 14px; padding: 12px; background: #fff; }
    .itemHead { display:flex; justify-content: space-between; gap: 12px; align-items: baseline; }
    .itemHead strong { font-size: 13px; }
    .itemHead .tag { font-size: 11px; padding: 4px 8px; border-radius: 999px; border: var(--border); background: #fafafa; }

    .tasks { display: grid; gap: 8px; margin-top: 10px; }
    .task {
      display:flex; gap: 10px; align-items: center; justify-content: space-between;
      border: var(--border); border-radius: 12px; padding: 10px; background: #fbfbff;
    }
    .task.done { opacity: .6; background: #f4f4f4; text-decoration: line-through; }
    .task .req { font-size: 12px; opacity: .85; }
    .task .rew { font-size: 12px; opacity: .85; text-align: right; }

    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      background: #0f1220;
      color: #e9ecff;
      border-radius: 14px;
      padding: 12px;
      max-height: 260px;
      overflow: auto;
      white-space: pre-wrap;
      border: 1px solid rgba(255,255,255,.08);
    }
    .kbd { font-family: ui-monospace, Menlo, Consolas, monospace; background: rgba(0,0,0,.05); border-radius: 8px; padding: 2px 6px; font-size: 12px; }

    /* Wizard panel */
    .wizard {
      position: fixed;
      right: 16px;
      bottom: 16px;
      width: min(420px, calc(100vw - 32px));
      background: white;
      border: var(--border);
      border-radius: 18px;
      box-shadow: 0 8px 30px rgba(0,0,0,.12);
      overflow: hidden;
      z-index: 30;
      display: none;
    }
    .wizard.open { display: block; }
    .wizardHead {
      padding: 12px 12px;
      border-bottom: var(--border);
      display:flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      background: #fbfbff;
    }
    .wizardHead strong { font-size: 13px; }
    .wizardBody { padding: 12px; display: grid; gap: 10px; }
    .step {
      border: var(--border);
      border-radius: 14px;
      padding: 10px;
      background: #fff;
      display: grid;
      gap: 8px;
    }
    .step .title { display:flex; justify-content: space-between; align-items: center; gap: 10px; }
    .step .title span { font-weight: 800; font-size: 13px; }
    .step .state { font-size: 11px; border: var(--border); background: #fafafa; padding: 4px 8px; border-radius: 999px; }
    .step .hint { font-size: 12px; opacity: .8; }
    .step.active { outline: 3px solid rgba(47,92,255,.25); background: #fbfbff; }
    .wizardToggle {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 31;
      border-radius: 999px;
      padding: 12px 14px;
      box-shadow: 0 6px 18px rgba(0,0,0,.12);
    }
  </style>
</head>
<body>
<header>
  <h1>Sonic Roll – Simulation (Turn Wizard + Boss Battle, config-driven)</h1>
  <div class="sub">
    <span class="pill">Mode: <strong id="uiMode"></strong></span>
    <span class="pill">Turn: <strong id="uiTurnPlayer"></strong></span>
    <span class="pill">Life: <strong id="uiLife"></strong></span>
    <span class="pill">Rings: <strong id="uiRings"></strong></span>
    <span class="pill">Boost: <strong id="uiBoost"></strong></span>
    <span class="pill">Emeralds: <strong id="uiEmeralds"></strong></span>
    <span class="pill">Boss HP: <strong id="uiBossHp"></strong></span>
    <span class="pill">Time: <strong id="uiTime"></strong></span>
    <span class="pill">Progress: <strong id="uiProgress"></strong></span>
  </div>
</header>

<main>
  <div class="grid">
    <section class="card">
      <h2>Controls</h2>

      <div class="row" style="gap:8px;">
        <button class="primary" id="btnNewGame">New game</button>
        <button id="btnEndTurn">End turn</button>
        <button class="danger" id="btnStopEarly">Stop early (spend 1 Time)</button>
      </div>

      <div class="hr"></div>

      <div class="row">
        <span class="pill"><span class="muted">Seed</span> <strong id="uiSeed"></strong></span>
        <span class="pill"><span class="muted">Wizard step</span> <strong id="uiWizardStep"></strong></span>
      </div>

      <div class="hr"></div>

      <div class="row"><div class="muted">Roll Action</div></div>
      <div class="row" id="rollActionButtons"></div>

      <div class="row" style="margin-top:10px;">
        <button class="primary" id="btnRoll" disabled>Roll</button>
        <button id="btnReroll" disabled>Reroll remaining</button>
      </div>

      <div class="muted" style="margin-top:10px;">
        Click dice to select them. Then:
        <span class="kbd">Attack Badnik</span> (uses selected die), or click a Zone/Boss objective to auto-pay.
      </div>

      <div class="hr"></div>

      <h2>Dice Pool</h2>
      <div class="diceRow" id="diceRow"></div>

      <div class="row" style="margin-top:12px;">
        <button id="btnAttackBadnik" disabled>Attack Badnik (use selected die)</button>
      </div>

      <div class="hr"></div>

      <h2>Log</h2>
      <div class="log" id="log"></div>
    </section>

    <section class="card">
      <h2>Board State</h2>

      <div class="row">
        <span class="pill"><span class="muted">Zones</span> <strong id="uiZonesCount"></strong></span>
        <span class="pill"><span class="muted">Badniks</span> <strong id="uiBadniksCount"></strong></span>
        <span class="pill"><span class="muted">Boss objective</span> <strong id="uiBossObjective"></strong></span>
      </div>

      <div class="hr"></div>

      <div id="boardZonesBlock">
        <h2>Zones</h2>
        <div class="list" id="zonesList"></div>
        <div class="hr"></div>
      </div>

      <div id="boardBossBlock" style="display:none;">
        <h2>Boss Battle</h2>
        <div class="item" id="bossCard"></div>
        <div class="hr"></div>
      </div>

      <h2>Badniks</h2>
      <div class="list" id="badniksList"></div>
    </section>
  </div>
</main>

<button class="wizardToggle primary" id="btnWizardToggle">Turn Wizard</button>

<!-- Wizard Panel -->
<div class="wizard" id="wizard">
  <div class="wizardHead">
    <strong>Turn Wizard</strong>
    <div class="row" style="gap:8px;">
      <button id="btnWizardClose">Close</button>
    </div>
  </div>
  <div class="wizardBody" id="wizardBody"></div>
</div>

<script>
/**
 * CONFIG: Replace CONTENT with your real Sonic Roll data.
 * - This file implements a "wizard state machine" + boss battle mode.
 */

//////////////////////////////
// RNG helpers
//////////////////////////////
function mulberry32(seed) {
  let t = seed >>> 0;
  return function () {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}
function shuffle(rng, arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function rollDie(rng) { return 1 + Math.floor(rng() * 6); }

function existsSubsetSum(dice, k, target) {
  // Brute force backtracking; dice pools are small so this is fine
  function dfs(start, left, sum) {
    if (left === 0) return sum === target;
    for (let i = start; i < dice.length; i++) {
      if (dfs(i + 1, left - 1, sum + dice[i])) return true;
    }
    return false;
  }
  return dfs(0, k, 0);
}

function pickSubsetSumIndices(dice, k, target) {
  // Returns an array of indices of a subset that matches, or null
  const idxs = [];
  function dfs(start, left, sum) {
    if (left === 0) return sum === target;
    for (let i = start; i < dice.length; i++) {
      idxs.push(i);
      if (dfs(i + 1, left - 1, sum + dice[i])) return true;
      idxs.pop();
    }
    return false;
  }
  const ok = dfs(0, k, 0);
  return ok ? idxs.slice() : null;
}

//////////////////////////////
// Content model (EDIT ME)
//////////////////////////////
const CONTENT = {
  // Progress threshold that triggers boss mode
  bossUnlockProgress: 3,

  rollActions: [
    { id: "steady", label: "Steady (3)", rolls: [3] },
    { id: "speedy", label: "Speedy (2+2)", rolls: [2,2] },
    { id: "risky",  label: "Risky (1+3+1)", rolls: [1,3,1] }
  ],

  zones: [
    {
      id: "GHZ-1",
      name: "Green Hill (Example)",
      tasks: [
        { id: "loop",   requirement: { exact: 4 }, reward: { rings: 2 } },
        { id: "spikes", requirement: { exact: 2 }, reward: { rings: 1 } },
        { id: "goal",   requirement: { sumAtLeast: 8, diceCount: 2 }, reward: { advance: 1 } }
      ],
      completeReward: { bonusFlip: 1 }
    },
    {
      id: "MZ-1",
      name: "Marble (Example)",
      tasks: [
        { id: "lava", requirement: { exact: 5 }, reward: { rings: 2 } },
        { id: "switch", requirement: { sumAtLeast: 7, diceCount: 2 }, reward: { advance: 1 } }
      ],
      completeReward: { bonusFlip: 1 }
    },
    {
      id: "SYZ-1",
      name: "Spring Yard (Example)",
      tasks: [
        { id: "spring", requirement: { exact: 6 }, reward: { rings: 3 } },
        { id: "platform", requirement: { exact: 3 }, reward: { rings: 1 } }
      ],
      completeReward: { bonusFlip: 1 }
    }
  ],

  badniks: [
    { id: "crabmeat", name: "Crabmeat (Example)", hp: 3, rerollTrigger: { anyFaceIn: [1] }, attack: { damage: 1 } },
    { id: "buzzbomber", name: "Buzz Bomber (Example)", hp: 2, rerollTrigger: { anyFaceIn: [6] }, attack: { damage: 1 } },
    { id: "motobug", name: "Motobug (Example)", hp: 4, rerollTrigger: { anyFaceIn: [2,3] }, attack: { damage: 1 } }
  ],

  bonusTiles: [
    { id: "bonus-rings", type: "rings", amount: 3 },
    { id: "bonus-emerald", type: "emerald" },
    { id: "bonus-boost", type: "boost" }
  ],
  chaosEmeralds: [ { id: "red" }, { id: "blue" }, { id: "green" }, { id: "yellow" } ],

  // Boss battle (placeholder but functional):
  // - Each turn you roll like normal, then attempt to satisfy the current objective.
  // - If you complete the objective, you damage the boss and advance to the next objective.
  // - Boss also has reroll-trigger attacks.
  boss: {
    id: "eggman",
    name: "Dr. Eggman (Example)",
    hp: 10,
    rerollTrigger: { anyFaceIn: [1, 6] }, // example: if you reroll into 1 or 6, Eggman attacks
    attack: { damage: 1 },

    // "Objectives" are requirements you must pay with dice to deal damage.
    // You can model patterns/phases here.
    objectives: [
      { id: "phase-1", label: "Disable shield", requirement: { sumAtLeast: 9, diceCount: 2 }, damageBoss: 2 },
      { id: "phase-2", label: "Hit weak spot", requirement: { exact: 6 }, damageBoss: 2 },
      { id: "phase-3", label: "Dodge + strike", requirement: { exact: 5 }, damageBoss: 1 },
      { id: "phase-4", label: "Final blow", requirement: { sumAtLeast: 10, diceCount: 2 }, damageBoss: 3 }
    ]
  }
};

//////////////////////////////
// Engine + Wizard FSM
//////////////////////////////
const WIZARD_STEPS = [
  { key: "choose-roll", title: "Choose a Roll Action", hint: "Pick a roll action below." },
  { key: "roll", title: "Roll dice", hint: "Click Roll to build your dice pool." },
  { key: "spend", title: "Spend dice", hint: "Click a Zone/Boss objective or attack a Badnik with a selected die." },
  { key: "reroll", title: "Reroll remaining dice", hint: "Reroll remaining dice (push your luck). Triggers attacks." },
  { key: "end", title: "End turn", hint: "End turn, or stop early to spend 1 Time." }
];

class Player {
  constructor(name) {
    this.name = name;
    this.life = 3;
    this.boost = 1;
    this.rings = 0;
    this.emeralds = [];
  }
}

class GameState {
  constructor({ players, seed = 1 }) {
    this.seed = seed;
    this.rng = mulberry32(seed);

    this.players = players.map(n => new Player(n));
    this.activePlayerIdx = 0;

    this.timeTokens = 7;
    this.actProgress = 0;

    this.zoneDeck = shuffle(this.rng, CONTENT.zones).map(z => structuredClone(z));
    this.badnikDeck = shuffle(this.rng, CONTENT.badniks).map(b => structuredClone(b));
    this.emeraldDeck = shuffle(this.rng, CONTENT.chaosEmeralds).map(e => structuredClone(e));
    this.bonusTiles = shuffle(this.rng, CONTENT.bonusTiles).map(t => structuredClone(t));

    this.activeZones = this.zoneDeck.splice(0, 3);
    this.activeBadniks = this.badnikDeck.splice(0, 2);

    this.mode = "zones"; // zones | boss | game-over

    this.boss = { ...structuredClone(CONTENT.boss), hp: CONTENT.boss.hp };
    this.bossObjectiveIndex = 0;

    this.selectedRollActionId = null;
    this.dicePool = [];

    // Wizard
    this.wizardStepIndex = 0; // drives what UI enables
  }

  get activePlayer() { return this.players[this.activePlayerIdx]; }

  get currentWizardStep() { return WIZARD_STEPS[this.wizardStepIndex]?.key ?? "choose-roll"; }

  isGameOver() {
    const allDead = this.players.every(p => p.life <= 0);
    const outOfTime = this.timeTokens <= 0;
    const bossDefeated = this.boss.hp <= 0;
    return allDead || outOfTime || bossDefeated;
  }
}

//////////////////////////////
// Rules helpers
//////////////////////////////
function logLine(msg) {
  const el = document.getElementById("log");
  el.textContent = (el.textContent ? el.textContent + "\n" : "") + msg;
  el.scrollTop = el.scrollHeight;
}

function canPay(requirement, dice) {
  if (!requirement) return false;

  // Single die must match exactly
  if (requirement.exact != null) {
    return dice.some(d => d === requirement.exact);
  }

  // Exact sum using exactly K dice (top-K no longer; must exist some subset of size K)
  if (requirement.sumExact != null && requirement.diceCount != null) {
    return existsSubsetSum(dice, requirement.diceCount, requirement.sumExact);
  }

  // At-least removed; min/max removed
  return false;
}

function pay(requirement, dicePool) {
  if (requirement.exact != null) {
    const idx = dicePool.findIndex(d => d === requirement.exact);
    if (idx >= 0) dicePool.splice(idx, 1);
    return idx >= 0;
  }

  // Remove a subset of exactly K dice that sum to target (sumExact)
  if (requirement.sumExact != null && requirement.diceCount != null) {
    const pickedIdx = pickSubsetSumIndices(dicePool, requirement.diceCount, requirement.sumExact);
    if (!pickedIdx) return false;

    // remove from end to avoid reindex issues
    pickedIdx.sort((a,b)=>b-a).forEach(i => dicePool.splice(i, 1));
    return true;
  }

  return false;
}

function applyReward(state, reward) {
  if (!reward) return;
  const p = state.activePlayer;
  if (reward.rings) p.rings += reward.rings;
  if (reward.advance) state.actProgress += reward.advance;
  if (reward.damageBoss) state.boss.hp = Math.max(0, state.boss.hp - reward.damageBoss);
}

function buildDicePool(state, rollActionId) {
  const action = CONTENT.rollActions.find(a => a.id === rollActionId);
  if (!action) throw new Error("Unknown roll action");
  state.dicePool = [];
  for (const n of action.rolls) for (let i=0;i<n;i++) state.dicePool.push(rollDie(state.rng));
  return action;
}

function rerollRemainingDice(state) {
  state.dicePool = state.dicePool.map(()=>rollDie(state.rng));
}

function resolveRerollAttacks(state) {
  const faces = state.dicePool;

  let total = 0;

  // Badniks attacks
  if (state.mode === "zones") {
    for (const b of state.activeBadniks) {
      const any = b.rerollTrigger?.anyFaceIn?.some(f => faces.includes(f));
      if (any) total += (b.attack?.damage ?? 0);
    }
  }

  // Boss attacks
  if (state.mode === "boss") {
    const anyBoss = state.boss.rerollTrigger?.anyFaceIn?.some(f => faces.includes(f));
    if (anyBoss) total += (state.boss.attack?.damage ?? 0);
  }

  if (total > 0) {
    state.activePlayer.life = Math.max(0, state.activePlayer.life - total);
  }
  return total;
}

function maybeEnterBossMode(state) {
  if (state.mode !== "zones") return;
  if (state.actProgress >= CONTENT.bossUnlockProgress) {
    state.mode = "boss";
    logLine(`=== BOSS BATTLE START: ${state.boss.name} ===`);
    // Reset wizard to start of a boss turn
    state.wizardStepIndex = 0;
    state.selectedRollActionId = null;
    state.dicePool = [];
  }
}

function completeZoneIfDone(state, zone) {
  if (!zone.tasks?.length) return;
  if (!zone.tasks.every(t => t.cleared)) return;

  const flips = zone.completeReward?.bonusFlip ?? 0;
  if (flips > 0) {
    for (let i=0;i<flips && state.bonusTiles.length;i++) {
      const tile = state.bonusTiles.shift();
      if (tile.type === "rings") { state.activePlayer.rings += tile.amount; logLine(`Bonus: +${tile.amount} rings`); }
      else if (tile.type === "boost") { state.activePlayer.boost += 1; logLine(`Bonus: +1 boost`); }
      else if (tile.type === "emerald") {
        const e = state.emeraldDeck.shift();
        if (e) { state.activePlayer.emeralds.push(e); logLine(`Bonus: gained emerald (${e.id})`); }
      }
    }
  }

  const idx = state.activeZones.findIndex(z => z.id === zone.id);
  const next = state.zoneDeck.shift();
  state.activeZones[idx] = next ? next : { id: "EMPTY", name: "No more Zones", tasks: [] };
  logLine(`Zone cleared: ${zone.name}`);
}

function currentBossObjective(state) {
  return state.boss.objectives?.[state.bossObjectiveIndex] ?? null;
}

function advanceBossObjective(state) {
  if (state.boss.objectives?.length) {
    state.bossObjectiveIndex = Math.min(state.bossObjectiveIndex + 1, state.boss.objectives.length - 1);
  }
}

//////////////////////////////
// UI state
//////////////////////////////
let state = null;
let selectedDiceIndex = null;
let selectedBadnikId = null;

function uiSetText(id, txt) { document.getElementById(id).textContent = txt; }
function reqToText(req) {
  if (!req) return "—";
  if (req.exact != null) return `Exact: ${req.exact}`;
  if (req.sumExact != null) return `Use ${req.diceCount} dice sum = ${req.sumExact}`;
  return "—";
}
function wizardStepLabel(stepKey) {
  const s = WIZARD_STEPS.find(x => x.key === stepKey);
  return s ? s.title : stepKey;
}

function openWizard(open) {
  document.getElementById("wizard").classList.toggle("open", !!open);
}

function renderWizard() {
  const body = document.getElementById("wizardBody");
  body.innerHTML = "";

  const current = state.currentWizardStep;

  for (let i=0;i<WIZARD_STEPS.length;i++) {
    const s = WIZARD_STEPS[i];
    const done = i < state.wizardStepIndex;
    const active = i === state.wizardStepIndex;

    const el = document.createElement("div");
    el.className = "step" + (active ? " active" : "");
    el.innerHTML = `
      <div class="title">
        <span>${i+1}. ${s.title}</span>
        <span class="state">${done ? "Done" : (active ? "Now" : "Next")}</span>
      </div>
      <div class="hint">${s.hint}</div>
    `;

    // Tiny "jump" affordance: allow going backwards (never forward).
    if (!done && !active) {
      // no jump
    } else if (done) {
      const backBtn = document.createElement("button");
      backBtn.textContent = "Go here";
      backBtn.onclick = () => { state.wizardStepIndex = i; render(); };
      el.appendChild(backBtn);
    }

    body.appendChild(el);
  }
}

function render() {
  if (!state) return;

  // Auto game over
  if (state.isGameOver()) state.mode = "game-over";

  // header
  uiSetText("uiMode", state.mode.toUpperCase());
  uiSetText("uiTurnPlayer", state.activePlayer.name);
  uiSetText("uiLife", state.activePlayer.life);
  uiSetText("uiRings", state.activePlayer.rings);
  uiSetText("uiBoost", state.activePlayer.boost);
  uiSetText("uiEmeralds", state.activePlayer.emeralds.map(e=>e.id).join(", ") || "none");
  uiSetText("uiBossHp", state.boss.hp);
  uiSetText("uiTime", state.timeTokens);
  uiSetText("uiProgress", state.actProgress);

  uiSetText("uiSeed", String(state.seed));
  uiSetText("uiWizardStep", wizardStepLabel(state.currentWizardStep));
  uiSetText("uiZonesCount", String(state.activeZones.length));
  uiSetText("uiBadniksCount", String(state.activeBadniks.length));

  // Boss objective label
  const obj = currentBossObjective(state);
  uiSetText("uiBossObjective", state.mode === "boss" && obj ? obj.label : "—");

  // Toggle board blocks
  document.getElementById("boardZonesBlock").style.display = (state.mode === "zones") ? "" : "none";
  document.getElementById("boardBossBlock").style.display = (state.mode === "boss") ? "" : "none";

  // Roll Action buttons
  const rollWrap = document.getElementById("rollActionButtons");
  rollWrap.innerHTML = "";
  for (const a of CONTENT.rollActions) {
    const btn = document.createElement("button");
    btn.textContent = a.label;
    const canChoose = (state.mode !== "game-over") && (state.currentWizardStep === "choose-roll");
    btn.disabled = !canChoose;
    if (state.selectedRollActionId === a.id) btn.classList.add("primary");
    btn.onclick = () => {
      state.selectedRollActionId = a.id;
      logLine(`Selected roll action: ${a.label}`);
      // Advance wizard to "roll" once a roll action is selected
      if (state.currentWizardStep === "choose-roll") state.wizardStepIndex = 1;
      render();
    };
    rollWrap.appendChild(btn);
  }

  // Dice
  const diceRow = document.getElementById("diceRow");
  diceRow.innerHTML = "";
  state.dicePool.forEach((d, i) => {
    const el = document.createElement("div");
    el.className = "die" + (selectedDiceIndex === i ? " selected" : "");
    el.innerHTML = `<span class="idx">${i}</span>${d}`;
    el.onclick = () => {
      selectedDiceIndex = (selectedDiceIndex === i) ? null : i;
      render();
    };
    diceRow.appendChild(el);
  });

  // Zones rendering (only in zones mode)
  const zonesList = document.getElementById("zonesList");
  zonesList.innerHTML = "";
  if (state.mode === "zones") {
    for (const z of state.activeZones) {
      const wrap = document.createElement("div");
      wrap.className = "item";
      wrap.innerHTML = `
        <div class="itemHead">
          <strong>${z.name}</strong>
          <span class="tag">${z.id}</span>
        </div>
        <div class="tasks"></div>
      `;
      const tasksEl = wrap.querySelector(".tasks");
      (z.tasks || []).forEach(t => {
        const doable =
          state.currentWizardStep === "spend" &&
          !t.cleared &&
          canPay(t.requirement, state.dicePool);

        const task = document.createElement("div");
        task.className = "task" + (t.cleared ? " done" : "");
        task.innerHTML = `
          <div>
            <div><strong>${t.id}</strong></div>
            <div class="req">${reqToText(t.requirement)}</div>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <div class="rew">${t.reward ? (Object.entries(t.reward).map(([k,v])=>`${k}:${v}`).join(", ")) : "—"}</div>
            <button ${doable ? "" : "disabled"}>Spend</button>
          </div>
        `;
        task.querySelector("button").onclick = () => {
          if (!doable) return;
          const ok = pay(t.requirement, state.dicePool);
          if (!ok) return;
          t.cleared = true;
          applyReward(state, t.reward);
          logLine(`Spent dice on zone task: ${z.id}:${t.id}`);
          completeZoneIfDone(state, z);
          selectedDiceIndex = null;

          // After spending, wizard expects reroll next
          state.wizardStepIndex = 3; // reroll
          render();
        };

        tasksEl.appendChild(task);
      });

      if (!z.tasks?.length) {
        const empty = document.createElement("div");
        empty.className = "muted small";
        empty.textContent = "No tasks.";
        tasksEl.appendChild(empty);
      }

      zonesList.appendChild(wrap);
    }
  }

  // Boss rendering (only in boss mode)
  const bossCard = document.getElementById("bossCard");
  if (state.mode === "boss") {
    const o = currentBossObjective(state);
    const doable = (state.currentWizardStep === "spend") && o && canPay(o.requirement, state.dicePool);

    bossCard.innerHTML = `
      <div class="itemHead">
        <strong>${state.boss.name}</strong>
        <span class="tag">HP ${state.boss.hp}</span>
      </div>
      <div class="muted small" style="margin-top:8px;">
        Reroll trigger: any face in [${(state.boss.rerollTrigger?.anyFaceIn || []).join(", ")}]
        → damage ${state.boss.attack?.damage ?? 0}
      </div>
      <div class="hr"></div>
      <div class="task" style="margin:0;">
        <div>
          <div><strong>Objective: ${o ? o.label : "—"}</strong></div>
          <div class="req">${o ? reqToText(o.requirement) : "—"}</div>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <div class="rew">${o ? `Boss dmg: ${o.damageBoss}` : ""}</div>
          <button ${doable ? "" : "disabled"}>Complete</button>
        </div>
      </div>
    `;

    bossCard.querySelector("button")?.addEventListener("click", () => {
      if (!doable) return;
      if (!pay(o.requirement, state.dicePool)) return;

      state.boss.hp = Math.max(0, state.boss.hp - (o.damageBoss ?? 1));
      logLine(`Completed boss objective "${o.label}" → boss takes ${o.damageBoss ?? 1}. Boss HP=${state.boss.hp}`);

      // move to next objective if boss still alive
      if (state.boss.hp > 0) {
        advanceBossObjective(state);
        logLine(`Boss shifts pattern → "${currentBossObjective(state)?.label ?? "—"}"`);
      } else {
        logLine(`=== BOSS DEFEATED ===`);
      }

      selectedDiceIndex = null;
      state.wizardStepIndex = 3; // reroll step after spend
      render();
    });
  }

  // Badniks list (only meaningful in zones mode, but still shown)
  const badniksList = document.getElementById("badniksList");
  badniksList.innerHTML = "";
  for (const b of state.activeBadniks) {
    const wrap = document.createElement("div");
    wrap.className = "item";
    const isSelected = selectedBadnikId === b.id;
    wrap.innerHTML = `
      <div class="itemHead">
        <strong>${b.name}</strong>
        <span class="tag">HP ${b.hp}</span>
      </div>
      <div class="muted small" style="margin-top:8px;">
        Reroll trigger: any face in [${(b.rerollTrigger?.anyFaceIn || []).join(", ")}] → damage ${b.attack?.damage ?? 0}
      </div>
      <div class="row" style="margin-top:10px;">
        <button class="${isSelected ? "primary" : ""}" ${state.mode !== "zones" ? "disabled" : ""}>
          ${isSelected ? "Targeting" : "Target"}
        </button>
      </div>
    `;
    wrap.querySelector("button").onclick = () => {
      if (state.mode !== "zones") return;
      selectedBadnikId = (selectedBadnikId === b.id) ? null : b.id;
      logLine(selectedBadnikId ? `Targeting badnik: ${b.name}` : "Cleared badnik target.");
      render();
    };
    badniksList.appendChild(wrap);
  }

  // Button enables based on wizard step
  const canRoll = (state.currentWizardStep === "roll") && !!state.selectedRollActionId && state.mode !== "game-over";
  document.getElementById("btnRoll").disabled = !canRoll;

  const canSpend = (state.currentWizardStep === "spend") && state.dicePool.length > 0 && state.mode !== "game-over";
  const canReroll = (state.currentWizardStep === "reroll") && state.dicePool.length > 0 && state.mode !== "game-over";
  document.getElementById("btnReroll").disabled = !canReroll;

  const canAttackBadnik =
    state.mode === "zones" &&
    canSpend &&
    selectedDiceIndex != null &&
    state.activeBadniks.length > 0;
  document.getElementById("btnAttackBadnik").disabled = !canAttackBadnik;

  document.getElementById("btnStopEarly").disabled = !(state.currentWizardStep === "end" && state.mode !== "game-over");
  document.getElementById("btnEndTurn").disabled = !(state.currentWizardStep === "end" && state.mode !== "game-over");

  renderWizard();
}

//////////////////////////////
// Wizard-driven actions
//////////////////////////////
function doRoll() {
  if (state.currentWizardStep !== "roll") return;
  const action = buildDicePool(state, state.selectedRollActionId);
  logLine(`${state.activePlayer.name} rolls (${action.label}) → [${state.dicePool.join(", ")}]`);
  state.wizardStepIndex = 2; // spend
  render();
}

function doSpendAttackBadnik() {
  if (state.mode !== "zones") return;
  if (state.currentWizardStep !== "spend") return;
  if (selectedDiceIndex == null) return;

  const idx = selectedDiceIndex;
  const dmg = state.dicePool[idx];
  const targetId = selectedBadnikId ?? state.activeBadniks[0]?.id;
  const b = state.activeBadniks.find(x => x.id === targetId);
  if (!b) return;

  state.dicePool.splice(idx, 1);
  selectedDiceIndex = null;

  b.hp -= dmg;
  logLine(`Attacked ${b.name} for ${dmg}. HP now ${b.hp}`);

  if (b.hp <= 0) {
    logLine(`Defeated badnik: ${b.name}`);
    state.activeBadniks = state.activeBadniks.filter(x => x.id !== b.id);
    const next = state.badnikDeck.shift();
    if (next) { state.activeBadniks.push(next); logLine(`New badnik appears: ${next.name}`); }
    selectedBadnikId = null;
  }

  // After a spend, wizard expects reroll
  state.wizardStepIndex = 3; // reroll
  render();
}

function doReroll() {
  if (state.currentWizardStep !== "reroll") return;
  if (state.dicePool.length === 0) return;

  rerollRemainingDice(state);
  const dmg = resolveRerollAttacks(state);
  logLine(`Reroll → [${state.dicePool.join(", ")}]`);
  if (dmg > 0) logLine(`Attacks triggered for ${dmg}. ${state.activePlayer.name} life=${state.activePlayer.life}`);

  // After reroll, wizard loops back to spend (if dice remain), else end.
  state.wizardStepIndex = (state.dicePool.length > 0) ? 2 : 4;
  render();
}

function doEndTurn() {
  if (state.currentWizardStep !== "end") return;
  if (state.mode === "game-over") return;

  // Check boss unlock between turns too
  maybeEnterBossMode(state);

  state.activePlayerIdx = (state.activePlayerIdx + 1) % state.players.length;
  state.selectedRollActionId = null;
  state.dicePool = [];
  selectedDiceIndex = null;
  selectedBadnikId = null;

  state.wizardStepIndex = 0;
  logLine(`--- Turn passes to ${state.activePlayer.name} ---`);

  render();
}

function doStopEarly() {
  if (state.currentWizardStep !== "end") return;
  state.timeTokens = Math.max(0, state.timeTokens - 1);
  logLine(`${state.activePlayer.name} stops early. Time -1 → ${state.timeTokens}`);
  doEndTurn();
}

//////////////////////////////
// Entry points
//////////////////////////////
function newGame() {
  const seed = Math.floor(Math.random() * 1e9);
  state = new GameState({ players: ["Sonic", "Tails"], seed });
  selectedDiceIndex = null;
  selectedBadnikId = null;

  document.getElementById("log").textContent = "";
  logLine(`New game (seed=${seed})`);
  logLine(`Players: ${state.players.map(p=>p.name).join(", ")}`);
  logLine(`Zones: ${state.activeZones.map(z=>z.name).join(" | ")}`);
  logLine(`Badniks: ${state.activeBadniks.map(b=>b.name).join(" | ")}`);
  logLine(`Boss unlock at progress ≥ ${CONTENT.bossUnlockProgress}`);

  render();
}

//////////////////////////////
// Wire buttons
//////////////////////////////
document.getElementById("btnNewGame").onclick = newGame;
document.getElementById("btnRoll").onclick = doRoll;
document.getElementById("btnReroll").onclick = doReroll;
document.getElementById("btnAttackBadnik").onclick = doSpendAttackBadnik;
document.getElementById("btnEndTurn").onclick = doEndTurn;
document.getElementById("btnStopEarly").onclick = doStopEarly;

// Wizard toggle
document.getElementById("btnWizardToggle").onclick = () => openWizard(true);
document.getElementById("btnWizardClose").onclick = () => openWizard(false);

// Also allow clicking outside? (keep simple)

// Initial
newGame();
</script>
</body>
</html>
