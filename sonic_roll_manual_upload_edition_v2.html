<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sonic Roll – Rules Engine (Dashboards Implemented)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body {
      margin: 16px;
      color:#e8ecff;
      background: linear-gradient(45deg, #8fbfe8 25%, transparent 25%, transparent 75%, #8fbfe8 75%, #8fbfe8),
                  linear-gradient(45deg, #8fbfe8 25%, transparent 25%, transparent 75%, #8fbfe8 75%, #8fbfe8);
      background-size: 120px 120px;
      background-position: 0 0, 60px 60px;
      background-color: #9fc7ea;
    }
    h1,h2 { margin: 8px 0; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    .card { background:#121a33; border:1px solid #23305a; border-radius:14px; padding:12px; box-shadow: 0 8px 25px rgba(0,0,0,.25); }
    .card h2 { font-size: 14px; letter-spacing:.04em; text-transform:uppercase; color:#b8c6ff; }
    .controls-card { background:#121a33; border-color:#23305a; }
    .controls-card[data-character="Sonic"] { background:#0f2347; border-color:#2a4f96; }
    .controls-card[data-character="Tails"] { background:#3a220f; border-color:#8b5b2a; }
    .controls-card[data-character="Knuckles"] { background:#3a0f12; border-color:#8a2a2a; }
    .controls-card[data-character="Amy"] { background:#351126; border-color:#7a2d53; }
    .character-heading { display:flex; align-items:center; gap:8px; flex-wrap:wrap; font-size:18px; font-weight:700; margin:0 0 6px; color:#e8ecff; }
    .badge-tight { padding:2px 6px; font-size:11px; }
    button, select, input { background:#1a2550; border:1px solid #2d3b73; color:#e8ecff; padding:8px 10px; border-radius:10px; cursor:pointer; }
    button:hover { filter:brightness(1.1); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { display:inline-flex; gap:8px; padding:6px 10px; border:1px solid #2d3b73; border-radius:999px; background:#0f1733; margin:4px 4px 0 0; align-items:center; }
    .muted { color:#b0b8e8; }
    .log { max-height: 300px; overflow:auto; font-size: 13px; line-height:1.35; }
    .grid { display:grid; grid-template-columns: minmax(240px, 1fr); gap:10px; }
    .tiny { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .badge { font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #2d3b73; background:#0f1733; }
    .roll-action-btn { padding:8px 10px; border-radius:10px; border:1px solid #2d3b73; background:#0f1733; color:#e8ecff; cursor:pointer; display:flex; flex-direction:column; align-items:center; gap:4px; min-width:90px; }
    .roll-action-icon { font-size:16px; line-height:1; }
    .roll-action-btn.active { border-color:#7cb6ff; box-shadow: 0 0 0 2px rgba(124,182,255,.35); background:#15234a; }
    .die {
      width: 44px; height: 44px; border-radius:10px; display:inline-flex; align-items:center; justify-content:center;
      margin:4px; font-weight:700; border:1px solid #2d3b73; background:#0f1733;
      user-select:none;
    }
    .die.blue { outline:2px solid rgba(86,161,255,.65); }
    .die.yellow { outline:2px solid rgba(255,219,86,.65); }
    .die.red { outline:2px solid rgba(255,97,97,.65); }
    .die.black { outline:2px solid rgba(170,170,170,.35); }
    .die.selected { box-shadow: 0 0 0 2px #b8c6ff; }
    textarea { width:100%; min-height:120px; border-radius:10px; background:#0f1733; border:1px solid #2d3b73; color:#e8ecff; padding:10px; }
    .hr { height:1px; background:#23305a; margin:10px 0; }
    .ok { color:#b8ffcf; }
    .warn { color:#ffe7a6; }
    .clickable { cursor:pointer; }
    .clickable:hover { filter:brightness(1.08); }
    .target-list { display:flex; flex-direction:column; gap:6px; margin-top:6px; }
    .target-item { padding:6px 8px; border:1px solid #2d3b73; border-radius:10px; background:#0f1733; cursor:pointer; }
    .target-item.selected { outline:2px solid rgba(120,200,255,.6); background:#15234a; }
    .target-actions { margin-top:8px; }
    .track-list { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
    .track-item {
      border:1px solid #2d3b73;
      border-radius:10px;
      background:#0f1733;
      padding:6px 8px;
      font-size:13px;
      display:flex;
      flex-direction:column;
      justify-content:flex-start;
    }
    .track-item.cleared { opacity:.55; text-decoration: line-through; }
    .track-label { font-weight:600; font-size:14px; }
    .track-reward { color:#b0b8e8; font-size:12px; }
    .req-chip { display:inline-flex; align-items:center; justify-content:center; width:46px; height:46px; padding:0; border-radius:8px; border:1px solid #2d3b73; background:#d7dbe6; color:#111; font-weight:700; letter-spacing:.02em; }
    .req-chip img { width:28px; height:28px; display:block; }
    .req-chip.req-blue { background:#5aa3ff; color:#0b1020; }
    .req-chip.req-yellow { background:#ffd756; color:#3a2a00; }
    .req-chip.req-red { background:#ff6a6a; color:#2a0b0b; }
    .req-chip.req-any { background:#d7dbe6; color:#111; }
    .req-number { font-size:1.15em; }
    .player-setup { display:flex; flex-direction:column; gap:6px; }
    .player-setup-row { display:flex; align-items:center; gap:8px; }
    .player-setup-row select { min-width:150px; }
    .portrait { width:28px; height:28px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; font-weight:700; font-size:12px; border:1px solid #2d3b73; background:#1a2550; color:#e8ecff; }
    .portrait.sonic { background:#1a4fa3; }
    .portrait.tails { background:#b56a1f; }
    .portrait.knuckles { background:#a33131; }
    .portrait.amy { background:#8e2f60; }
    .header-bar { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; margin:6px 0 12px; }
    .header-bar h1 { margin:0; }
    .top-bar { display:flex; justify-content:flex-end; }
    .menu-wrapper { position:relative; }
    .menu-button { width:36px; height:32px; display:flex; flex-direction:column; justify-content:center; gap:4px; padding:6px; }
    .menu-button span { display:block; width:18px; height:2px; background:#e8ecff; border-radius:2px; }
    .menu-dropdown { position:absolute; right:0; top:40px; background:#121a33; border:1px solid #23305a; border-radius:10px; padding:6px; min-width:140px; display:none; z-index:900; }
    .menu-dropdown.open { display:block; }
    .menu-dropdown button { width:100%; text-align:left; }
    .modal-overlay { position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal-overlay.open { display:flex; }
    .modal { max-width:540px; width:calc(100% - 32px); }
    .modal-actions { justify-content:flex-end; }
  </style>
</head>
<body>
  <div class="header-bar">
    <h1>Sonic Roll – Rules Engine + Web App (Dashboards Implemented)</h1>
    <div id="top-bar" class="top-bar">
      <div id="menuWrapper" class="menu-wrapper">
        <button id="menuBtn" class="menu-button" aria-label="Menu">
          <span></span><span></span><span></span>
        </button>
        <div id="menuDropdown" class="menu-dropdown">
          <button id="menuNewGame">New Game</button>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <div id="controlsCard" class="card controls-card" style="flex:1; min-width:340px;">
      <div id="characterHeading" class="character-heading"></div>
      <div class="hr"></div>

      <div class="row">
        <div id="rollActionButtons" class="row"></div>
        <button id="btnBuildPool">Roll / Build Dice Pool</button>
      </div>

      <div class="row" style="margin-top:8px;">
        <button id="btnUseBoostToken">Use Boost Token</button>
        <button id="btnSpendDie">Spend Selected Die</button>
        <button id="btnRerollStep">Reroll Step</button>
        <button id="btnEndTurn">End Turn (Discard + Time)</button>
      </div>

      <div class="hr"></div>

      <div class="tiny">
        <div><span class="badge">Phase</span> <span id="phase"></span></div>
        <div><span class="badge">Active</span> <span id="activePlayer"></span></div>
        <div><span class="badge">Invulnerable</span> <span id="invuln"></span></div>
      </div>

      <div class="hr"></div>

      <h2>Dice Pool</h2>
      <div id="dicePool"></div>
      <div class="tiny muted">Click a die to select it for spending.</div>

      <div class="hr"></div>

      <div id="discardSection">
        <h2>Discard a Die</h2>
        <div id="discardPanel" class="tiny muted"></div>
        <div class="hr"></div>
      </div>

      <div id="starPostSection">
        <h2>Star Post</h2>
        <div id="starPostPanel" class="tiny muted"></div>
        <div class="hr"></div>
      </div>

      <h2>Spend Target</h2>
      <div id="spendTargetPanel" class="tiny muted">Select a die and click "Spend Selected Die" to choose a target. Tip: click a Zone/Badnik card to preselect.</div>

      <div class="hr"></div>

      <h2>Per-Turn Counters</h2>
      <div id="counters" class="tiny"></div>

      <div class="hr"></div>

      <h2>Power Ups</h2>
      <div id="powerUpStatus" class="tiny"></div>
      <div id="powerUpPanel" class="tiny muted">No pending Power Ups.</div>
    </div>

    <div class="card" style="flex:1; min-width:340px;">
      <h2>Zone (Simplified Track)</h2>
      <p class="tiny muted">
        For now: each route has a “next challenge” requiring an exact number, sometimes also an exact colour. This is a stand-in until we encode real Zone Cards.
      </p>
      <div id="zoneView" class="grid"></div>
    </div>

    <div class="card" style="flex:1; min-width:340px;">
      <h2>Badniks (Simplified)</h2>
      <p class="tiny muted">
        Badniks attack only dice being rerolled. Destroy/Avoid are simplified (exact match).
      </p>
      <div id="badnikView"></div>

      <div class="hr"></div>

      <h2>Log</h2>
      <div id="log" class="log mono"></div>

      <div class="hr"></div>

      <h2>Discarded Power Ups</h2>
      <div id="powerUpDiscardView" class="tiny muted"></div>

      <div class="hr"></div>

      <h2>Discarded Badniks</h2>
      <div id="badnikDiscardView" class="tiny muted"></div>

      <div class="hr"></div>

      <h2>Time Scoring</h2>
      <div id="timeScoringView" class="tiny muted"></div>
    </div>
  </div>

  <div id="newGameModal" class="modal-overlay">
    <div class="card modal">
      <h2>New Game</h2>
      <h2>Game Controls</h2>
      <div class="row">
        <label class="pill tiny">Players
          <select id="playerCount">
            <option>1</option><option selected>2</option><option>3</option><option>4</option>
          </select>
        </label>
        <label class="pill tiny">Seed
          <input id="seed" value="" size="10" />
        </label>
      </div>

      <div class="hr"></div>

      <h2>Characters</h2>
      <div id="playerSetup" class="player-setup tiny"></div>
      <div class="tiny muted">Each character can only be used once per game.</div>

      <div class="hr"></div>

      <div class="row modal-actions">
        <button id="cancelNewGameBtn">Cancel</button>
        <button id="confirmNewGameBtn">Start New Game</button>
      </div>
    </div>
  </div>

<script>
/* =======================
   RNG (seeded)
   ======================= */
function mulberry32(seed) {
  let a = seed >>> 0;
  return function() {
    a += 0x6D2B79F5;
    let t = a;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function hashSeed(str) {
  let h = 2166136261 >>> 0;
  for (let i=0;i<str.length;i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}
let __rng = null;
function initGameRng(seed) { __rng = mulberry32(seed); }
function rng(){ return __rng; }
function rollD6(){ return 1 + Math.floor(rng()()*6); }

/* =======================
   Types / helpers
   ======================= */
const DieColor = Object.freeze({ BLUE:"blue", YELLOW:"yellow", RED:"red", BLACK:"black" });

let PRE_GAME_CHARACTERS = [];

function uuid() {
  // browser-safe UUID fallback
  if (crypto?.randomUUID) return crypto.randomUUID();
  return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now();
}

function makeDie(color, value) { return { id: uuid(), color, value }; }
function clone(obj) { return JSON.parse(JSON.stringify(obj)); }
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng()() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function log(state, msg) { state.log.push(msg); return state; }
function makeVulnerable(p){ p.invulnerable = false; }
function makeInvulnerable(p){ p.invulnerable = true; }

function isGameOver(state) {
  if (state.timeTokens <= 0) return "Time ran out (0 Time Tokens)";
  for (const p of state.players) if (p.lives <= 0) return `${p.name} lost final Life`;
  return null;
}

function getDefaultCharacterOrder() {
  return Object.keys(CONFIG.characters);
}

const CHARACTER_PORTRAITS = {
  Sonic: { label: "S", className: "sonic" },
  Tails: { label: "T", className: "tails" },
  Knuckles: { label: "K", className: "knuckles" },
  Amy: { label: "A", className: "amy" }
};

function applyPortrait(el, character) {
  if (!el) return;
  const def = CHARACTER_PORTRAITS[character] || { label: "?", className: "" };
  el.textContent = def.label;
  el.className = `portrait ${def.className}`;
  el.title = character || "Unknown";
}

function updatePortraitsFromSelectors() {
  const selects = Array.from(document.querySelectorAll("[id^='playerCharSelect-']"));
  for (const sel of selects) {
    const idx = sel.id.split("-")[1];
    const portrait = document.getElementById(`playerPortrait-${idx}`);
    applyPortrait(portrait, sel.value);
  }
}

function getPreGameCharacterSelections(playerCount) {
  const allChars = getDefaultCharacterOrder();
  const used = new Set();
  const out = [];
  for (let i = 0; i < playerCount; i++) {
    let choice = PRE_GAME_CHARACTERS[i];
    if (!allChars.includes(choice) || used.has(choice)) {
      choice = allChars.find(c => !used.has(c)) || allChars[i % allChars.length];
    }
    out.push(choice);
    used.add(choice);
  }
  PRE_GAME_CHARACTERS = out.slice();
  return out;
}

function enforceUniqueCharacterSelections() {
  const selects = Array.from(document.querySelectorAll("[id^='playerCharSelect-']"));
  const allChars = getDefaultCharacterOrder();
  const used = new Set();
  for (const sel of selects) {
    let choice = sel.value;
    if (!allChars.includes(choice) || used.has(choice)) {
      choice = allChars.find(c => !used.has(c)) || allChars[0];
      sel.value = choice;
    }
    used.add(choice);
  }
  for (const sel of selects) {
    for (const opt of sel.options) {
      opt.disabled = used.has(opt.value) && opt.value !== sel.value;
    }
  }
  PRE_GAME_CHARACTERS = selects.map(s => s.value);
  updatePortraitsFromSelectors();
}

function renderCharacterSelectors() {
  const container = document.getElementById("playerSetup");
  if (!container) return;
  const playerCount = parseInt(document.getElementById("playerCount").value, 10);
  const selections = getPreGameCharacterSelections(playerCount);
  const allChars = getDefaultCharacterOrder();
  container.innerHTML = "";

  for (let i = 0; i < playerCount; i++) {
    const row = document.createElement("div");
    row.className = "player-setup-row";
    row.innerHTML = `
      <span class="badge">P${i+1}</span>
      <span id="playerPortrait-${i}" class="portrait"></span>
      <select id="playerCharSelect-${i}"></select>
    `;
    const sel = row.querySelector("select");
    for (const name of allChars) {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      sel.appendChild(opt);
    }
    sel.value = selections[i] || allChars[i % allChars.length];
    sel.addEventListener("change", () => {
      PRE_GAME_CHARACTERS[i] = sel.value;
      enforceUniqueCharacterSelections();
    });
    const portrait = row.querySelector(`#playerPortrait-${i}`);
    applyPortrait(portrait, sel.value);
    container.appendChild(row);
  }
  enforceUniqueCharacterSelections();
}

function readCharacterSelections(playerCount) {
  const selections = [];
  for (let i = 0; i < playerCount; i++) {
    const sel = document.getElementById(`playerCharSelect-${i}`);
    selections.push(sel ? sel.value : null);
  }
  return selections;
}

/* =======================
   Dashboard-accurate config
   (from the four images you provided)
   ======================= */
const BIG_RING_AMOUNT = 5; // "big ring" icon: treat as +5 Rings for now (easy to change globally)

const CONFIG = {
  characters: {
    Sonic: {
      ability: { name:"Insta-Shield", perTurnToken:true },
      rollActions: [
        {
          name:"Super Peel Out",
          dice:{ blue:6 },
          // ROLL: Discard the lowest result(s) in your Dice Pool.
          onBuildPool: (ctx) => {
            const { p, state } = ctx;
            const min = Math.min(...p.dicePool.map(d=>d.value));
            const removed = p.dicePool.filter(d => d.value === min);
            if (removed.length) {
              p.dicePool = p.dicePool.filter(d => d.value !== min);
              const label = removed.map(d => `${d.color.toUpperCase()}-${d.value}`).join(" ");
              log(state, `Sonic Super Peel Out (ROLL): discard lowest dice (${label}).`);
            }
          }
        },
        {
          name:"Spin Dash",
          dice:{ blue:1, red:1 },
          // ROLL: Repeat roll until 2 results in your Dice Pool match.
          buildMode:"repeatUntilPair"
        },
        {
          name:"Drop Dash",
          dice:{ yellow:3 },
          // SPEND: If a yellow die is spent on a Zone Card, gain a blue die.
          onSpend: (ctx) => {
            const { state, p, spendTarget, spentDie } = ctx;
            if (spendTarget?.type === "zone" && spentDie?.color === DieColor.YELLOW) {
              const d = makeDie(DieColor.BLUE, rollD6());
              p.dicePool.push(d);
              log(state, `Sonic Drop Dash (SPEND): gained a BLUE die (${d.value}) for spending on a Zone.`);
            }
          }
        }
      ]
    },

    Tails: {
      ability: { name:"Buddy Flight", perTurnToken:false }, // model later
      rollActions: [
        {
          name:"Fly",
          dice:{ yellow:4 },
          // x2, ROLL: Save matching pairs, discard the rest.
          // If no pairs, instead save any 1 die, discard the rest.
          buildMode:"tailsFlyX2"
        },
        {
          name:"Spin Jump",
          dice:{ red:3 },
          // SPEND: Gain yellow die if spent on a Badnik.
          onSpend: (ctx) => {
            const { state, p, spendTarget } = ctx;
            if (spendTarget?.type === "badnik") {
              const d = makeDie(DieColor.YELLOW, rollD6());
              p.dicePool.push(d);
              log(state, `Tails Spin Jump (SPEND): gained a YELLOW die (${d.value}) for spending on a Badnik.`);
            }
          }
        },
        {
          name:"Propeller Tail",
          dice:{ blue:4 },
          // REROLL: Gain yellow die if 2 or more dice were spent since the last Reroll.
          onRerollStepStart: (ctx) => {
            const { state, p } = ctx;
            if (p.spentSinceLastReroll >= 2 && !p.propellerTailBonusGivenSinceReroll) {
              const d = makeDie(DieColor.YELLOW, rollD6());
              p.dicePool.push(d);
              p.propellerTailBonusGivenSinceReroll = true;
              log(state, `Tails Propeller Tail (REROLL): spent>=2 since last reroll -> gained a YELLOW die (${d.value}).`);
            }
          }
        }
      ]
    },

    Knuckles: {
      ability: { name:"Secret Passage", perTurnToken:false }, // model later
      rollActions: [
        {
          name:"Wall Climb",
          dice:{ red:3 },
          repeats:3,
          // ROLL: Save a die as long as its result is higher than last saved die. Discard all unsaved dice.
          buildMode:"knucklesWallClimbX3"
        },
        {
          name:"Spin Attack",
          dice:{ blue:4 },
          // AVOID: May change a blue into a red.
          // For now: we expose a simple "convert selected blue->red" hotkey in UI later if desired.
          onAvoidConvert: { from: DieColor.BLUE, to: DieColor.RED }
        },
        {
          name:"Glide",
          dice:{ yellow:4 },
          // SPEND: May spend another yellow without rerolling if its result is lower than last spent die.
          onSpendChainRule: { color: DieColor.YELLOW, direction:"lower" }
        }
      ]
    },

    Amy: {
      ability: { name:"Piko Piko Hammer", perTurnToken:false },
      rollActions: [
        {
          name:"Hammer Throw",
          dice:{ red:3 },
          // SPEND red: May spend on any player's Badnik (once per turn).
          // Engine note: cross-player targeting is not wired into UI yet; placeholder logs when spending on own badnik.
          onSpend: (ctx) => {
            const { state, p, spentDie, spendTarget } = ctx;
            if (spentDie?.color === DieColor.RED && spendTarget?.type === "badnik") {
              if (p.oncePerTurn?.hammerThrowUsed) return;
              p.oncePerTurn.hammerThrowUsed = true;
              log(state, `Amy Hammer Throw (SPEND): would allow targeting any player's Badnik (once/turn). (UI currently spends on own Badnik.)`);
            }
          }
        },
        {
          name:"Spin Dash",
          dice:{ blue:1, red:1 },
          buildMode:"repeatUntilPair"
        },
        {
          name:"Hammer Rush",
          dice:{ yellow:3 },
          // SPEND yellow: Gain red die if a yellow die is spent on a Zone Card.
          onSpend: (ctx) => {
            const { state, p, spendTarget, spentDie } = ctx;
            if (spendTarget?.type === "zone" && spentDie?.color === DieColor.YELLOW) {
              const d = makeDie(DieColor.RED, rollD6());
              p.dicePool.push(d);
              log(state, `Amy Hammer Rush (SPEND): gained a RED die (${d.value}) for spending on a Zone.`);
            }
          }
        }
      ]
    }
  },

  // Simplified Badnik deck used just to test attack timing and spend rules
  badnikDeck: [
    { name:"Moto Bug", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { name:"Crabmeat", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { name:"Buzz Bomber", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { name:"Chopper", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } }
  ],

  // Simplified Zone generator (placeholder until we encode real Zone Cards)
  zoneGenerator: {
    challengesMin: 5,
    challengesMax: 7,
    deckCounts: { 1: 8, 2: 8, 3: 9, 4: 10 },
    actBoardName: "Green Hill Zone (Act 1)",
    actBoardRewards: {
      Top: { type:"rings", amount:2 },
      Middle: { type:"boost", amount:1 },
      Bottom: { type:"badnik", amount:1 }
    },
    bumper: {
      maxGroups: 1,
      groupChance: 0.55,
      tripleChance: 0.35,
      colorChance: 0.2
    }
  }
};

const POWER_UPS = [
  { id: "super_ring", label: "Super Ring", count: 3 },
  { id: "hyper_ring", label: "Hyper Ring", count: 2 },
  { id: "eggman_mark", label: "Eggman Mark", count: 2 },
  { id: "power_sneakers", label: "Power Sneakers", count: 3 },
  { id: "invincible", label: "Invincible", count: 2 },
  { id: "one_up", label: "1-Up", count: 3 },
  { id: "shield_flame", label: "Flame Shield", count: 2 },
  { id: "shield_bubble", label: "Bubble Shield", count: 2 },
  { id: "shield_lightning", label: "Lightning Shield", count: 2 },
  { id: "shield_blue", label: "Blue Shield", count: 2 }
];

function getPowerUpLabel(id) {
  const entry = POWER_UPS.find(p => p.id === id);
  return entry ? entry.label : id;
}

function getShieldLabel(type) {
  if (type === "flame") return "Flame Shield";
  if (type === "bubble") return "Bubble Shield";
  if (type === "lightning") return "Lightning Shield";
  if (type === "blue") return "Blue Shield";
  return type;
}

function isShieldPowerUp(id) {
  return id && id.startsWith("shield_");
}

function getShieldTypeFromPowerUp(id) {
  return id.replace("shield_", "");
}

function buildPowerUpDeck() {
  const deck = [];
  for (const p of POWER_UPS) {
    const count = Math.max(0, p.count ?? 1);
    for (let i = 0; i < count; i++) deck.push(p.id);
  }
  return shuffle(deck);
}

function drawPowerUp(state) {
  if (!state.powerUpDeck) state.powerUpDeck = [];
  if (!state.powerUpDiscard) state.powerUpDiscard = [];
  if (!state.powerUpDeck.length) {
    if (state.powerUpDiscard.length) {
      state.powerUpDeck = shuffle(state.powerUpDiscard);
      state.powerUpDiscard = [];
      log(state, "Power Up deck reshuffled from discard.");
    } else {
      log(state, "Power Up deck empty: no Power Ups available.");
      return null;
    }
  }
  const next = state.powerUpDeck.shift();
  state.powerUpDiscard.push(next);
  log(state, `Power Up drawn: ${getPowerUpLabel(next)}.`);
  return next;
}

/* =======================
   Zone (simplified)
   ======================= */
function generateZoneCard(genCfg) {
  const bumperCfg = genCfg.bumper || {};
  const maxGroups = bumperCfg.maxGroups ?? 0;
  const groupChance = bumperCfg.groupChance ?? 0;
  const tripleChance = bumperCfg.tripleChance ?? 0.3;
  const colorChance = bumperCfg.colorChance ?? 0.4;

  function rollBaseColor() {
    const r = rng()();
    return r < 0.1 ? DieColor.BLUE : r < 0.2 ? DieColor.YELLOW : r < 0.3 ? DieColor.RED : null;
  }

  function rollBumperColor() {
    const r = rng()();
    return r < 0.34 ? DieColor.BLUE : r < 0.67 ? DieColor.YELLOW : DieColor.RED;
  }

  function rollReward() {
    const rr = rng()();
    const rrr = rng()();
    return rr < 0.25 ? { type:"rings", amount: (rrr<0.1?4:(rrr<0.3?3:(rrr<0.6?2:1))) } :
           rr < 0.50  ? { type:"boost", amount:1 } :
           rr < 0.70 ? { type:"badnik", amount:1 } :
           rr < 0.75 ? { type:"hazard", amount:1 } :
           rr < 0.80 ? { type:"lose_die", amount:1 } :
           rr < 0.90 ? { type:"star_post", amount:1 } :
                       { type:"power_up" };
  }

  const minChallenges = genCfg.challengesMin ?? genCfg.challengesPerCard ?? 7;
  const maxChallenges = genCfg.challengesMax ?? genCfg.challengesPerCard ?? minChallenges;
  const totalChallenges = minChallenges + Math.floor(rng()() * (maxChallenges - minChallenges + 1));

  const challenges = [];
  for (let i=0;i<totalChallenges;i++) {
    const n = rollD6();
    const color = rollBaseColor();
    const reward = rollReward();
    challenges.push({ id: uuid(), n, color, cleared:false, reward });
  }

  const occupied = Array(challenges.length).fill(false);
  const groupCount = Math.min(maxGroups, challenges.length > 2 ? maxGroups : 0);
  for (let g=0; g<groupCount; g++) {
    if (rng()() > groupChance) continue;
    const length = rng()() < tripleChance ? 3 : 2;
    if (length > challenges.length) continue;
    let placed = false;
    for (let attempts=0; attempts<25; attempts++) {
      const start = Math.floor(rng()() * (challenges.length - length + 1));
      if (occupied.slice(start, start + length).some(Boolean)) continue;
      const groupId = uuid();
      const bumperColor = rng()() < colorChance ? rollBumperColor() : null;
      for (let i=0;i<length;i++) {
        const ch = challenges[start + i];
        ch.bumper = { id: groupId, index: i, length };
        ch.n = null;
        ch.color = bumperColor;
        occupied[start + i] = true;
      }
      placed = true;
      break;
    }
    if (!placed) break;
  }

  return { id: uuid(), challenges, bumperLocks: {} };
}

function generateZone(genCfg, playerCount) {
  const deckCount = genCfg.deckCounts?.[playerCount] || genCfg.deckCounts?.[2] || 8;
  const deck = [];
  for (let i=0;i<deckCount;i++) deck.push(generateZoneCard(genCfg));
  shuffle(deck);

  const routes = ["Top","Middle","Bottom"].map(name => ({
    id: uuid(),
    name,
    activeCard: deck.shift() || null
  }));

  return { routes, deck, bossFightReady:false };
}

function generateActBoard(genCfg) {
  const routes = ["Top","Middle","Bottom"].map(name => ({
    id: uuid(),
    name,
    reward: genCfg.actBoardRewards?.[name] || { type:"rings", amount:1 }
  }));
  return { name: genCfg.actBoardName || "Act 1", routes };
}

/* =======================
   Game creation
   ======================= */
function newGame({ playerCount, seedStr, characterSelections }) {
  const seed = hashSeed(seedStr);
  initGameRng(seed);

  const charNames = Object.keys(CONFIG.characters);
  const requested = Array.isArray(characterSelections) ? characterSelections : [];
  const used = new Set();
  const finalChars = [];
  for (let i = 0; i < playerCount; i++) {
    let choice = requested[i];
    if (!charNames.includes(choice) || used.has(choice)) {
      choice = charNames.find(c => !used.has(c)) || charNames[i % charNames.length];
    }
    finalChars.push(choice);
    used.add(choice);
  }

  const players = Array.from({length: playerCount}, (_,i) => {
    const character = finalChars[i];
    const rollActions = CONFIG.characters[character].rollActions;
    return {
      id: i,
      name: `P${i+1}`,
      character,
      chosenRollAction: rollActions[0].name,
      rollActionSelectedThisTurn: false,

      lives: 3,
      boost: 1,
      heldRings: 0,
      savedRings: 0,
      zoneCardsCompleted: 0,
      animalTokens: 0,
      timeTokensTaken: 0,
      chaosEmeraldsReady: 0,
      chaosEmeraldsSpent: 0,
      hyperRing: false,
      invincibleTokens: 0,
      shield: null,
      flameShieldArmed: false,
      lightningShieldArmed: false,
      blueShieldLostThisTurn: false,

      badniks: [],
      dicePool: [],
      selectedDieId: null,

      invulnerable: false,
      spentSinceLastReroll: 0,
      hasRerolledThisTurn: false,
      propellerTailBonusGivenSinceReroll: false,
      oncePerTurn: {},
      lastChainSpendRule: null, // used for Glide-like chaining
    };
  });

  const badnikDeck = shuffle(clone(CONFIG.badnikDeck));
  const zone = generateZone(CONFIG.zoneGenerator, playerCount);
  const actBoard = generateActBoard(CONFIG.zoneGenerator);
  const powerUpDeck = buildPowerUpDeck();

  return {
    phase: "ROLL_ACTION", // ROLL_ACTION | SPENDING | REROLL | END_TURN | GAME_OVER
    activePlayer: 0,
    timeTokens: 7,
    players,
    badnikDeck,
    badnikDiscard: [],
    pendingBadnikReward: null,
    powerUpDeck,
    powerUpDiscard: [],
    zone,
    actBoard,
    ui: { spend: null, discard: null, starPost: null },
    pendingPowerUp: null,
    pendingPowerUpQueue: [],
    pendingDamage: null,
    log: [`Game started (${playerCount}P), seed="${seedStr}"`]
  };
}

/* =======================
   Core rules: damage / hazard / badnik draw
   ======================= */
function takeDamage(state, reason) {
  const p = state.players[state.activePlayer];

  if (p.invulnerable) {
    log(state, `No damage (invulnerable): ${reason}`);
    return state;
  }

  if (p.shield) {
    const shieldType = p.shield.type;
    p.shield = null;
    if (shieldType === "blue") p.blueShieldLostThisTurn = true;
    log(state, `${p.name} ignores damage with ${getShieldLabel(shieldType)} (shield discarded).`);
    return state;
  }

  if (p.invincibleTokens > 0 && p.dicePool.length > 0) {
    clearSpendUi(state);
    clearDiscardUi(state);
    clearStarPostUi(state);
    state.pendingDamage = {
      reason,
      selectedDieId: null,
      resumePhase: state.phase,
      resetAfterReroll: state.phase === "REROLL"
    };
    log(state, `${p.name} may discard a die to ignore damage (Invincible).`);
    return state;
  }

  return applyDamage(state, reason);
}

function applyDamage(state, reason) {
  const p = state.players[state.activePlayer];
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);

  const heldBefore = p.heldRings;
  if (heldBefore > 0 && p.hyperRing) {
    const kept = Math.ceil(heldBefore / 2);
    const lost = heldBefore - kept;
    p.heldRings = kept;
    log(state, `DAMAGE (${reason}): Hyper Ring keeps ${kept} Held Rings (lost ${lost}).`);
  } else {
    p.heldRings = 0;
    if (heldBefore > 0) {
      log(state, `DAMAGE (${reason}): ${p.name} loses all Held Rings (${heldBefore}).`);
    }
  }

  if (heldBefore === 0) {
    p.lives -= 1;
    log(state, `DAMAGE (${reason}): No held rings -> ${p.name} loses 1 Life (now ${p.lives}).`);
  }

  // Clear badniks and dice pool, end turn without time token
  if (p.badniks.length) {
    state.badnikDiscard.push(...p.badniks);
  }
  p.badniks = [];
  p.dicePool = [];
  p.selectedDieId = null;
  p.spentSinceLastReroll = 0;
  p.hasRerolledThisTurn = false;
  p.propellerTailBonusGivenSinceReroll = false;
  p.lastChainSpendRule = null;
  p.invincibleTokens = 0;
  p.flameShieldArmed = false;
  p.lightningShieldArmed = false;
  state.pendingDamage = null;

  makeInvulnerable(p);
  state.phase = "END_TURN";

  const over = isGameOver(state);
  if (over) {
    state.phase = "GAME_OVER";
    log(state, `GAME OVER: ${over}`);
  } else {
    log(state, "Turn ends immediately (no Time Token taken).");
  }
  return state;
}

function hazardRoll(state) {
  const p = state.players[state.activePlayer];
  const v = rollD6();
  log(state, `⚠️ Hazard Die rolled: ${v}`);
  if (p.dicePool.some(d => d.value === v)) {
    takeDamage(state, `Hazard matched a die value (${v})`);
  } else {
    log(state, `Hazard did not match Dice Pool → no damage.`);
  }
}

function drawBadnik(state, targetPlayer) {
  const p = targetPlayer;
  if (p.badniks.length >= 3) { log(state, `${p.name} cannot draw more Badniks (already 3).`); return; }
  if (!state.badnikDeck.length) {
    state.badnikDeck = shuffle(state.badnikDiscard);
    state.badnikDiscard = [];
    log(state, `Badnik deck reshuffled from discard.`);
  }
  const b = state.badnikDeck.shift();
  p.badniks.push(b);
  log(state, `${p.name} draws Badnik: ${b.name}`);
}

function getEligibleBadnikTargets(state) {
  return state.players.filter(pl => pl.badniks.length < 3);
}

function queueBadnikRewardChoice(state, count = 1) {
  for (let i = 0; i < count; i++) {
    const eligible = getEligibleBadnikTargets(state);
    if (!eligible.length) {
      log(state, "Badnik reward: no eligible players can draw (all at 3).");
      continue;
    }
    if (!state.pendingBadnikReward) {
      state.pendingBadnikReward = { remaining: 0 };
    }
    state.pendingBadnikReward.remaining += 1;
    log(state, "Badnik reward: choose a player with fewer than 3 Badniks to draw.");
  }
}

function resolveBadnikRewardChoice(state, targetPlayerId) {
  const pending = state.pendingBadnikReward;
  if (!pending) return;
  const target = state.players.find(pl => pl.id === targetPlayerId);
  if (!target) return;
  if (target.badniks.length >= 3) {
    log(state, `${target.name} cannot draw more Badniks (already 3).`);
    return;
  }
  drawBadnik(state, target);
  pending.remaining -= 1;
  if (pending.remaining <= 0) {
    state.pendingBadnikReward = null;
    return;
  }
  if (!getEligibleBadnikTargets(state).length) {
    log(state, "Badnik reward: no eligible players can draw (all at 3).");
    state.pendingBadnikReward = null;
  }
}

function queuePowerUp(state, powerUpId) {
  state.pendingPowerUpQueue.push(powerUpId);
  log(state, `Power Up queued: ${getPowerUpLabel(powerUpId)}.`);
}

function processQueuedPowerUps(state) {
  if (state.pendingPowerUp || !state.pendingPowerUpQueue.length) return;
  const next = state.pendingPowerUpQueue.shift();
  applyPowerUp(state, next);
}

function applyPowerUp(state, powerUpId) {
  const p = state.players[state.activePlayer];
  if (powerUpId === "super_ring") {
    p.heldRings += 5;
    log(state, `Power Up: Super Ring (+5 Rings). Held=${p.heldRings}`);
    return;
  }
  if (powerUpId === "hyper_ring") {
    p.hyperRing = true;
    log(state, "Power Up: Hyper Ring (keep half held Rings when damaged).");
    return;
  }
  if (powerUpId === "power_sneakers") {
    p.boost += 2;
    log(state, `Power Up: Power Sneakers (+2 Boost). Boost=${p.boost}`);
    return;
  }
  if (powerUpId === "one_up") {
    if (state.pendingPowerUp) return queuePowerUp(state, powerUpId);
    state.pendingPowerUp = { kind: "one_up" };
    log(state, "Power Up: 1-Up. Choose a die color to add to your Dice Pool.");
    return;
  }
  if (powerUpId === "invincible") {
    p.invincibleTokens += 1;
    log(state, "Power Up: Invincible (discard a die to ignore damage this turn).");
    return;
  }
  if (powerUpId === "eggman_mark") {
    if (state.pendingPowerUp) return queuePowerUp(state, powerUpId);
    state.pendingPowerUp = { kind: "eggman_mark" };
    log(state, "Power Up: Eggman Mark. Choose a player to receive a Badnik.");
    return;
  }
  if (isShieldPowerUp(powerUpId)) {
    const newShield = getShieldTypeFromPowerUp(powerUpId);
    if (!p.shield) {
      p.shield = { type: newShield };
      log(state, `Power Up: ${getShieldLabel(newShield)} equipped.`);
      return;
    }
    if (state.pendingPowerUp) return queuePowerUp(state, powerUpId);
    state.pendingPowerUp = { kind: "shield_swap", newShield };
    log(state, `${p.name} drew ${getShieldLabel(newShield)} but already has ${getShieldLabel(p.shield.type)}.`);
    return;
  }
  log(state, `Unknown Power Up: ${powerUpId}`);
}

function resolveEggmanMark(state, targetPlayerId) {
  const target = state.players.find(pl => pl.id === targetPlayerId);
  if (!target) return;
  drawBadnik(state, target);
  state.pendingPowerUp = null;
  processQueuedPowerUps(state);
}

function resolveOneUp(state, color) {
  const p = state.players[state.activePlayer];
  const pending = state.pendingPowerUp;
  if (!pending || pending.kind !== "one_up") return;
  const d = makeDie(color, rollD6());
  p.dicePool.push(d);
  log(state, `${p.name} gains a ${color.toUpperCase()} die from 1-Up (${d.value}).`);
  state.pendingPowerUp = null;
  processQueuedPowerUps(state);
}

function resolveShieldSwap(state, keepCurrent) {
  const p = state.players[state.activePlayer];
  const pending = state.pendingPowerUp;
  if (!pending || pending.kind !== "shield_swap") return;
  if (keepCurrent) {
    log(state, `${p.name} keeps ${getShieldLabel(p.shield.type)} and discards ${getShieldLabel(pending.newShield)}.`);
  } else {
    log(state, `${p.name} swaps to ${getShieldLabel(pending.newShield)} (discarded ${getShieldLabel(p.shield.type)}).`);
    p.shield = { type: pending.newShield };
  }
  state.pendingPowerUp = null;
  processQueuedPowerUps(state);
}

function maybeApplyLightningShield(state, reward) {
  const p = state.players[state.activePlayer];
  if (!p.shield || p.shield.type !== "lightning") return reward;
  if (!p.lightningShieldArmed || p.oncePerTurn.lightningShieldUsed) return reward;
  p.lightningShieldArmed = false;
  p.oncePerTurn.lightningShieldUsed = true;
  const amount = reward.type === "rings" ? reward.amount * 2 : 2;
  log(state, `${p.name} Lightning Shield: reward changed to rings x2 (${amount}).`);
  return { type:"rings", amount };
}

function confirmInvincibleDiscard(state) {
  const p = state.players[state.activePlayer];
  const pending = state.pendingDamage;
  if (!pending || !pending.selectedDieId) return;
  const idx = p.dicePool.findIndex(d => d.id === pending.selectedDieId);
  if (idx < 0) return;
  const removed = p.dicePool.splice(idx, 1)[0];
  if (p.selectedDieId === removed.id) p.selectedDieId = null;
  p.invincibleTokens = Math.max(0, p.invincibleTokens - 1);
  state.pendingDamage = null;
  log(state, `${p.name} uses Invincible: discards ${removed.color.toUpperCase()}-${removed.value} to ignore damage.`);
  if (pending.resetAfterReroll) {
    p.spentSinceLastReroll = 0;
    p.propellerTailBonusGivenSinceReroll = false;
    p.lastChainSpendRule = null;
    state.phase = "SPENDING";
  } else if (pending.resumePhase) {
    state.phase = pending.resumePhase;
  }
}

function declineInvincible(state) {
  const pending = state.pendingDamage;
  if (!pending) return;
  state.pendingDamage = null;
  applyDamage(state, pending.reason);
}

function applyReward(state, reward) {
  const p = state.players[state.activePlayer];
  if (!reward) return;
  const effectiveReward = maybeApplyLightningShield(state, reward);
  if (effectiveReward.type === "rings") {
    p.heldRings += effectiveReward.amount;
    log(state, `Reward: +${effectiveReward.amount} Rings (Held=${p.heldRings})`);
  } else if (effectiveReward.type === "boost") {
    p.boost += effectiveReward.amount;
    log(state, `Reward: +${effectiveReward.amount} Boost (Boost=${p.boost})`);
  } else if (effectiveReward.type === "badnik") {
    for (let i=0;i<effectiveReward.amount;i++) {
      drawBadnik(state, p);
      queueBadnikRewardChoice(state, 1);
    }
  } else if (effectiveReward.type === "hazard") {
    for (let i=0;i<effectiveReward.amount;i++) hazardRoll(state);
  } else if (effectiveReward.type === "lose_die") {
    queueLoseDieReward(state, "reward");
  } else if (effectiveReward.type === "star_post") {
    queueStarPostReward(state, "reward");
  } else if (effectiveReward.type === "power_up") {
    const powerUpId = effectiveReward.powerUp || drawPowerUp(state);
    if (!powerUpId) return;
    if (effectiveReward.powerUp) {
      if (!state.powerUpDiscard) state.powerUpDiscard = [];
      state.powerUpDiscard.push(powerUpId);
    }
    if (state.pendingPowerUp) {
      queuePowerUp(state, powerUpId);
    } else {
      applyPowerUp(state, powerUpId);
    }
  }
}

function completeZoneCard(state, route) {
  const card = route.activeCard;
  if (!card) return;
  if (card.challenges.some(ch => !ch.cleared)) return;

  const p = state.players[state.activePlayer];
  p.zoneCardsCompleted = (p.zoneCardsCompleted || 0) + 1;
  log(state, `${p.name} completed a Zone Card on ${route.name} Route (total ${p.zoneCardsCompleted}).`);

  const actReward = getActBoardReward(state, route.name);
  if (actReward) {
    applyReward(state, actReward);
    log(state, `Act Board reward for ${route.name} Route: ${formatRewardLabel(actReward)}.`);
  }

  if (state.zone.deck.length) {
    route.activeCard = state.zone.deck.shift();
    log(state, `New Zone Card dealt to ${route.name} Route. (${state.zone.deck.length} left)`);
  } else {
    route.activeCard = null;
    state.zone.bossFightReady = true;
    log(state, "Zone Card Deck empty -> Boss Fight should begin (not implemented).");
  }
}

function clearSpendUi(state) {
  if (state?.ui) state.ui.spend = null;
}

function clearDiscardUi(state) {
  if (state?.ui) state.ui.discard = null;
}

function clearStarPostUi(state) {
  if (state?.ui) state.ui.starPost = null;
}

function formatRewardLabel(reward) {
  if (!reward) return "none";
  if (reward.type === "lose_die") return "lose die";
  if (reward.type === "star_post") return "star post";
  if (reward.type === "power_up") return "power up";
  if (reward.amount != null) return `${reward.type} x${reward.amount}`;
  return `${reward.type}`;
}

function getActBoardReward(state, routeName) {
  const route = state?.actBoard?.routes?.find(r => r.name === routeName);
  return route?.reward || null;
}

function queueLoseDieReward(state, reason) {
  const p = getActivePlayer(state);
  if (!state.ui) state.ui = { spend: null, discard: null, starPost: null };
  if (state.ui.discard?.open) {
    log(state, `Lose a die (${reason}): discard already pending.`);
    return;
  }
  if (!p.dicePool.length) {
    log(state, `Lose a die (${reason}): no dice in pool.`);
    return;
  }
  if (p.dicePool.length === 1) {
    const removed = p.dicePool.pop();
    log(state, `Lose a die (${reason}): discarded ${removed.color.toUpperCase()}-${removed.value}.`);
    p.selectedDieId = null;
    return;
  }
  state.ui.discard = {
    open: true,
    reason,
    selectedDieId: null,
    postSpend: null
  };
  log(state, `Lose a die (${reason}): choose a die to discard.`);
}

function queueStarPostReward(state, reason) {
  const p = getActivePlayer(state);
  if (!state.ui) state.ui = { spend: null, discard: null, starPost: null };
  if (state.ui.starPost?.open) {
    log(state, `Star Post (${reason}): choice already pending.`);
    return;
  }
  if (p.heldRings <= 0) {
    log(state, `Star Post (${reason}): no held rings to save.`);
    return;
  }
  state.ui.starPost = {
    open: true,
    reason,
    postSpend: null
  };
  log(state, `Star Post (${reason}): choose to save all held rings or keep them held.`);
}

function getBumperLock(card, groupId) {
  if (!card) return null;
  if (!card.bumperLocks) card.bumperLocks = {};
  const value = card.bumperLocks[groupId];
  return value == null ? null : value;
}

function formatChallengeRequirement(ch, card) {
  if (!ch) return "NONE";
  const colorPrefix = ch.color ? `${ch.color.toUpperCase()}-` : "";
  if (ch.bumper) {
    const lock = getBumperLock(card, ch.bumper.id);
    return `${colorPrefix}BUMP-${lock == null ? "ANY" : lock}`;
  }
  const value = ch.n != null ? ch.n : "ANY";
  return `${colorPrefix || "ANY-"}${value}`;
}

function getChallengeColorClass(ch) {
  if (ch?.color === DieColor.BLUE) return "req-blue";
  if (ch?.color === DieColor.YELLOW) return "req-yellow";
  if (ch?.color === DieColor.RED) return "req-red";
  return "req-any";
}

function formatChallengeChip(ch, card) {
  const cls = getChallengeColorClass(ch);
  if (ch?.bumper) {
    return `<span class="req-chip ${cls}"><img src="img/bumper.png" alt="Bumper"></span>`;
  }
  if (ch?.n != null) {
    return `<span class="req-chip ${cls}"><img src="img/${ch.n}.png" alt="${ch.n}"></span>`;
  }
  return `<span class="req-chip ${cls}">ANY</span>`;
}

function isDieLegalForChallenge(ch, card, die) {
  if (!ch || !die) return false;
  if (ch.color && ch.color !== die.color) return false;
  if (ch.bumper) {
    if (ch.bumper.index === 0) return true;
    const lock = getBumperLock(card, ch.bumper.id);
    return lock != null && lock === die.value;
  }
  return ch.n === die.value;
}

function applyBumperLock(ch, card, die) {
  if (!ch?.bumper || !card) return;
  if (!card.bumperLocks) card.bumperLocks = {};
  const lock = card.bumperLocks[ch.bumper.id];
  if (lock == null && ch.bumper.index === 0) {
    card.bumperLocks[ch.bumper.id] = die.value;
  }
}

function getEffectiveSpendDie(p, die, options = {}) {
  const amyEligible = p.character === "Amy" && die.color === DieColor.RED;
  const useAmyRaise = amyEligible && !!options.useAmyRaise;
  const raisedValue = useAmyRaise ? ((die.value % 6) + 1) : die.value;
  const amyAdjustedDie = useAmyRaise ? { ...die, value: raisedValue } : die;

  const canUseFlame = p.shield?.type === "flame" && !p.oncePerTurn.flameShieldUsed;
  const wantsFlame = options.useFlameShieldOverride ?? p.flameShieldArmed;
  const useFlameShield = canUseFlame && wantsFlame && amyAdjustedDie.color !== DieColor.RED;
  const effectiveDie = useFlameShield ? { ...amyAdjustedDie, color: DieColor.RED } : amyAdjustedDie;
  return { effectiveDie, useFlameShield, useAmyRaise };
}

function refreshSpendTargets(state, die) {
  const spendUi = state.ui?.spend;
  if (!spendUi || !die) return false;
  const p = getActivePlayer(state);
  const { effectiveDie } = getEffectiveSpendDie(p, die, {
    useFlameShieldOverride: spendUi.useFlameShield,
    useAmyRaise: spendUi.amyRaise
  });
  const targets = buildSpendTargets(state, effectiveDie);
  spendUi.targets = targets;
  spendUi.selectedTargetId = targets[0]?.id || null;
  return targets.length > 0;
}

function buildSpendTargets(state, die) {
  const p = getActivePlayer(state);
  const targets = [];

  for (const route of state.zone.routes) {
    const card = route.activeCard;
    const ch = card?.challenges.find(x=>!x.cleared);
    if (!ch) continue;
    if (isDieLegalForChallenge(ch, card, die)) {
      const rewardLabel = formatRewardLabel(ch.reward);
      const reqLabel = formatChallengeRequirement(ch, card);
      const label = `Zone: ${route.name} ${reqLabel} (reward: ${rewardLabel})`;
      targets.push({
        id: uuid(),
        type: "zone",
        routeId: route.id,
        challengeId: ch.id,
        label
      });
    }
  }

  for (let i=0;i<p.badniks.length;i++) {
    const b = p.badniks[i];
    const avoidOk = b.avoid && (b.avoid.color === die.color && b.avoid.value === die.value);
    const destroyOk = b.destroy && (die.color === DieColor.RED && b.destroy.value === die.value);
    if (avoidOk) {
      targets.push({
        id: uuid(),
        type: "badnik",
        badnikIndex: i,
        mode: "avoid",
        label: `Badnik: avoid ${b.name} (${b.avoid.color[0].toUpperCase()}${b.avoid.value})`
      });
    }
    if (destroyOk) {
      targets.push({
        id: uuid(),
        type: "badnik",
        badnikIndex: i,
        mode: "destroy",
        label: `Badnik: destroy ${b.name} (R${b.destroy.value})`
      });
    }
  }

  return targets;
}

function openSpendUiForDie(state, die) {
  if (!state.ui) state.ui = { spend: null, discard: null, starPost: null };
  const p = getActivePlayer(state);
  const { effectiveDie, useFlameShield } = getEffectiveSpendDie(p, die, { useAmyRaise: false });
  const targets = buildSpendTargets(state, effectiveDie);
  if (!targets.length) return false;
  state.ui.spend = {
    open: true,
    dieId: die.id,
    targets,
    selectedTargetId: targets[0].id,
    useFlameShield,
    amyRaise: false
  };
  return true;
}

function preselectSpendTarget(state, targetInfo) {
  const p = getActivePlayer(state);
  if (state.phase !== "SPENDING") return log(state, "Cannot select spend target outside SPENDING.");
  if (state.ui?.discard?.open) return log(state, "Resolve the discard before selecting a spend target.");
  if (state.ui?.starPost?.open) return log(state, "Resolve the Star Post before selecting a spend target.");
  if (state.pendingPowerUp || state.pendingDamage || state.pendingBadnikReward) {
    return log(state, "Resolve the pending reward before selecting a target.");
  }
  const die = p.dicePool.find(d => d.id === p.selectedDieId) || p.dicePool[0];
  if (!die) return log(state, "Select a die before targeting.");

  if (!openSpendUiForDie(state, die)) {
    return log(state, "No legal spend targets for that die.");
  }

  const spendUi = state.ui?.spend;
  if (!spendUi) return state;

  let match = null;
  if (targetInfo.type === "zone") {
    match = spendUi.targets.find(t =>
      t.type === "zone" &&
      t.routeId === targetInfo.routeId &&
      t.challengeId === targetInfo.challengeId
    );
  } else if (targetInfo.type === "badnik") {
    const candidates = spendUi.targets.filter(t =>
      t.type === "badnik" && t.badnikIndex === targetInfo.badnikIndex
    );
    if (targetInfo.mode) {
      match = candidates.find(t => t.mode === targetInfo.mode);
    }
    if (!match) {
      match = candidates.find(t => t.mode === "destroy") || candidates[0];
    }
  }

  if (!match) {
    return log(state, "That target is not legal for the selected die.");
  }

  spendUi.selectedTargetId = match.id;
  return state;
}

/* =======================
   Roll Action lookup
   ======================= */
function getActivePlayer(state){ return state.players[state.activePlayer]; }
function getCharCfg(p){ return CONFIG.characters[p.character]; }
function getRollActionCfg(p){
  const c = getCharCfg(p);
  return c.rollActions.find(r=>r.name===p.chosenRollAction) || c.rollActions[0];
}

/* =======================
   Build dice pool (dashboard-accurate)
   ======================= */
function buildDicePool(state) {
  if (state.phase !== "ROLL_ACTION") return log(state, `Cannot build pool: phase=${state.phase}`);

  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);

  const p = getActivePlayer(state);
  if (!p.rollActionSelectedThisTurn) {
    return log(state, `${p.name} must select a Roll Action before building the Dice Pool.`);
  }
  p.oncePerTurn = {};                 // refresh "once per turn" flags
  p.spentSinceLastReroll = 0;
  p.hasRerolledThisTurn = false;
  p.propellerTailBonusGivenSinceReroll = false;
  p.lastChainSpendRule = null;

  const ra = getRollActionCfg(p);

  p.dicePool = [];
  p.selectedDieId = null;

  function rollBatch(diceSpec) {
    const out = [];
    for (const [color, count] of Object.entries(diceSpec)) {
      for (let i=0;i<count;i++) out.push(makeDie(color, rollD6()));
    }
    return out;
  }

  if (ra.buildMode === "repeatUntilPair") {
    // Roll the action dice repeatedly, add all rolled dice, stop once any pair of values matches in pool.
    let safety = 4;
    while (safety-- > 0) {
      const batch = rollBatch(ra.dice);
      p.dicePool.push(...batch);
      const counts = new Map();
      let hasPair = false;
      for (const d of p.dicePool) {
        counts.set(d.value, (counts.get(d.value)||0)+1);
        if (counts.get(d.value) >= 2) { hasPair = true; break; }
      }
      log(state, `${p.name} Spin Dash roll: ${batch.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")} → pool size ${p.dicePool.length}`);
      if (hasPair) { log(state, `Spin Dash condition met: at least one matching pair exists in Dice Pool.`); break; }
    }
  }
  else if (ra.buildMode === "tailsFlyX2") {
    // x2: each time roll 4 yellows; save matching pairs else save any 1; discard rest.
    for (let rep=1; rep<=2; rep++) {
      const batch = rollBatch(ra.dice); // 4 yellows
      const byVal = new Map();
      for (const d of batch) byVal.set(d.value, (byVal.get(d.value)||[]).concat([d]));
      const pairs = [];
      for (const [val, arr] of byVal.entries()) {
        if (arr.length >= 2) pairs.push(...arr.slice(0,2));
      }
      if (pairs.length > 0) {
        p.dicePool.push(...pairs);
        log(state, `${p.name} Fly (x${rep}): rolled ${batch.map(d=>`Y${d.value}`).join(" ")} → saved pairs ${pairs.map(d=>`Y${d.value}`).join(" ")}.`);
      } else {
        // save any 1 die (choose highest to be practical)
        batch.sort((a,b)=>b.value-a.value);
        p.dicePool.push(batch[0]);
        log(state, `${p.name} Fly (x${rep}): rolled ${batch.map(d=>`Y${d.value}`).join(" ")} → no pairs; saved one die Y${batch[0].value}.`);
      }
    }
  }
  else if (ra.buildMode === "knucklesWallClimbX3") {
    // x3: each repeat roll 3 reds; greedily save ascending sequence (smallest possible > lastSaved), discard rest.
    let last = 0;
    for (let rep=1; rep<=3; rep++) {
      const batch = rollBatch(ra.dice); // 3 reds
      batch.sort((a,b)=>a.value-b.value);

      const savedThisRep = [];
      for (const d of batch) {
        if (d.value > last) { savedThisRep.push(d); last = d.value; }
      }
      if (savedThisRep.length === 0) {
        // if none higher, save the highest anyway (keeps game moving; adjust if you prefer strict failure)
        const fallback = batch[batch.length-1];
        savedThisRep.push(fallback);
        last = fallback.value;
      }
      p.dicePool.push(...savedThisRep);
      log(state, `${p.name} Wall Climb (x${rep}): rolled ${batch.map(d=>`R${d.value}`).join(" ")} → saved ${savedThisRep.map(d=>`R${d.value}`).join(" ")}.`);
    }
  }
  else {
    // Standard: roll once, add all dice
    const batch = rollBatch(ra.dice);
    p.dicePool.push(...batch);
    log(state, `${p.name} rolled: ${batch.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);
  }

  // Apply any ROLL effect after building pool
  if (typeof ra.onBuildPool === "function") {
    ra.onBuildPool({ state, p });
  }

  makeVulnerable(p); // unless damage happened previously
  state.phase = "SPENDING";
  log(state, `${p.name} Dice Pool built: ${p.dicePool.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);
  return state;
}

/* =======================
   Boost after Roll Action
   ======================= */
function boostAfterRollAction(state) {
  const p = getActivePlayer(state);
  if (p.boost <= 0) return log(state, `${p.name} has no Boost tokens.`);
  if (state.phase !== "SPENDING" || p.dicePool.length === 0) return log(state, `Boost-after-roll-action must be used right after building a Dice Pool.`);

  p.boost -= 1;
  log(state, `${p.name} spends 1 Boost (after Roll Action): reroll Dice Pool and enter REROLL step (Badnik-vulnerable).`);
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);
  state.phase = "REROLL";
  return rerollStep(state);
}

/* =======================
   Spending
   ======================= */
function spendSelectedDie(state) {
  const p = getActivePlayer(state);
  if (state.phase !== "SPENDING") return log(state, `Cannot spend: phase=${state.phase}`);
  if (state.pendingPowerUp || state.pendingDamage || state.pendingBadnikReward) {
    return log(state, "Resolve the pending reward before spending.");
  }

  if (!p.dicePool.length) { state.phase = "END_TURN"; return log(state, `No dice left → End Turn`); }

  const die = p.dicePool.find(d => d.id === p.selectedDieId) || p.dicePool[0];

  if (!openSpendUiForDie(state, die)) {
    clearSpendUi(state);
    return takeDamage(state, "Could not spend a die during Spending Step");
  }
  return state;
}

function confirmSpendSelection(state) {
  const p = getActivePlayer(state);
  const spendUi = state.ui?.spend;
  if (state.phase !== "SPENDING") { clearSpendUi(state); return state; }
  if (!spendUi || !spendUi.open) return state;

  const die = p.dicePool.find(d => d.id === spendUi.dieId);
  if (!die) {
    log(state, "Spend canceled: selected die is no longer available.");
    clearSpendUi(state);
    return state;
  }

  const target = spendUi.targets.find(t => t.id === spendUi.selectedTargetId);
  if (!target) {
    log(state, "Spend canceled: no target selected.");
    clearSpendUi(state);
    return state;
  }

  const spendMeta = { useFlameShield: spendUi.useFlameShield, amyRaise: spendUi.amyRaise };
  clearSpendUi(state);
  return spendDieOnTarget(state, die, target, spendMeta);
}

function cancelSpendSelection(state) {
  clearSpendUi(state);
  return state;
}

function finalizePostSpend(state, spentDie, ra) {
  const p = getActivePlayer(state);
  if (!spentDie) return state;

  if (!p.dicePool.length) { state.phase = "END_TURN"; return log(state, "Dice Pool empty -> End Turn"); }

  if (spentDie.color === DieColor.BLUE) {
    log(state, `Run die property: ${p.name} may spend another die without rerolling.`);
    state.phase = "SPENDING";
    return state;
  }

  if (p.lastChainSpendRule?.color === DieColor.YELLOW && ra?.name === "Glide") {
    const canChain = p.dicePool.some(d => d.color === DieColor.YELLOW && d.value < p.lastChainSpendRule.lastSpentValue);
    if (canChain) {
      log(state, `Knuckles Glide (SPEND): may spend another YELLOW without reroll if it is lower than last spent (${p.lastChainSpendRule.lastSpentValue}).`);
      state.phase = "SPENDING";
      return state;
    }
  }

  state.phase = "REROLL";
  log(state, "Must REROLL remaining dice before next spend.");
  return state;
}

function confirmDiscardSelection(state) {
  const p = getActivePlayer(state);
  const discardUi = state.ui?.discard;
  if (!discardUi?.open) return state;
  const die = p.dicePool.find(d => d.id === discardUi.selectedDieId);
  if (!die) {
    log(state, "Discard canceled: no die selected.");
    return state;
  }

  p.dicePool = p.dicePool.filter(d => d.id !== die.id);
  p.selectedDieId = null;
  log(state, `Lose a die (${discardUi.reason}): discarded ${die.color.toUpperCase()}-${die.value}.`);

  const post = discardUi.postSpend;
  clearDiscardUi(state);
  if (post?.spentDieColor) {
    const ra = getRollActionCfg(p);
    return finalizePostSpend(state, { color: post.spentDieColor }, ra);
  }
  return state;
}

function confirmStarPostSave(state) {
  const p = getActivePlayer(state);
  const starUi = state.ui?.starPost;
  if (!starUi?.open) return state;

  const savedNow = p.heldRings;
  p.heldRings = 0;
  p.savedRings += savedNow;
  log(state, `Star Post (${starUi.reason}): saved ${savedNow} Rings (Saved=${p.savedRings}).`);
  if (savedNow >= 5) {
    log(state, "Bonus Stage triggered (not implemented).");
  }

  const post = starUi.postSpend;
  clearStarPostUi(state);
  if (post?.spentDieColor) {
    const ra = getRollActionCfg(p);
    return finalizePostSpend(state, { color: post.spentDieColor }, ra);
  }
  return state;
}

function confirmStarPostKeep(state) {
  const p = getActivePlayer(state);
  const starUi = state.ui?.starPost;
  if (!starUi?.open) return state;
  log(state, `Star Post (${starUi.reason}): kept ${p.heldRings} Rings held.`);
  const post = starUi.postSpend;
  clearStarPostUi(state);
  if (post?.spentDieColor) {
    const ra = getRollActionCfg(p);
    return finalizePostSpend(state, { color: post.spentDieColor }, ra);
  }
  return state;
}

function spendDieOnTarget(state, die, target, spendMeta) {
  const p = getActivePlayer(state);
  const ra = getRollActionCfg(p);
  const { effectiveDie, useFlameShield, useAmyRaise } = getEffectiveSpendDie(p, die, {
    useFlameShieldOverride: spendMeta?.useFlameShield,
    useAmyRaise: spendMeta?.amyRaise
  });
  let spendTarget = null;
  let challengeReward = null;
  let completedRoute = null;
  const spendLabel = useAmyRaise
    ? `${die.color.toUpperCase()}-${die.value} (Piko Piko Hammer -> ${effectiveDie.value})`
    : `${die.color.toUpperCase()}-${die.value}`;

  if (target.type === "zone") {
    const route = state.zone.routes.find(r => r.id === target.routeId);
    const card = route?.activeCard;
    const ch = card?.challenges.find(c => c.id === target.challengeId);
    const next = card?.challenges.find(x => !x.cleared);
    const legal = ch && isDieLegalForChallenge(ch, card, effectiveDie);
    if (!route || !ch || !next || next.id !== ch.id || !legal) {
      log(state, "Spend failed: zone target no longer legal.");
      return state;
    }
    ch.cleared = true;
    applyBumperLock(ch, card, effectiveDie);
    spendTarget = { type:"zone", route: route.name, challengeId: ch.id };
    const reqLabel = formatChallengeRequirement(ch, card);
    log(state, `${p.name} spends ${spendLabel} to clear ${route.name} challenge (${reqLabel}).`);
    challengeReward = ch.reward;
    completedRoute = route;
  } else if (target.type === "badnik") {
    const b = p.badniks[target.badnikIndex];
    if (!b) {
      log(state, "Spend failed: badnik target no longer exists.");
      return state;
    }
    const avoidOk = b.avoid && (b.avoid.color === effectiveDie.color && b.avoid.value === effectiveDie.value);
    const destroyOk = b.destroy && (effectiveDie.color === DieColor.RED && b.destroy.value === effectiveDie.value);
    if (target.mode === "avoid" && !avoidOk) {
      log(state, "Spend failed: avoid target no longer legal.");
      return state;
    }
    if (target.mode === "destroy" && !destroyOk) {
      log(state, "Spend failed: destroy target no longer legal.");
      return state;
    }
    spendTarget = { type:"badnik", name: b.name, mode: target.mode };
    if (target.mode === "destroy") {
      p.animalTokens += 1;
      log(state, `${p.name} DESTROYS Badnik "${b.name}" with ${spendLabel} -> gained 1 Animal Token (total ${p.animalTokens}).`);
    } else {
      log(state, `${p.name} AVOIDS Badnik "${b.name}" with ${spendLabel}.`);
    }
    p.badniks.splice(target.badnikIndex, 1);
    state.badnikDiscard.push(b);
  } else {
    return state;
  }

  // Remove die from pool
  p.dicePool = p.dicePool.filter(d => d.id !== die.id);
  p.selectedDieId = null;

  // Spending ends invulnerability window
  makeVulnerable(p);

  // Update counters for "since last reroll"
  p.spentSinceLastReroll += 1;

  if (ra.name === "Propeller Tail" && !p.hasRerolledThisTurn && p.spentSinceLastReroll >= 2 && !p.propellerTailBonusGivenSinceReroll) {
    const bonusDie = makeDie(DieColor.YELLOW, rollD6());
    p.dicePool.push(bonusDie);
    p.propellerTailBonusGivenSinceReroll = true;
    log(state, `Tails Propeller Tail (SPEND): spent>=2 after initial roll -> gained a YELLOW die (${bonusDie.value}).`);
  }

  // Core dice properties (from rulebook)
  const spentDie = useAmyRaise ? { ...die, value: effectiveDie.value } : die;

  if (spentDie.color === DieColor.YELLOW) {
    p.heldRings += 1;
    log(state, `Jump die property: +1 Ring (Held=${p.heldRings}).`);
  }

  if (useFlameShield) {
    p.oncePerTurn.flameShieldUsed = true;
    p.flameShieldArmed = false;
    log(state, `${p.name} Flame Shield: spent die treated as RED.`);
  }

  // Apply roll-action SPEND effect hooks
  if (typeof ra.onSpend === "function") {
    const spentDieForEffects = useFlameShield ? { ...spentDie, color: DieColor.RED } : spentDie;
    ra.onSpend({ state, p, spentDie: spentDieForEffects, spendTarget });
  }

  // Knuckles Glide chaining rule: if the action specifies a chain rule, set it up for potential extra spend.
  if (ra.onSpendChainRule && spentDie.color === ra.onSpendChainRule.color) {
    p.lastChainSpendRule = { ...ra.onSpendChainRule, lastSpentValue: spentDie.value };
  } else {
    p.lastChainSpendRule = null;
  }

  if (challengeReward) applyReward(state, challengeReward);
  if (completedRoute) completeZoneCard(state, completedRoute);
  if (state.ui?.discard?.open) {
    state.ui.discard.postSpend = { spentDieColor: spentDie.color };
    return state;
  }
  if (state.ui?.starPost?.open) {
    state.ui.starPost.postSpend = { spentDieColor: spentDie.color };
    return state;
  }
  if (state.phase === "END_TURN" || state.phase === "GAME_OVER") return state;
  return finalizePostSpend(state, spentDie, ra);
}

/* =======================
   Reroll step
   ======================= */
function rerollStep(state) {
  const p = getActivePlayer(state);
  const canRerollNow = state.phase === "REROLL" || (state.phase === "SPENDING" && p.spentSinceLastReroll > 0);
  if (!canRerollNow) return log(state, `Cannot reroll: phase=${state.phase}`);
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);
  if (!p.dicePool.length) { state.phase = "END_TURN"; return log(state, `No dice to reroll → End Turn`); }

  const ra = getRollActionCfg(p);
  p.hasRerolledThisTurn = true;

  // Apply REROLL effects at the beginning of the reroll step
  if (typeof ra.onRerollStepStart === "function") {
    ra.onRerollStepStart({ state, p });
  }

  // Reroll all remaining dice
  for (const d of p.dicePool) d.value = rollD6();
  log(state, `${p.name} rerolls Dice Pool: ${p.dicePool.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);

  // Reroll ends invulnerability
  makeVulnerable(p);

  // Badnik attacks: if any rerolled die matches an attack, take damage.
  if (p.badniks.length) {
    const hits = [];
    for (const b of p.badniks) {
      for (const atk of (b.attacks||[])) {
        const hit = atk.color
          ? p.dicePool.some(d => d.color === atk.color && d.value === atk.value)
          : p.dicePool.some(d => d.value === atk.value);
        if (hit) hits.push({ b, atk });
      }
    }
    if (hits.length) {
      log(state, `🟥 Badnik attack hits: ${hits.map(h=>`${h.b.name}(${h.atk.color ? h.atk.color[0].toUpperCase() : "ANY"}${h.atk.value})`).join(", ")}`);
      takeDamage(state, "Badnik attack");
      if (state.pendingDamage || state.phase !== "REROLL") return state;
    } else {
      log(state, `No Badnik attacks hit.`);
    }
  } else {
    log(state, `No Badniks in front of ${p.name}.`);
  }

  // Reset counters after a reroll happens
  p.spentSinceLastReroll = 0;
  p.propellerTailBonusGivenSinceReroll = false;
  p.lastChainSpendRule = null;

  state.phase = "SPENDING";
  return state;
}

function boostInReroll(state) {
  const p = getActivePlayer(state);
  if (state.phase !== "REROLL") return log(state, `Boost-in-reroll only usable in REROLL phase.`);
  if (p.boost <= 0) return log(state, `${p.name} has no Boost tokens.`);
  p.boost -= 1;
  log(state, `${p.name} spends 1 Boost → immediately reroll Dice Pool again.`);
  return rerollStep(state);
}

/* =======================
   End turn
   ======================= */
function endTurn(state) {
  const p = getActivePlayer(state);
  if (state.phase === "GAME_OVER") return state;
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);

  // If dice remain and player ends normally → discard + take time
  if (p.dicePool.length) {
    p.dicePool = [];
    p.selectedDieId = null;
    if (p.blueShieldLostThisTurn) {
      log(state, `${p.name} ends turn with dice remaining but avoids taking a Time Token (Blue Shield).`);
    } else {
      state.timeTokens -= 1;
      p.timeTokensTaken += 1;
      log(state, `${p.name} ends turn with dice remaining -> discard dice and take 1 Time Token (Time left: ${state.timeTokens}).`);
    }
  } else {
    log(state, `${p.name} ends turn.`);
  }

  makeVulnerable(p);
  p.spentSinceLastReroll = 0;
  p.lastChainSpendRule = null;
  p.invincibleTokens = 0;
  p.flameShieldArmed = false;
  p.lightningShieldArmed = false;
  p.blueShieldLostThisTurn = false;
  state.pendingDamage = null;

  const over = isGameOver(state);
  if (over) {
    state.phase = "GAME_OVER";
    log(state, `🛑 GAME OVER: ${over}`);
    return state;
  }

  state.activePlayer = (state.activePlayer + 1) % state.players.length;
  const np = getActivePlayer(state);
  np.oncePerTurn = {};
  np.rollActionSelectedThisTurn = false;
  state.phase = "ROLL_ACTION";
  log(state, `➡️ Turn passes to ${np.name} (${np.character}).`);
  return state;
}

/* =======================
   UI
   ======================= */
let STATE = null;

function escapeHtml(str) {
  return str.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}

function buildRollActionDiceHint(diceSpec) {
  if (!diceSpec) return "none";
  const order = [
    { key: "blue", emoji: "🟦" },
    { key: "red", emoji: "🟥" },
    { key: "yellow", emoji: "🟨" }
  ];
  let out = "";
  for (const item of order) {
    const count = diceSpec[item.key] || 0;
    if (count > 0) out += item.emoji.repeat(count);
  }
  return out || "none";
}

function getBadnikDisplayLabels(b) {
  const attacksLabel = (b.attacks || [])
    .map(a => `${a.color ? a.color[0].toUpperCase() : "ANY"}${a.value ?? ""}`)
    .join(", ") || "none";
  const avoidLabel = b.avoid
    ? `${b.avoid.color ? b.avoid.color[0].toUpperCase() : "ANY"}${b.avoid.value ?? ""}`
    : "none";
  const destroyColor = b.destroy?.color ? b.destroy.color[0].toUpperCase() : "R";
  const destroyLabel = b.destroy ? `${destroyColor}${b.destroy.value ?? ""}` : "none";
  return { attacksLabel, avoidLabel, destroyLabel };
}

function getTimeBonusPoints(playerCount, place) {
  const table = {
    2: { 1: 100, 2: 0 },
    3: { 1: 150, 2: 50, 3: 0 },
    4: { 1: 200, 2: 100, 3: 50, 4: 0 }
  };
  return table[playerCount]?.[place] ?? 0;
}

function getSoloTimePoints(timeTokensTaken) {
  if (timeTokensTaken <= 0) return 200;
  if (timeTokensTaken <= 2) return 100;
  if (timeTokensTaken <= 4) return 50;
  return 0;
}

function getRingPoints(p) {
  const heldValue = p.hyperRing ? 15 : 10;
  return (p.heldRings * heldValue) + (p.savedRings * 10);
}

function getAnimalPoints(p) {
  return p.animalTokens * 20;
}

function getLifeLossPoints(p) {
  const startingLives = 3;
  const lost = Math.max(0, startingLives - p.lives);
  return lost * -30;
}

function getChaosEmeraldPoints(p) {
  return (p.chaosEmeraldsReady * 50) + (p.chaosEmeraldsSpent * 20);
}

function computeTimeScores(state) {
  const entries = state.players.map(p => ({
    id: p.id,
    name: p.name,
    character: p.character,
    speed: (p.zoneCardsCompleted * 3) - p.timeTokensTaken
  }));

  if (entries.length <= 1) {
    return entries.map(e => ({
      ...e,
      place: null,
      points: getSoloTimePoints(state.players[0]?.timeTokensTaken ?? 0)
    }));
  }

  entries.sort((a, b) => b.speed - a.speed);
  let rank = 1;
  let i = 0;
  while (i < entries.length) {
    let j = i + 1;
    while (j < entries.length && entries[j].speed === entries[i].speed) j++;
    const groupSize = j - i;
    const assignedPlace = rank + groupSize - 1;
    const points = getTimeBonusPoints(entries.length, assignedPlace);
    for (let k = i; k < j; k++) {
      entries[k].place = assignedPlace;
      entries[k].points = points;
    }
    rank += groupSize;
    i = j;
  }
  return entries;
}

function computeScoreSummary(state) {
  const timeScores = computeTimeScores(state);
  const timeById = new Map(timeScores.map(entry => [entry.id, entry]));
  return state.players.map(p => {
    const timeEntry = timeById.get(p.id);
    const ringPoints = getRingPoints(p);
    const animalPoints = getAnimalPoints(p);
    const lifePoints = getLifeLossPoints(p);
    const chaosPoints = getChaosEmeraldPoints(p);
    const timePoints = timeEntry?.points ?? 0;
    return {
      id: p.id,
      name: p.name,
      character: p.character,
      speed: timeEntry?.speed ?? null,
      place: timeEntry?.place ?? null,
      timePoints,
      ringPoints,
      animalPoints,
      lifePoints,
      chaosPoints,
      totalPoints: timePoints + ringPoints + animalPoints + lifePoints + chaosPoints
    };
  });
}

function render() {
  const s = STATE;
  if (!s) return;

  const p = getActivePlayer(s);
  const ra = getRollActionCfg(p);

  const controlsCard = document.getElementById("controlsCard");
  if (controlsCard) controlsCard.dataset.character = p.character;
  const characterHeading = document.getElementById("characterHeading");
  if (characterHeading) {
    const label = `${p.name} — ${p.character}`;
    characterHeading.innerHTML = `
      <span>${escapeHtml(label)}</span>
      <span class="badge badge-tight">Lives ${p.lives} | Boost ${p.boost} | Held ${p.heldRings} | Saved ${p.savedRings} | Animals ${p.animalTokens} | Time Taken ${p.timeTokensTaken} | Chaos Ready ${p.chaosEmeraldsReady} | Chaos Spent ${p.chaosEmeraldsSpent}</span>
    `;
  }

  if (s.ui?.spend?.open) {
    const hasDie = p.dicePool.some(d => d.id === s.ui.spend.dieId);
    if (s.phase !== "SPENDING" || !hasDie) clearSpendUi(s);
  }
  if (s.ui?.discard?.open) {
    if (s.phase !== "SPENDING" || p.dicePool.length < 2) clearDiscardUi(s);
  }
  if (s.ui?.starPost?.open) {
    if (p.heldRings <= 0) clearStarPostUi(s);
  }
  if (s.pendingPowerUp || s.pendingDamage || s.pendingBadnikReward) {
    clearSpendUi(s);
  }

  document.getElementById("phase").textContent = s.phase;
  document.getElementById("activePlayer").textContent =
    `${p.name} (${p.character}) | Lives=${p.lives} | Boost=${p.boost} | HeldRings=${p.heldRings} | SavedRings=${p.savedRings} | Animals=${p.animalTokens} | ChaosReady=${p.chaosEmeraldsReady} | ChaosSpent=${p.chaosEmeraldsSpent} | ZoneCards=${p.zoneCardsCompleted} | Badniks=${p.badniks.length} | TimeTaken=${p.timeTokensTaken}`;

  document.getElementById("invuln").textContent = p.invulnerable ? "YES" : "NO";

  const counters = document.getElementById("counters");
  counters.innerHTML = `
    <div class="pill tiny"><b>spentSinceLastReroll</b> ${p.spentSinceLastReroll}</div>
    <div class="pill tiny"><b>Roll Action</b> ${escapeHtml(ra.name)}</div>
    ${p.lastChainSpendRule ? `<div class="pill tiny warn"><b>Chain rule</b> ${p.lastChainSpendRule.color.toUpperCase()} must be lower than ${p.lastChainSpendRule.lastSpentValue}</div>` : ""}
  `;

  const powerStatus = document.getElementById("powerUpStatus");
  if (powerStatus) {
    powerStatus.innerHTML = `
      <div class="pill tiny"><b>Shield</b> ${p.shield ? getShieldLabel(p.shield.type) : "None"}</div>
      <div class="pill tiny"><b>Hyper Ring</b> ${p.hyperRing ? "ON" : "OFF"}</div>
      <div class="pill tiny"><b>Invincible</b> ${p.invincibleTokens}</div>
      ${p.flameShieldArmed ? `<div class="pill tiny warn"><b>Flame Armed</b> yes</div>` : ""}
      ${p.lightningShieldArmed ? `<div class="pill tiny warn"><b>Lightning Armed</b> yes</div>` : ""}
    `;
  }

  const powerPanel = document.getElementById("powerUpPanel");
  if (powerPanel) {
    if (s.pendingDamage) {
      powerPanel.innerHTML = `
        <div class="pill tiny warn"><b>Invincible</b> Discard a die to ignore damage.</div>
        <div id="invincibleDice"></div>
        <div class="row">
          <button id="invincibleConfirm">Discard Selected Die</button>
          <button id="invincibleDecline">Take Damage</button>
        </div>
      `;
      const diceWrap = powerPanel.querySelector("#invincibleDice");
      for (const d of p.dicePool) {
        const el = document.createElement("div");
        el.className = `die ${d.color}` + (s.pendingDamage.selectedDieId === d.id ? " selected" : "");
        el.textContent = d.value;
        el.title = d.color;
        el.addEventListener("click", () => {
          s.pendingDamage.selectedDieId = d.id;
          render();
        });
        diceWrap.appendChild(el);
      }
      const confirmBtn = powerPanel.querySelector("#invincibleConfirm");
      confirmBtn.disabled = !s.pendingDamage.selectedDieId;
      confirmBtn.addEventListener("click", () => {
        confirmInvincibleDiscard(STATE);
        render();
      });
      powerPanel.querySelector("#invincibleDecline").addEventListener("click", () => {
        declineInvincible(STATE);
        render();
      });
    } else if (s.pendingPowerUp) {
      if (s.pendingPowerUp.kind === "eggman_mark") {
        powerPanel.innerHTML = `
          <div class="pill tiny warn"><b>Eggman Mark</b> Choose a player to receive a Badnik.</div>
          <div id="eggmanTargets" class="row"></div>
        `;
        const targetWrap = powerPanel.querySelector("#eggmanTargets");
        for (const pl of s.players) {
          const btn = document.createElement("button");
          btn.textContent = `${pl.name} (${pl.character})`;
          btn.addEventListener("click", () => {
            resolveEggmanMark(STATE, pl.id);
            render();
          });
          targetWrap.appendChild(btn);
        }
      } else if (s.pendingPowerUp.kind === "one_up") {
        powerPanel.innerHTML = `
          <div class="pill tiny warn"><b>1-Up</b> Choose a die color to add.</div>
          <div class="row">
            <button id="oneUpBlue">Blue Die</button>
            <button id="oneUpYellow">Yellow Die</button>
            <button id="oneUpRed">Red Die</button>
          </div>
        `;
        powerPanel.querySelector("#oneUpBlue").addEventListener("click", () => {
          resolveOneUp(STATE, DieColor.BLUE);
          render();
        });
        powerPanel.querySelector("#oneUpYellow").addEventListener("click", () => {
          resolveOneUp(STATE, DieColor.YELLOW);
          render();
        });
        powerPanel.querySelector("#oneUpRed").addEventListener("click", () => {
          resolveOneUp(STATE, DieColor.RED);
          render();
        });
      } else if (s.pendingPowerUp.kind === "shield_swap") {
        const pendingShield = s.pendingPowerUp.newShield;
        powerPanel.innerHTML = `
          <div class="pill tiny warn"><b>Shield Choice</b> Keep current or swap.</div>
          <div class="tiny">Current: ${p.shield ? getShieldLabel(p.shield.type) : "None"}</div>
          <div class="tiny">New: ${getShieldLabel(pendingShield)}</div>
          <div class="row">
            <button id="shieldKeepBtn">Keep Current</button>
            <button id="shieldSwapBtn">Take New</button>
          </div>
        `;
        powerPanel.querySelector("#shieldKeepBtn").addEventListener("click", () => {
          resolveShieldSwap(STATE, true);
          render();
        });
        powerPanel.querySelector("#shieldSwapBtn").addEventListener("click", () => {
          resolveShieldSwap(STATE, false);
          render();
        });
      }
    } else if (s.pendingBadnikReward) {
      const eligible = getEligibleBadnikTargets(s);
      powerPanel.innerHTML = `
        <div class="pill tiny warn"><b>Badnik Reward</b> Choose a player to draw a Badnik.</div>
        <div class="tiny">Remaining selections: ${s.pendingBadnikReward.remaining}</div>
        <div id="badnikRewardTargets" class="row"></div>
      `;
      const targetWrap = powerPanel.querySelector("#badnikRewardTargets");
      for (const pl of eligible) {
        const btn = document.createElement("button");
        btn.textContent = `${pl.name} (${pl.character})`;
        btn.addEventListener("click", () => {
          resolveBadnikRewardChoice(STATE, pl.id);
          render();
        });
        targetWrap.appendChild(btn);
      }
    } else {
      powerPanel.innerHTML = "";
      const actions = [];
      if (p.shield && p.shield.type === "flame") {
        actions.push(`<button id="flameShieldBtn">${p.flameShieldArmed ? "Flame Shield Armed" : "Use Flame Shield"}</button>`);
      }
      if (p.shield && p.shield.type === "bubble") {
        actions.push(`<button id="bubbleShieldBtn">Bubble Shield: Reroll Selected Die</button>`);
      }
      if (p.shield && p.shield.type === "lightning") {
        actions.push(`<button id="lightningShieldBtn">${p.lightningShieldArmed ? "Lightning Armed" : "Arm Lightning Shield"}</button>`);
      }
      if (actions.length) {
        powerPanel.innerHTML = `<div class="row">${actions.join("")}</div>`;
      } else {
        powerPanel.innerHTML = `<div class="muted">No pending Power Ups.</div>`;
      }

      const flameBtn = powerPanel.querySelector("#flameShieldBtn");
      if (flameBtn) {
        flameBtn.disabled = s.phase !== "SPENDING" || p.oncePerTurn.flameShieldUsed;
        flameBtn.addEventListener("click", () => {
          p.flameShieldArmed = !p.flameShieldArmed;
          log(s, `${p.name} ${p.flameShieldArmed ? "arms" : "disarms"} Flame Shield for the next spend.`);
          render();
        });
      }

      const bubbleBtn = powerPanel.querySelector("#bubbleShieldBtn");
      if (bubbleBtn) {
        bubbleBtn.disabled = p.oncePerTurn.bubbleShieldUsed || p.dicePool.length === 0;
        bubbleBtn.addEventListener("click", () => {
          const target = p.dicePool.find(d => d.id === p.selectedDieId) || (p.dicePool.length === 1 ? p.dicePool[0] : null);
          if (!target) {
            log(s, `${p.name} Bubble Shield: select a die to reroll.`);
            return;
          }
          const newValue = rollD6();
          target.value = newValue;
          p.oncePerTurn.bubbleShieldUsed = true;
          log(s, `${p.name} Bubble Shield rerolls ${target.color.toUpperCase()}-${newValue}.`);
          render();
        });
      }

      const lightningBtn = powerPanel.querySelector("#lightningShieldBtn");
      if (lightningBtn) {
        lightningBtn.disabled = p.oncePerTurn.lightningShieldUsed || p.lightningShieldArmed;
        lightningBtn.addEventListener("click", () => {
          p.lightningShieldArmed = true;
          log(s, `${p.name} arms Lightning Shield to change the next reward to rings x2.`);
          render();
        });
      }
    }
  }

  // Buttons
  const dis = (id, v) => document.getElementById(id).disabled = !!v;
  const discardOpen = !!s.ui?.discard?.open;
  const starPostOpen = !!s.ui?.starPost?.open;
  const powerOpen = !!s.pendingPowerUp;
  const damageOpen = !!s.pendingDamage;
  const badnikRewardOpen = !!s.pendingBadnikReward;
  const actionBlocked = discardOpen || starPostOpen || powerOpen || damageOpen || badnikRewardOpen;
  dis("btnBuildPool", s.phase !== "ROLL_ACTION" || actionBlocked || !p.rollActionSelectedThisTurn);
  dis("btnSpendDie", s.phase !== "SPENDING" || !p.dicePool.length || actionBlocked);
  const canOptionalReroll = s.phase === "SPENDING" && p.spentSinceLastReroll > 0 && p.dicePool.length > 0;
  dis("btnRerollStep", !(s.phase === "REROLL" || canOptionalReroll) || actionBlocked);
  const canUseBoost =
    (s.phase === "SPENDING" && p.boost > 0 && p.dicePool.length > 0);
  dis("btnUseBoostToken", !canUseBoost || actionBlocked);
  dis("btnEndTurn", !(s.phase==="SPENDING" || s.phase==="REROLL" || s.phase==="END_TURN") || actionBlocked);

  // Roll action buttons
  const raWrap = document.getElementById("rollActionButtons");
  raWrap.innerHTML = "";
  for (const a of getCharCfg(p).rollActions) {
    const btn = document.createElement("button");
    const hint = buildRollActionDiceHint(a.dice);
    btn.className = `roll-action-btn ${p.rollActionSelectedThisTurn && p.chosenRollAction === a.name ? "active" : ""}`;
    btn.innerHTML = `
      <div class="roll-action-icon">${hint === "none" ? "" : hint}</div>
      <div>${escapeHtml(a.name)}</div>
    `;
    btn.disabled = s.phase !== "ROLL_ACTION" || actionBlocked;
    btn.addEventListener("click", () => {
      p.chosenRollAction = a.name;
      p.rollActionSelectedThisTurn = true;
      log(s, `${p.name} set Roll Action to: ${p.chosenRollAction}`);
      render();
    });
    raWrap.appendChild(btn);
  }
  // Dice pool
  const dp = document.getElementById("dicePool");
  dp.innerHTML = "";
  const discardUi = s.ui?.discard;
  const selectedDieId = discardUi?.open ? discardUi.selectedDieId : p.selectedDieId;
  for (const d of p.dicePool) {
    const el = document.createElement("div");
    el.className = `die ${d.color}`;
    el.textContent = d.value;
    el.title = d.color;
    el.style.opacity = (selectedDieId === d.id) ? "1" : "0.82";
    el.style.transform = (selectedDieId === d.id) ? "scale(1.05)" : "scale(1)";
    el.addEventListener("click", () => {
      if (damageOpen || powerOpen || badnikRewardOpen) return;
      if (discardUi?.open) {
        discardUi.selectedDieId = d.id;
      } else {
        p.selectedDieId = d.id;
      }
      render();
    });
    dp.appendChild(el);
  }

  // Discard panel
  const discardSection = document.getElementById("discardSection");
  const discardPanel = document.getElementById("discardPanel");
  if (discardPanel) {
    if (!discardUi || !discardUi.open) {
      if (discardSection) discardSection.style.display = "none";
      discardPanel.textContent = "";
    } else {
      if (discardSection) discardSection.style.display = "";
      const selected = p.dicePool.find(d => d.id === discardUi.selectedDieId);
      const label = selected ? `${selected.color.toUpperCase()}-${selected.value}` : "Select a die to discard.";
      discardPanel.innerHTML = `
        <div class="pill tiny">Discard: ${label}</div>
        <div class="row target-actions">
          <button id="btnConfirmDiscard">Discard Selected Die</button>
        </div>
      `;
      const btn = discardPanel.querySelector("#btnConfirmDiscard");
      if (btn) {
        btn.disabled = !selected;
        btn.addEventListener("click", () => { confirmDiscardSelection(STATE); render(); });
      }
    }
  }

  // Star Post panel
  const starPostSection = document.getElementById("starPostSection");
  const starPostPanel = document.getElementById("starPostPanel");
  const starUi = s.ui?.starPost;
  if (starPostPanel) {
    if (!starUi || !starUi.open) {
      if (starPostSection) starPostSection.style.display = "none";
      starPostPanel.textContent = "";
    } else {
      if (starPostSection) starPostSection.style.display = "";
      starPostPanel.innerHTML = `
        <div class="pill tiny">Held Rings: ${p.heldRings}</div>
        <div class="row target-actions">
          <button id="btnStarPostSave">Save All Rings</button>
          <button id="btnStarPostKeep">Keep Held Rings</button>
        </div>
      `;
      const btnSave = starPostPanel.querySelector("#btnStarPostSave");
      const btnKeep = starPostPanel.querySelector("#btnStarPostKeep");
      if (btnSave) btnSave.addEventListener("click", () => { confirmStarPostSave(STATE); render(); });
      if (btnKeep) btnKeep.addEventListener("click", () => { confirmStarPostKeep(STATE); render(); });
    }
  }

  // Spend target selection
  const spendPanel = document.getElementById("spendTargetPanel");
  const spendUi = s.ui?.spend;
  if (!spendUi || !spendUi.open) {
    spendPanel.textContent = `Select a die and click "Spend Selected Die" to choose a target. Tip: click a Zone/Badnik card to preselect.`;
  } else {
    const die = p.dicePool.find(d => d.id === spendUi.dieId);
    const dieLabel = die ? `${die.color.toUpperCase()}-${die.value}` : "Unknown";
    const canAmyRaise = p.character === "Amy" && die && die.color === DieColor.RED;
    spendPanel.innerHTML = `
      <div class="pill tiny">Die: ${dieLabel}</div>
      ${canAmyRaise ? `<div class="row target-actions">
        <button id="btnAmyRaise">${spendUi.amyRaise ? "Piko Piko Hammer (+1) ON" : "Use Piko Piko Hammer (+1)"}</button>
      </div>` : ""}
      <div class="target-list"></div>
      <div class="row target-actions">
        <button id="btnConfirmSpend">Confirm Spend</button>
        <button id="btnCancelSpend">Cancel</button>
      </div>
    `;
    if (canAmyRaise) {
      const btnAmy = spendPanel.querySelector("#btnAmyRaise");
      btnAmy.addEventListener("click", () => {
        spendUi.amyRaise = !spendUi.amyRaise;
        const ok = refreshSpendTargets(STATE, die);
        if (!ok) {
          log(s, "No legal spend targets with Piko Piko Hammer.");
        }
        render();
      });
    }
    const list = spendPanel.querySelector(".target-list");
    for (const t of spendUi.targets) {
      const item = document.createElement("div");
      item.className = `target-item ${t.id === spendUi.selectedTargetId ? "selected" : ""}`;
      item.textContent = t.label;
      item.addEventListener("click", () => { spendUi.selectedTargetId = t.id; render(); });
      list.appendChild(item);
    }
    const btnConfirm = spendPanel.querySelector("#btnConfirmSpend");
    const btnCancel = spendPanel.querySelector("#btnCancelSpend");
    if (btnConfirm) {
      btnConfirm.disabled = !die || !spendUi.selectedTargetId;
      btnConfirm.addEventListener("click", () => { confirmSpendSelection(STATE); render(); });
    }
    if (btnCancel) {
      btnCancel.addEventListener("click", () => { cancelSpendSelection(STATE); render(); });
    }
  }

  // Zone view
  const zv = document.getElementById("zoneView");
  zv.innerHTML = "";
  for (const route of s.zone.routes) {
    const cardData = route.activeCard;
    const next = cardData?.challenges.find(x=>!x.cleared);
    const card = document.createElement("div");
    card.className = `card ${next ? "clickable" : ""}`;
    const nextHtml = cardData
      ? (next
          ? `${formatChallengeChip(next, cardData)}
             <span class="muted">Reward:</span> <span class="pill">${formatRewardLabel(next.reward)}</span>`
          : `<span class="ok">Completed</span>`)
      : `<span class="muted">No Zone Card</span>`;
    const trackHtml = cardData
      ? `<div class="track-list">
          ${cardData.challenges.map(ch => {
            const req = formatChallengeChip(ch, cardData);
            const reward = formatRewardLabel(ch.reward);
            return `<div class="track-item ${ch.cleared ? "cleared" : ""}">
              <div class="track-label">${req}</div>
              <div class="track-reward">${reward}</div>
            </div>`;
          }).join("")}
        </div>`
      : `<div class="tiny muted">No active card.</div>`;
    card.innerHTML = `
      <h2>${route.name} Route</h2>
      <div class="tiny">
        Act Board reward: <span class="pill">${formatRewardLabel(getActBoardReward(s, route.name))}</span>
      </div>
      <div class="tiny" style="margin-top:6px;">
        Next: ${nextHtml}
      </div>
      ${trackHtml}
    `;
    if (next) {
      card.title = "Click to preselect spend target";
      card.addEventListener("click", () => {
        preselectSpendTarget(STATE, { type:"zone", routeId: route.id, challengeId: next.id });
        render();
      });
    }
    zv.appendChild(card);
  }

  // Badniks
  const bv = document.getElementById("badnikView");
  bv.innerHTML = "";
  if (!p.badniks.length) {
    bv.innerHTML = `<div class="tiny muted">No Badniks.</div>`;
  } else {
    for (let i = 0; i < p.badniks.length; i++) {
      const b = p.badniks[i];
      const labels = getBadnikDisplayLabels(b);
      const el = document.createElement("div");
      el.className = "pill tiny clickable";
      el.innerHTML = `<b>${escapeHtml(b.name)}</b>
        <span class="muted">attacks:</span> ${labels.attacksLabel}
        <span class="muted">avoid:</span> ${labels.avoidLabel}
        <span class="muted">destroy:</span> ${labels.destroyLabel}`;
      el.title = "Click to preselect spend target";
      el.addEventListener("click", () => {
        preselectSpendTarget(STATE, { type:"badnik", badnikIndex: i });
        render();
      });
      bv.appendChild(el);
    }
  }

  // Log
  const logEl = document.getElementById("log");
  logEl.innerHTML = s.log.slice(-400).map(line => `<div>${escapeHtml(line)}</div>`).join("");
  logEl.scrollTop = logEl.scrollHeight;

  // Discards
  const powerDiscardEl = document.getElementById("powerUpDiscardView");
  if (powerDiscardEl) {
    const discards = s.powerUpDiscard || [];
    powerDiscardEl.textContent = discards.length
      ? discards.map(id => getPowerUpLabel(id)).join(", ")
      : "No discarded Power Ups.";
  }
  const badnikDiscardEl = document.getElementById("badnikDiscardView");
  if (badnikDiscardEl) {
    const discards = s.badnikDiscard || [];
    badnikDiscardEl.innerHTML = discards.length
      ? discards.map(b => {
          const labels = getBadnikDisplayLabels(b);
          return `<div class="pill tiny"><b>${escapeHtml(b.name)}</b>
            <span class="muted">attacks:</span> ${labels.attacksLabel}
            <span class="muted">avoid:</span> ${labels.avoidLabel}
            <span class="muted">defeat:</span> ${labels.destroyLabel}</div>`;
        }).join("")
      : `<div class="tiny muted">No discarded Badniks.</div>`;
  }

  const timeScoreEl = document.getElementById("timeScoringView");
  if (timeScoreEl) {
    if (s.players.length <= 1) {
      const solo = computeTimeScores(s)[0];
      const summary = computeScoreSummary(s)[0];
      timeScoreEl.innerHTML = `
        <div class="muted">Solo time scoring by Time Tokens taken.</div>
        <div class="pill tiny">
          <b>${escapeHtml(solo.name)} (${escapeHtml(solo.character)})</b>
          Time Taken ${s.players[0].timeTokensTaken} | Time Points ${solo.points}
        </div>
        <div class="pill tiny">Rings Points ${summary.ringPoints} | Animal Points ${summary.animalPoints} | Chaos ${summary.chaosPoints} | Life Loss ${summary.lifePoints} | Total ${summary.totalPoints}</div>
      `;
    } else {
      const scores = computeTimeScores(s);
      const summary = computeScoreSummary(s);
      timeScoreEl.innerHTML = `
        <div class="muted">Speed = (Zone Cards x3) - (Time Tokens taken)</div>
        ${scores.map(entry => {
          const extra = summary.find(sx => sx.id === entry.id);
          return `
          <div class="pill tiny">
            <b>${escapeHtml(entry.name)} (${escapeHtml(entry.character)})</b>
            Speed ${entry.speed} | Place ${entry.place} | Time Points ${entry.points}
            | Rings ${extra?.ringPoints ?? 0} | Animals ${extra?.animalPoints ?? 0} | Chaos ${extra?.chaosPoints ?? 0} | Life ${extra?.lifePoints ?? 0} | Total ${extra?.totalPoints ?? entry.points}
          </div>
        `;
        }).join("")}
      `;
    }
  }
}

/* =======================
   UI events
   ======================= */
function openNewGameModal() {
  const modal = document.getElementById("newGameModal");
  if (modal) modal.classList.add("open");
}

function closeNewGameModal() {
  const modal = document.getElementById("newGameModal");
  if (modal) modal.classList.remove("open");
}

function generateSeed() {
  return Math.floor(Math.random() * 1000000000).toString();
}

function ensureSeedValue() {
  const seedInput = document.getElementById("seed");
  if (!seedInput) return generateSeed();
  if (!seedInput.value.trim()) seedInput.value = generateSeed();
  return seedInput.value;
}

function startNewGame({ closeModal = false } = {}) {
  const playerCount = parseInt(document.getElementById("playerCount").value, 10);
  const seedStr = ensureSeedValue();
  const characterSelections = readCharacterSelections(playerCount);
  STATE = newGame({ playerCount, seedStr, characterSelections });
  if (closeModal) closeNewGameModal();
  render();
}

const menuWrapper = document.getElementById("menuWrapper");
const menuBtn = document.getElementById("menuBtn");
const menuDropdown = document.getElementById("menuDropdown");
const menuNewGame = document.getElementById("menuNewGame");
if (menuBtn && menuDropdown) {
  menuBtn.addEventListener("click", (event) => {
    event.stopPropagation();
    menuDropdown.classList.toggle("open");
  });
}
if (menuNewGame) {
  menuNewGame.addEventListener("click", () => {
    menuDropdown?.classList.remove("open");
    renderCharacterSelectors();
    openNewGameModal();
  });
}
document.addEventListener("click", (event) => {
  if (!menuWrapper) return;
  if (!menuWrapper.contains(event.target)) {
    menuDropdown?.classList.remove("open");
  }
});

const confirmNewGameBtn = document.getElementById("confirmNewGameBtn");
if (confirmNewGameBtn) {
  confirmNewGameBtn.addEventListener("click", () => {
    startNewGame({ closeModal: true });
  });
}

const cancelNewGameBtn = document.getElementById("cancelNewGameBtn");
if (cancelNewGameBtn) {
  cancelNewGameBtn.addEventListener("click", () => {
    closeNewGameModal();
  });
}

document.getElementById("playerCount").addEventListener("change", () => {
  renderCharacterSelectors();
});

document.getElementById("btnBuildPool").addEventListener("click", () => {
  buildDicePool(STATE);
  render();
});

document.getElementById("btnUseBoostToken").addEventListener("click", () => {
  if (STATE?.phase === "REROLL") {
    boostInReroll(STATE);
  } else {
    boostAfterRollAction(STATE);
  }
  render();
});

document.getElementById("btnSpendDie").addEventListener("click", () => {
  spendSelectedDie(STATE);
  render();
});

document.getElementById("btnRerollStep").addEventListener("click", () => {
  rerollStep(STATE);
  render();
});

document.getElementById("btnEndTurn").addEventListener("click", () => {
  endTurn(STATE);
  render();
});

// Auto-start
renderCharacterSelectors();
ensureSeedValue();
startNewGame();
</script>
</body>
</html>
