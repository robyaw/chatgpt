<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sonic Roll – Rules Engine (Dashboards Implemented)</title>
  <style>
    :root { font-family: Jost, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body {
      margin: 16px;
      color:#e8ecff;
      background: linear-gradient(45deg, #8fbfe8 25%, transparent 25%, transparent 75%, #8fbfe8 75%, #8fbfe8),
                  linear-gradient(45deg, #8fbfe8 25%, transparent 25%, transparent 75%, #8fbfe8 75%, #8fbfe8);
      background-size: 120px 120px;
      background-position: 0 0, 60px 60px;
      background-color: #9fc7ea;
    }
    h1,h2 { margin: 8px 0; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    .card { background:#121a33; border:1px solid #23305a; border-radius:14px; padding:12px; box-shadow: 0 8px 25px rgba(0,0,0,.25); }
    .card h2 { font-size: 14px; letter-spacing:.04em; text-transform:uppercase; color:#b8c6ff; }
    .controls-card { background:#121a33; border-color:#23305a; }
    .controls-card[data-character="Sonic"] { background:#0f2347; border-color:#2a4f96; }
    .controls-card[data-character="Tails"] { background:#3a220f; border-color:#8b5b2a; }
    .controls-card[data-character="Knuckles"] { background:#3a0f12; border-color:#8a2a2a; }
    .controls-card[data-character="Amy"] { background:#351126; border-color:#7a2d53; }
    .character-heading { display:flex; align-items:center; gap:8px; flex-wrap:wrap; font-size:18px; font-weight:700; margin:0 0 6px; color:#e8ecff; }
    .badge-tight { padding:2px 6px; font-size:11px; }
    button, select, input { background:#1a2550; border:1px solid #2d3b73; color:#e8ecff; padding:8px 10px; border-radius:10px; cursor:pointer; }
    button:hover { filter:brightness(1.1); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { display:inline-flex; gap:8px; padding:6px 10px; border:1px solid #2d3b73; border-radius:999px; background:#0f1733; margin:4px 4px 0 0; align-items:center; }
    .muted { color:#b0b8e8; }
    .log { max-height: 300px; overflow:auto; font-size: 13px; line-height:1.35; }
    .grid { display:grid; grid-template-columns: minmax(240px, 1fr); gap:10px; }
    .tiny { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .badge { font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #2d3b73; background:#0f1733; }
    .roll-action-btn { padding:8px 10px; border-radius:10px; border:1px solid #2d3b73; background:#0f1733; color:#e8ecff; cursor:pointer; display:flex; flex-direction:column; align-items:center; gap:4px; min-width:90px; }
    .roll-action-icon { display:flex; align-items:center; justify-content:center; gap:2px; min-height:18px; }
    .roll-action-icon .dice-hint-icon { width:16px; height:16px; display:block; }
    .roll-action-btn.active { border-color:#7cb6ff; box-shadow: 0 0 0 2px rgba(124,182,255,.35); background:#15234a; }
    .die {
      width: 44px; height: 44px; border-radius:10px; display:inline-flex; align-items:center; justify-content:center;
      margin:4px; font-weight:700; border:1px solid transparent; background:#0f1733; color:#f7f9ff;
      user-select:none; opacity:.82; transform:scale(1);
    }
    .die.blue { background:#2f7cff; border-color:#2f7cff; outline:2px solid #2f7cff; }
    .die.yellow { background:#e7c240; border-color:#e7c240; color:#f7f9ff; outline:2px solid #e7c240; }
    .die.red { background:#ff3b30; border-color:#ff3b30; outline:2px solid #ff3b30; }
    .die.buddy-flight { background:#f0b44b; border-color:#f0b44b; color:#2a1a00; outline:2px solid #f0b44b; }
    .die.black { background:#2d2d2d; border-color:#2d2d2d; outline:2px solid #2d2d2d; }
    .pip-grid {
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      width:100%;
      height:100%;
    }
    .pip {
      width:11px;
      height:11px;
      border-radius:50%;
      background:currentColor;
      opacity:0;
      justify-self:center;
      align-self:center;
    }
    .pip.on { opacity:1; }
    .die.selected { box-shadow: 0 0 0 2px #b8c6ff; opacity:1; transform:scale(1.05); }
    .die.disabled { opacity:.35; cursor:not-allowed; }
    textarea { width:100%; min-height:120px; border-radius:10px; background:#0f1733; border:1px solid #2d3b73; color:#e8ecff; padding:10px; }
    .hr { height:1px; background:#23305a; margin:10px 0; }
    .ok { color:#b8ffcf; }
    .warn { color:#ffe7a6; }
    .clickable { cursor:pointer; }
    .clickable:hover { filter:brightness(1.08); }
    .target-list { display:flex; flex-direction:column; gap:6px; margin-top:6px; }
    .target-item { padding:6px 8px; border:1px solid #2d3b73; border-radius:10px; background:#0f1733; cursor:pointer; }
    .target-item.selected { outline:2px solid rgba(120,200,255,.6); background:#15234a; }
    .target-actions { margin-top:8px; }
    .track-list { display:flex; flex-wrap:wrap; gap:4px; margin-top:6px; }
    .track-list-even {
      justify-content:space-between;
      gap:0;
      width:100%;
      flex-wrap:nowrap;
    }
    .track-item {
      border:1px solid #2d3b73;
      border-radius:10px;
      background:#0f1733;
      padding:4px 6px;
      font-size:13px;
      display:flex;
      flex-direction:column;
      justify-content:flex-start;
    }
    .track-item.cleared { opacity:.55; text-decoration: line-through; }
    .track-label { font-weight:600; font-size:14px; }
    .track-reward { color:#b0b8e8; font-size:12px; }
    .track-reward .act-reward-circle {
      width:46px;
      height:46px;
      border-width:2px;
      --reward-border: 2px;
      --reward-gap: 1px;
    }
    .track-reward .reward-inner-mask {
      padding-top: 10%;
      box-sizing: border-box;
    }
    .track-reward .reward-inner-mask .reward-star-post {
      width:31%;
    }
    .track-reward .act-reward-circle img {
      width:24px;
      height:24px;
    }
    .track-reward .act-reward-circle img.reward-star-post {
      width:31%;
      height:auto;
    }
    .track-reward .act-reward-tag {
      font-size:7px;
      padding:1px 4px;
    }
    .track-reward .act-reward-text {
      font-size:8px;
    }
    .req-chip { display:inline-flex; align-items:center; justify-content:center; width:46px; height:46px; padding:0; border-radius:8px; border:1px solid #2d3b73; background:#d7dbe6; color:#111; font-weight:700; letter-spacing:.02em; }
    .req-chip img { width:28px; height:28px; display:block; }
    .req-chip.req-blue { background:#5aa3ff; color:#0b1020; }
    .req-chip.req-yellow { background:#ffd756; color:#3a2a00; }
    .req-chip.req-red { background:#ff6a6a; color:#2a0b0b; }
    .req-chip.req-any { background:#d7dbe6; color:#111; }
    .req-number { font-size:1.15em; }
    .player-setup { display:flex; flex-direction:column; gap:6px; }
    .player-setup-row { display:flex; align-items:center; gap:8px; }
    .player-setup-row select { min-width:150px; }
    .portrait { width:28px; height:28px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; font-weight:700; font-size:12px; border:1px solid #2d3b73; background:#1a2550; color:#e8ecff; }
    .portrait.sonic { background:#1a4fa3; }
    .portrait.tails { background:#b56a1f; }
    .portrait.knuckles { background:#a33131; }
    .portrait.amy { background:#8e2f60; }
    .header-bar { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; margin:6px 0 12px; }
    .header-bar h1 { margin:0; }
    .header-logo img { height:48px; width:auto; display:block; }
    .top-bar { display:flex; justify-content:flex-end; }
    .menu-wrapper { position:relative; }
    .menu-button { width:36px; height:32px; display:flex; flex-direction:column; justify-content:center; gap:4px; padding:6px; }
    .menu-button span { display:block; width:18px; height:2px; background:#e8ecff; border-radius:2px; }
    .menu-dropdown { position:absolute; right:0; top:40px; background:#121a33; border:1px solid #23305a; border-radius:10px; padding:6px; min-width:140px; display:none; z-index:900; }
    .menu-dropdown.open { display:block; }
    .menu-dropdown button { width:100%; text-align:left; }
    .modal-overlay { position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal-overlay.open { display:flex; }
    .modal { max-width:540px; width:calc(100% - 32px); }
    .modal-actions { justify-content:flex-end; }
    .bonus-stage-modal .modal {
      background:
        linear-gradient(45deg, #fb7 25%, transparent 25%, transparent 75%, #fb7 75%, #fb7),
        linear-gradient(45deg, #fb7 25%, transparent 25%, transparent 75%, #fb7 75%, #fb7);
      background-size: 120px 120px;
      background-position: 0 0, 60px 60px;
      background-color: #da9;
      color:#1a1a1a;
    }
    .bonus-stage-modal .modal h2 {
      color:#1a1a1a;
    }
    .bonus-stage-modal .modal .tiny,
    .bonus-stage-modal .modal .muted {
      color:#2a1a0a;
    }
    .bonus-stage-modal .modal .pill {
      background:#fff1c9;
      border-color:#b8894a;
      color:#1a1a1a;
    }
    .bonus-stage-modal .modal button {
      background:#33d;
      color:#fff;
      border-color:#2240a0;
    }
    .bonus-stage-modal .modal button:hover {
      filter:brightness(1.08);
    }
    .bonus-stage-grid {
      display:grid;
      grid-template-columns: repeat(4, 120px);
      gap:16px;
      justify-content:center;
      margin-top:20px;
    }
    .bonus-tile {
      width:120px;
      height:120px;
      border-radius:12px;
      border:1px solid #2d3b73;
      background:linear-gradient(to bottom, #fdb418, #fee306);
      color:#1a1a1a;
      font-size:11px;
      font-weight:600;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      position:relative;
      cursor:pointer;
      user-select:none;
      padding:6px;
      box-sizing:border-box;
      box-shadow: 0 2px 4px rgba(0,0,0,.8);
    }
    .bonus-tile.revealed { cursor:default; }
    .bonus-tile.revealed { background:linear-gradient(to bottom, #fff3b0, #ffd6a5); }
    .bonus-tile.red { border-color:#8a2a2a; }
    .bonus-tile.bumper { border-color:#8b5b2a; }
    .bonus-tile.chaos {
      background:linear-gradient(to bottom, #fff, #ddd);
      border-color:#b8c6ff;
    }
    .bonus-tile.disabled { opacity:.6; cursor:not-allowed; }
    .bonus-reward {
      position:absolute;
      top:4px;
      right:4px;
      font-size:10px;
      background:#0f1733;
      border:1px solid #2d3b73;
      border-radius:6px;
      padding:1px 4px;
    }
    .bonus-reward img {
      width:18px;
      height:18px;
      display:block;
    }
    .zone-header {
      display:block;
      margin-top:6px;
    }
    .zone-level-name {
      display:flex;
      align-items:center;
      justify-content:space-between;
      width:100%;
      box-sizing:border-box;
      padding:8px 14px;
      border-radius:14px;
      background:linear-gradient(135deg, #0a47c8, #3ddcff, #ffd756);
      color:#ffffff;
      font-weight:900;
      font-size:13px;
      letter-spacing:.12em;
      text-transform:uppercase;
      border:1px solid #e8f3ff;
      box-shadow: 0 4px 12px rgba(0,0,0,.35);
      position:relative;
      text-shadow:
        -1px -1px 0 rgba(0,0,0,.7),
        1px -1px 0 rgba(0,0,0,.7),
        -1px 1px 0 rgba(0,0,0,.7),
        1px 1px 0 rgba(0,0,0,.7);
    }
    .zone-level-name::after {
      content:"";
      position:absolute;
      inset:0;
      border-radius:16px;
      background:linear-gradient(120deg, rgba(255,255,255,.6), rgba(255,255,255,0));
      z-index:-1;
      filter:blur(6px);
    }
    .zone-card { background:#121a33; }
    .zone-level-name .zone-title {
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .zone-level-name .zone-deck {
      font-size:11px;
      letter-spacing:.18em;
      text-transform:uppercase;
      opacity:.95;
    }
    #zoneView { justify-items:start; }
    .zone-card {
      max-width:460px;
      width:100%;
      min-height:230px;
    }
    .zone-layout {
      display:flex;
      gap:6px;
      align-items:stretch;
    }
    .zone-cards {
      flex:1;
      min-width:240px;
    }
    .act-board {
      flex:0 0 200px;
      background:linear-gradient(180deg, #0f2347, #0a142b);
      border:1px solid #23305a;
      border-radius:14px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      box-shadow: 0 8px 25px rgba(0,0,0,.25);
    }
    .act-board-lanes {
      display:flex;
      flex-direction:column;
      gap:8px;
      flex:1;
    }
    .act-lane {
      flex:1;
      display:flex;
      align-items:center;
      gap:10px;
      background:rgba(0,0,0,.2);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:8px;
    }
    .act-lane-arrow {
      width:44px;
      height:24px;
      background:linear-gradient(135deg, #58b6ff, #2f7cff);
      border-radius:8px;
      position:relative;
      flex:0 0 56px;
    }
    .act-lane-arrow::after {
      content:"";
      position:absolute;
      right:-8px;
      top:0;
      border-left:8px solid #2f7cff;
      border-top:12px solid transparent;
      border-bottom:12px solid transparent;
    }
    .act-reward-circle {
      --reward-border: 6px;
      --reward-gap: 1px;
      --reward-inset: calc(var(--reward-border) + var(--reward-gap));
      width:110px;
      height:110px;
      border-radius:50%;
      background:transparent;
      border:var(--reward-border) solid #d8b24c;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      color:#0a142b;
      font-weight:800;
      text-align:center;
      padding:8px;
      box-sizing:border-box;
      overflow:hidden;
    }
    .act-reward-circle::before {
      content:"";
      position:absolute;
      inset:var(--reward-inset);
      border-radius:50%;
      background:radial-gradient(circle at 30% 30%, #ffffff, #b6c8ff);
      z-index:0;
    }
    .act-reward-circle > * { position:relative; z-index:1; }
    .act-reward-circle img {
      width:52px;
      height:52px;
      display:block;
    }
    .reward-inner-mask {
      position:absolute;
      inset:var(--reward-inset);
      border-radius:50%;
      overflow:hidden;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      z-index:1;
    }
    .reward-inner-mask .reward-star-post {
      width:26%;
      height:auto;
      display:block;
    }
    .act-reward-tag {
      position:absolute;
      bottom:6px;
      font-size:9px;
      letter-spacing:.1em;
      text-transform:uppercase;
      background:#0a47c8;
      color:#fff;
      padding:2px 6px;
      border-radius:999px;
    }
    .act-reward-text {
      font-size:10px;
      letter-spacing:.08em;
      text-transform:uppercase;
    }
    .reward-icon {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:18px;
      height:18px;
      vertical-align:middle;
    }
    .reward-icon img {
      width:18px;
      height:18px;
      display:block;
    }
    .chaos-emerald-list { display:flex; flex-wrap:wrap; gap:8px; margin-top:6px; }
    .chaos-emerald-card {
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
      padding:6px 8px;
      border:1px solid #2d3b73;
      border-radius:10px;
      background:#0f1733;
      color:#e8ecff;
      font-size:11px;
      min-width:90px;
    }
    .chaos-emerald-card img { width:36px; height:auto; display:block; }
    .chaos-emerald-card.spent { opacity:.6; text-decoration: line-through; }
    .bonus-icon {
      font-size:70px;
      line-height:1;
    }
  </style>
</head>
<body>
  <div class="header-bar">
    <h1 class="header-logo"><img src="img/Sonic_Roll_Logo.webp" alt="Sonic Roll"></h1>
    <div id="top-bar" class="top-bar">
      <div id="menuWrapper" class="menu-wrapper">
        <button id="menuBtn" class="menu-button" aria-label="Menu">
          <span></span><span></span><span></span>
        </button>
        <div id="menuDropdown" class="menu-dropdown">
          <button id="menuNewGame">New Game</button>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <div id="controlsCard" class="card controls-card" style="flex:1; min-width:340px;">
      <div id="characterHeading" class="character-heading"></div>
      <div class="hr"></div>

      <div class="row">
        <div id="rollActionButtons" class="row"></div>
        <button id="btnBuildPool">Roll / Build Dice Pool</button>
      </div>

      <div class="row" style="margin-top:8px;">
        <button id="btnUseBoostToken">Use Boost Token</button>
        <button id="btnSpendDie">Spend Selected Die</button>
        <button id="btnRerollStep">Reroll Step</button>
        <button id="btnEndTurn">End Turn (Discard + Time)</button>
      </div>

      <div class="hr"></div>

      <div class="tiny row">
        <div><span class="badge">Phase</span> <span id="phase"></span></div>
        <div><span class="badge">Invulnerable</span> <span id="invuln"></span></div>
      </div>

      <div class="hr"></div>

      <h2>Dice Pool</h2>
      <div id="dicePool"></div>
      <div class="tiny muted">Click a die to select it for spending.</div>

      <div class="hr"></div>

      <div id="wallClimbSection">
        <h2>Wall Climb</h2>
        <div id="wallClimbPanel" class="tiny muted"></div>
        <div class="hr"></div>
      </div>

      <div id="discardSection">
        <h2>Discard a Die</h2>
        <div id="discardPanel" class="tiny muted"></div>
        <div class="hr"></div>
      </div>

      <div id="starPostSection">
        <h2>Star Post</h2>
        <div id="starPostPanel" class="tiny muted"></div>
        <div class="hr"></div>
      </div>

      <h2>Spend Target</h2>
      <div id="spendTargetPanel" class="tiny muted">Select a die and click "Spend Selected Die" to choose a target. Tip: click a Zone/Badnik card to preselect.</div>

      <div class="hr"></div>

      <h2>Per-Turn Counters</h2>
      <div id="counters" class="tiny"></div>

      <div class="hr"></div>

      <h2>Power Ups</h2>
      <div id="powerUpStatus" class="tiny"></div>
      <div id="powerUpPanel" class="tiny muted">No pending Power Ups.</div>

      <div class="hr"></div>

      <h2>Chaos Emeralds</h2>
      <div id="chaosEmeraldPanel" class="tiny muted"></div>

      <div class="hr"></div>

      <h2>Debug</h2>
      <button id="btnForceBonusStage">Force Bonus Stage</button>
    </div>

    <div class="card" style="flex:1.2; min-width:360px;">
      <h2 style="display:none;">Zone (Simplified Track)</h2>
      <div id="zoneHeaderInfo" class="zone-header"></div>
      <p class="tiny muted">
        For now: each route has a “next challenge” requiring an exact number, sometimes also an exact colour. This is a stand-in until we encode real Zone Cards.
      </p>
      <div class="zone-layout">
        <div class="zone-cards">
          <div id="zoneView" class="grid"></div>
        </div>
        <div id="actBoardView" class="act-board"></div>
      </div>
    </div>

    <div class="card" style="flex:0 0 320px; min-width:320px;">
      <h2>Badniks (Simplified)</h2>
      <p class="tiny muted">
        Badniks attack only dice being rerolled. Destroy/Avoid are simplified (exact match).
      </p>
      <div id="badnikView"></div>

      <div class="hr"></div>

      <h2>Log</h2>
      <div id="log" class="log mono"></div>

      <div class="hr"></div>

      <h2>Discarded Power Ups</h2>
      <div id="powerUpDiscardView" class="tiny muted"></div>

      <div class="hr"></div>

      <h2>Discarded Badniks</h2>
      <div id="badnikDiscardView" class="tiny muted"></div>

      <div class="hr"></div>

      <h2>Time Scoring</h2>
      <div id="timeScoringView" class="tiny muted"></div>

    </div>
  </div>

  <div id="newGameModal" class="modal-overlay">
    <div class="card modal">
      <h2>New Game</h2>
      <h2>Game Controls</h2>
      <div class="row">
        <label class="pill tiny">Players
          <select id="playerCount">
            <option>1</option><option selected>2</option><option>3</option><option>4</option>
          </select>
        </label>
        <label class="pill tiny">Seed
          <input id="seed" value="" size="10" />
        </label>
        <label class="pill tiny">Zone
          <select id="zoneSelect"></select>
        </label>
      </div>

      <div class="hr"></div>

      <h2>Characters</h2>
      <div id="playerSetup" class="player-setup tiny"></div>
      <div class="tiny muted">Each character can only be used once per game.</div>

      <div class="hr"></div>

      <div class="row modal-actions">
        <button id="cancelNewGameBtn">Cancel</button>
        <button id="confirmNewGameBtn">Start New Game</button>
      </div>
    </div>
  </div>

  <div id="bonusStageModal" class="modal-overlay bonus-stage-modal">
    <div class="card modal">
      <h2>Bonus Stage</h2>
      <div id="bonusStageStatus" class="tiny muted"></div>
      <div id="bonusStageGrid" class="bonus-stage-grid"></div>
      <div class="row modal-actions">
        <button id="bonusStageExit">Return to Zone</button>
      </div>
    </div>
  </div>

<script>
/* =======================
   RNG (seeded)
   ======================= */
function mulberry32(seed) {
  let a = seed >>> 0;
  return function() {
    a += 0x6D2B79F5;
    let t = a;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function hashSeed(str) {
  let h = 2166136261 >>> 0;
  for (let i=0;i<str.length;i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}
let __rng = null;
function initGameRng(seed) { __rng = mulberry32(seed); }
function rng(){ return __rng; }
function rollD6(){ return 1 + Math.floor(rng()()*6); }

/* =======================
   Types / helpers
   ======================= */
const DieColor = Object.freeze({ BLUE:"blue", YELLOW:"yellow", RED:"red", BLACK:"black" });

let PRE_GAME_CHARACTERS = [];
let PRE_GAME_ZONE = "green_hill";

function uuid() {
  // browser-safe UUID fallback
  if (crypto?.randomUUID) return crypto.randomUUID();
  return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now();
}

function makeDie(color, value) { return { id: uuid(), color, value }; }
function clone(obj) { return JSON.parse(JSON.stringify(obj)); }
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng()() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function log(state, msg) { state.log.push(msg); return state; }
function makeVulnerable(p){ p.invulnerable = false; }
function makeInvulnerable(p){ p.invulnerable = true; }

function getPipPositions(value) {
  switch (value) {
    case 1: return [4];
    case 2: return [0, 8];
    case 3: return [0, 4, 8];
    case 4: return [0, 2, 6, 8];
    case 5: return [0, 2, 4, 6, 8];
    case 6: return [0, 2, 3, 5, 6, 8];
    default: return [4];
  }
}

function buildDieFaceHtml(value) {
  const v = Math.max(1, Math.min(6, Number(value) || 1));
  const on = new Set(getPipPositions(v));
  const pips = Array.from({ length: 9 }, (_, i) => {
    return `<span class="pip${on.has(i) ? " on" : ""}"></span>`;
  }).join("");
  return `<div class="pip-grid">${pips}</div>`;
}

function buildGradientCss(colors) {
  if (!Array.isArray(colors) || !colors.length) return "";
  if (colors.length === 1 && typeof colors[0] === "string") return colors[0];
  const stops = colors.map((entry, index) => {
    if (typeof entry === "string") {
      const pct = Math.round((index / (colors.length - 1)) * 100);
      return `${entry} ${pct}%`;
    }
    if (entry && typeof entry === "object") {
      const pct = Number.isFinite(entry.stop) ? entry.stop : Math.round((index / (colors.length - 1)) * 100);
      return `${entry.color} ${pct}%`;
    }
    return "";
  }).filter(Boolean);
  return `linear-gradient(180deg, ${stops.join(", ")})`;
}

function isGameOver(state) {
  if (state.timeTokens <= 0) return "Time ran out (0 Time Tokens)";
  for (const p of state.players) if (p.lives <= 0) return `${p.name} lost final Life`;
  return null;
}

function getDefaultCharacterOrder() {
  return Object.keys(CONFIG.characters);
}

const CHARACTER_PORTRAITS = {
  Sonic: { label: "S", className: "sonic" },
  Tails: { label: "T", className: "tails" },
  Knuckles: { label: "K", className: "knuckles" },
  Amy: { label: "A", className: "amy" }
};

function applyPortrait(el, character) {
  if (!el) return;
  const def = CHARACTER_PORTRAITS[character] || { label: "?", className: "" };
  el.textContent = def.label;
  el.className = `portrait ${def.className}`;
  el.title = character || "Unknown";
}

function updatePortraitsFromSelectors() {
  const selects = Array.from(document.querySelectorAll("[id^='playerCharSelect-']"));
  for (const sel of selects) {
    const idx = sel.id.split("-")[1];
    const portrait = document.getElementById(`playerPortrait-${idx}`);
    applyPortrait(portrait, sel.value);
  }
}

function getPreGameCharacterSelections(playerCount) {
  const allChars = getDefaultCharacterOrder();
  const used = new Set();
  const out = [];
  for (let i = 0; i < playerCount; i++) {
    let choice = PRE_GAME_CHARACTERS[i];
    if (!allChars.includes(choice) || used.has(choice)) {
      choice = allChars.find(c => !used.has(c)) || allChars[i % allChars.length];
    }
    out.push(choice);
    used.add(choice);
  }
  PRE_GAME_CHARACTERS = out.slice();
  return out;
}

function enforceUniqueCharacterSelections() {
  const selects = Array.from(document.querySelectorAll("[id^='playerCharSelect-']"));
  const allChars = getDefaultCharacterOrder();
  const used = new Set();
  for (const sel of selects) {
    let choice = sel.value;
    if (!allChars.includes(choice) || used.has(choice)) {
      choice = allChars.find(c => !used.has(c)) || allChars[0];
      sel.value = choice;
    }
    used.add(choice);
  }
  for (const sel of selects) {
    for (const opt of sel.options) {
      opt.disabled = used.has(opt.value) && opt.value !== sel.value;
    }
  }
  PRE_GAME_CHARACTERS = selects.map(s => s.value);
  updatePortraitsFromSelectors();
}

function renderCharacterSelectors() {
  const container = document.getElementById("playerSetup");
  if (!container) return;
  const playerCount = parseInt(document.getElementById("playerCount").value, 10);
  const selections = getPreGameCharacterSelections(playerCount);
  const allChars = getDefaultCharacterOrder();
  container.innerHTML = "";

  for (let i = 0; i < playerCount; i++) {
    const row = document.createElement("div");
    row.className = "player-setup-row";
    row.innerHTML = `
      <span class="badge">P${i+1}</span>
      <span id="playerPortrait-${i}" class="portrait"></span>
      <select id="playerCharSelect-${i}"></select>
    `;
    const sel = row.querySelector("select");
    for (const name of allChars) {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      sel.appendChild(opt);
    }
    sel.value = selections[i] || allChars[i % allChars.length];
    sel.addEventListener("change", () => {
      PRE_GAME_CHARACTERS[i] = sel.value;
      enforceUniqueCharacterSelections();
    });
    const portrait = row.querySelector(`#playerPortrait-${i}`);
    applyPortrait(portrait, sel.value);
    container.appendChild(row);
  }
  enforceUniqueCharacterSelections();
}

function renderZoneSelector() {
  const select = document.getElementById("zoneSelect");
  if (!select) return;
  select.innerHTML = "";
  for (const zone of Object.values(CONFIG.zones)) {
    const opt = document.createElement("option");
    opt.value = zone.id;
    opt.textContent = zone.name;
    select.appendChild(opt);
  }
  if (!CONFIG.zones[PRE_GAME_ZONE]) {
    PRE_GAME_ZONE = Object.keys(CONFIG.zones)[0];
  }
  select.value = PRE_GAME_ZONE;
  select.addEventListener("change", () => {
    PRE_GAME_ZONE = select.value;
  });
}

function readZoneSelection() {
  const select = document.getElementById("zoneSelect");
  return select?.value || PRE_GAME_ZONE || Object.keys(CONFIG.zones)[0];
}

function readCharacterSelections(playerCount) {
  const selections = [];
  for (let i = 0; i < playerCount; i++) {
    const sel = document.getElementById(`playerCharSelect-${i}`);
    selections.push(sel ? sel.value : null);
  }
  return selections;
}

/* =======================
   Dashboard-accurate config
   (from the four images you provided)
   ======================= */
const BIG_RING_AMOUNT = 5; // Reference value for Big Ring rewards (Bonus Stage trigger).

// Zone-specific Badnik decks (swap per zone via badnikDeckId).
const BASE_BADNIK_DECK = [
  { name:"Moto Bug", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
  { name:"Crabmeat", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
  { name:"Buzz Bomber", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
  { name:"Chopper", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } }
];

const BADNIK_DECKS = {
  default: BASE_BADNIK_DECK,
  green_hill: BASE_BADNIK_DECK,
  stardust_speedway: [
    { name:"Horatu", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { name:"Kabasira", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { name:"Dango", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { name:"Kanabun", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } }
  ]
};

const CONFIG = {
  characters: {
    Sonic: {
      ability: { name:"Insta-Shield", perTurnToken:true },
      rollActions: [
        {
          name:"Super Peel Out",
          dice:{ blue:6 },
          // ROLL: Discard the lowest result(s) in your Dice Pool.
          onBuildPool: (ctx) => {
            const { p, state } = ctx;
            const min = Math.min(...p.dicePool.map(d=>d.value));
            const removed = p.dicePool.filter(d => d.value === min);
            if (removed.length) {
              p.dicePool = p.dicePool.filter(d => d.value !== min);
              const label = removed.map(d => `${d.color.toUpperCase()}-${d.value}`).join(" ");
              log(state, `Sonic Super Peel Out (ROLL): discard lowest dice (${label}).`);
            }
          }
        },
        {
          name:"Spin Dash",
          dice:{ blue:1, red:1 },
          // ROLL: Repeat roll until 2 results in your Dice Pool match.
          buildMode:"repeatUntilPair"
        },
        {
          name:"Drop Dash",
          dice:{ yellow:3 },
          // SPEND: If a yellow die is spent on a Zone Card, gain a blue die.
          onSpend: (ctx) => {
            const { state, p, spendTarget, spentDie } = ctx;
            if (spendTarget?.type === "zone" && spentDie?.color === DieColor.YELLOW) {
              const d = makeDie(DieColor.BLUE, rollD6());
              p.dicePool.push(d);
              log(state, `Sonic Drop Dash (SPEND): gained a BLUE die (${d.value}) for spending on a Zone.`);
            }
          }
        }
      ]
    },

    Tails: {
      ability: { name:"Buddy Flight", perTurnToken:false }, // model later
      rollActions: [
        {
          name:"Fly",
          dice:{ yellow:4 },
          // x2, ROLL: Save matching pairs, discard the rest.
          // If no pairs, instead save any 1 die, discard the rest.
          buildMode:"tailsFlyX2"
        },
        {
          name:"Spin Jump",
          dice:{ red:3 },
          // SPEND: Gain yellow die if spent on a Badnik.
          onSpend: (ctx) => {
            const { state, p, spendTarget } = ctx;
            if (spendTarget?.type === "badnik") {
              const d = makeDie(DieColor.YELLOW, rollD6());
              p.dicePool.push(d);
              log(state, `Tails Spin Jump (SPEND): gained a YELLOW die (${d.value}) for spending on a Badnik.`);
            }
          }
        },
        {
          name:"Propeller Tail",
          dice:{ blue:4 },
          // REROLL: Gain yellow die if 2 or more dice were spent since the last Reroll.
          onRerollStepStart: (ctx) => {
            const { state, p } = ctx;
            if (p.spentSinceLastReroll >= 2 && !p.propellerTailBonusGivenSinceReroll) {
              const d = makeDie(DieColor.YELLOW, rollD6());
              p.dicePool.push(d);
              p.propellerTailBonusGivenSinceReroll = true;
              log(state, `Tails Propeller Tail (REROLL): spent>=2 since last reroll -> gained a YELLOW die (${d.value}).`);
            }
          }
        }
      ]
    },

    Knuckles: {
      ability: { name:"Secret Passage", perTurnToken:false }, // model later
      rollActions: [
        {
          name:"Wall Climb",
          dice:{ red:3 },
          repeats:3,
          // ROLL: Save a die as long as its result is higher than last saved die. Discard all unsaved dice.
          buildMode:"knucklesWallClimbX3"
        },
        {
          name:"Spin Attack",
          dice:{ blue:4 },
          // AVOID: May change a blue into a red.
          // For now: we expose a simple "convert selected blue->red" hotkey in UI later if desired.
          onAvoidConvert: { from: DieColor.BLUE, to: DieColor.RED }
        },
        {
          name:"Glide",
          dice:{ yellow:4 },
          // SPEND: May spend another yellow without rerolling if its result is lower than last spent die.
          onSpendChainRule: { color: DieColor.YELLOW, direction:"lower" }
        }
      ]
    },

    Amy: {
      ability: { name:"Piko Piko Hammer", perTurnToken:false },
      rollActions: [
        {
          name:"Hammer Throw",
          dice:{ red:3 },
          // SPEND red: May spend on any player's Badnik (once per turn).
          // Engine note: cross-player targeting is not wired into UI yet; placeholder logs when spending on own badnik.
          onSpend: (ctx) => {
            const { state, p, spentDie, spendTarget } = ctx;
            if (spentDie?.color === DieColor.RED && spendTarget?.type === "badnik") {
              if (p.oncePerTurn?.hammerThrowUsed) return;
              p.oncePerTurn.hammerThrowUsed = true;
              log(state, `Amy Hammer Throw (SPEND): would allow targeting any player's Badnik (once/turn). (UI currently spends on own Badnik.)`);
            }
          }
        },
        {
          name:"Spin Dash",
          dice:{ blue:1, red:1 },
          buildMode:"repeatUntilPair"
        },
        {
          name:"Hammer Rush",
          dice:{ yellow:3 },
          // SPEND yellow: Gain red die if a yellow die is spent on a Zone Card.
          onSpend: (ctx) => {
            const { state, p, spendTarget, spentDie } = ctx;
            if (spendTarget?.type === "zone" && spentDie?.color === DieColor.YELLOW) {
              const d = makeDie(DieColor.RED, rollD6());
              p.dicePool.push(d);
              log(state, `Amy Hammer Rush (SPEND): gained a RED die (${d.value}) for spending on a Zone.`);
            }
          }
        }
      ]
    }
  },

  // Simplified Zone generator (placeholder until we encode real Zone Cards)
  zoneGenerator: {
    challengesMin: 5,
    challengesMax: 7,
    deckCounts: { 1: 8, 2: 8, 3: 9, 4: 10 },
    bumper: {
      maxGroups: 1,
      groupChance: 0.55,
      tripleChance: 0.35,
      colorChance: 0.2
    }
  },
  zones: {
    green_hill: {
      id: "green_hill",
      name: "Green Hill Zone Act 1",
      badnikDeckId: "green_hill",
      zoneGenerator: {
        actBoardName: "Green Hill Zone Act 1",
        actBoardRewards: {
          Top: { type:"big_ring" },
          Middle: { type:"star_post", amount:1 },
          Bottom: { type:"power_up" }
        },
        cardGradient: ["#1c2d66", "#2f7cff", "#8bd3ff"]
      }
    },
    stardust_speedway: {
      id: "stardust_speedway",
      name: "Stardust Speedway Zone Act 1",
      badnikDeckId: "stardust_speedway",
      zoneGenerator: {
        actBoardName: "Stardust Speedway Zone Act 1",
        actBoardRewards: {
          Top: { type:"big_ring" },
          Middle: { type:"star_post", amount:1 },
          Bottom: { type:"power_up" }
        },
        cardGradient: [
          { color: "#1f2a7a", stop: 0 },
          { color: "#4a1c7a", stop: 50 },
          { color: "#ffd400", stop: 50 },
          { color: "#b48fe6", stop: 100 }
        ]
      }
    },
    lava_reef: {
      id: "lava_reef",
      name: "Lava Reef Zone Act 1",
      badnikDeckId: "lava_reef",
      zoneGenerator: {
        actBoardName: "Lava Reef Zone Act 1",
        actBoardRewards: {
          Top: { type:"big_ring" },
          Middle: { type:"star_post", amount:1 },
          Bottom: { type:"power_up" }
        },
        cardGradient: [
          { color: "#d65a2a", stop: 0 },
          { color: "#ffd257", stop: 33 },
          { color: "#e37a2f", stop: 66 },
          { color: "#c7743f", stop: 66 },
          { color: "#8a5a36", stop: 100 }
        ]
      }
    }
  }
};

const POWER_UPS = [
  { id: "super_ring", label: "Super Ring", count: 3 },
  { id: "hyper_ring", label: "Hyper Ring", count: 2 },
  { id: "eggman_mark", label: "Eggman Mark", count: 2 },
  { id: "power_sneakers", label: "Power Sneakers", count: 3 },
  { id: "invincible", label: "Invincible", count: 2 },
  { id: "one_up", label: "1-Up", count: 3 },
  { id: "shield_flame", label: "Flame Shield", count: 2 },
  { id: "shield_bubble", label: "Bubble Shield", count: 2 },
  { id: "shield_lightning", label: "Lightning Shield", count: 2 },
  { id: "shield_blue", label: "Blue Shield", count: 2 }
];

const CHAOS_EMERALDS = [
  { id: "chaos_emerald_green", color: "green", img: "img/chaos_emerald_01_green.png" },
  { id: "chaos_emerald_yellow", color: "yellow", img: "img/chaos_emerald_02_yellow.png" },
  { id: "chaos_emerald_blue", color: "blue", img: "img/chaos_emerald_03_blue.png" },
  { id: "chaos_emerald_purple", color: "purple", img: "img/chaos_emerald_04_purple.png" },
  { id: "chaos_emerald_white", color: "white", img: "img/chaos_emerald_05_white.png" },
  { id: "chaos_emerald_cyan", color: "cyan", img: "img/chaos_emerald_06_cyan.png" },
  { id: "chaos_emerald_red", color: "red", img: "img/chaos_emerald_07_red.png" }
].map(card => ({
  ...card,
  diceBonusColors: [],
  extraReward: null
}));

function getPowerUpLabel(id) {
  const entry = POWER_UPS.find(p => p.id === id);
  return entry ? entry.label : id;
}

function getChaosEmeraldLabel(card) {
  if (!card) return "Chaos Emerald";
  const color = card.color ? `${card.color[0].toUpperCase()}${card.color.slice(1)}` : "Unknown";
  return `${color} Chaos Emerald`;
}

function getShieldLabel(type) {
  if (type === "flame") return "Flame Shield";
  if (type === "bubble") return "Bubble Shield";
  if (type === "lightning") return "Lightning Shield";
  if (type === "blue") return "Blue Shield";
  return type;
}

function isShieldPowerUp(id) {
  return id && id.startsWith("shield_");
}

function getShieldTypeFromPowerUp(id) {
  return id.replace("shield_", "");
}

function getShieldPowerUpId(type) {
  return `shield_${type}`;
}

function buildPowerUpDeck() {
  const deck = [];
  for (const p of POWER_UPS) {
    const count = Math.max(0, p.count ?? 1);
    for (let i = 0; i < count; i++) deck.push(p.id);
  }
  return shuffle(deck);
}

function drawPowerUp(state) {
  if (!state.powerUpDeck) state.powerUpDeck = [];
  if (!state.powerUpDiscard) state.powerUpDiscard = [];
  if (!state.powerUpDeck.length) {
    if (state.powerUpDiscard.length) {
      state.powerUpDeck = shuffle(state.powerUpDiscard);
      state.powerUpDiscard = [];
      log(state, "Power Up deck reshuffled from discard.");
    } else {
      log(state, "Power Up deck empty: no Power Ups available.");
      return null;
    }
  }
  const next = state.powerUpDeck.shift();
  state.powerUpDiscard.push(next);
  log(state, `Power Up drawn: ${getPowerUpLabel(next)}.`);
  return next;
}

function removePowerUpFromDiscard(state, powerUpId) {
  if (!state.powerUpDiscard) state.powerUpDiscard = [];
  const idx = state.powerUpDiscard.indexOf(powerUpId);
  if (idx >= 0) state.powerUpDiscard.splice(idx, 1);
}

function addPowerUpToDiscard(state, powerUpId) {
  if (!state.powerUpDiscard) state.powerUpDiscard = [];
  state.powerUpDiscard.push(powerUpId);
}

function clearInvinciblePowerUps(state, p, reason) {
  if (!p.invincibleTokens) return;
  for (let i = 0; i < p.invincibleTokens; i++) {
    addPowerUpToDiscard(state, "invincible");
  }
  log(state, `${p.name} discards Invincible (${reason}).`);
  p.invincibleTokens = 0;
}

function buildChaosEmeraldDeck() {
  return shuffle(CHAOS_EMERALDS.map(card => ({
    ...card,
    spent: false,
    instanceId: uuid()
  })));
}

function getChaosCounts(p) {
  const list = p.chaosEmeralds || [];
  const spent = list.filter(c => c.spent).length;
  return { ready: list.length - spent, spent };
}

function drawChaosEmerald(state) {
  if (!state.chaosEmeraldDeck || !state.chaosEmeraldDeck.length) {
    log(state, "Chaos Emerald deck empty: no Emeralds available.");
    return null;
  }
  const p = state.players[state.activePlayer];
  const card = state.chaosEmeraldDeck.shift();
  p.chaosEmeralds.push(card);
  log(state, `${p.name} gains the ${getChaosEmeraldLabel(card)}.`);
  return true;
}

function spendChaosEmerald(state, emeraldId) {
  if (state.ui?.discard?.open || state.ui?.starPost?.open) {
    log(state, "Resolve the current prompt before spending a Chaos Emerald.");
    return;
  }
  if (state.pendingPowerUp || state.pendingDamage || state.pendingBadnikReward || state.pendingWallClimb || state.pendingAvoid || state.bonusStage?.open) {
    log(state, "Resolve the pending reward before spending a Chaos Emerald.");
    return;
  }
  const p = state.players[state.activePlayer];
  const card = p.chaosEmeralds.find(c => c.id === emeraldId && !c.spent);
  if (!card) {
    log(state, "Chaos Emerald spend failed: no unspent Emerald found.");
    return;
  }
  const colors = Array.isArray(card.diceBonusColors) ? card.diceBonusColors : [];
  if (colors.length !== 2) {
    log(state, "Chaos Emerald dice bonus colors not configured yet.");
    return;
  }
  card.spent = true;
  log(state, `${p.name} spends the ${getChaosEmeraldLabel(card)}.`);
  colors.forEach(color => {
    if (!color) return;
    const d = makeDie(color, rollD6());
    p.dicePool.push(d);
  });
  log(state, "Chaos Emerald bonus: added two dice to the Dice Pool.");
  if (card.extraReward) {
    applyReward(state, card.extraReward);
    log(state, "Chaos Emerald extra reward applied.");
  }
}

function buildBonusStageTiles() {
  const tiles = [];
  const bumperRewards = shuffle([
    ...Array(4).fill(0).map(() => ({ type: "rings", amount: 1 })),
    ...Array(3).fill(0).map(() => ({ type: "boost", amount: 1 }))
  ]);
  const redRewards = shuffle([
    ...Array(2).fill(0).map(() => ({ type: "boost", amount: 1 })),
    ...Array(6).fill(0).map(() => ({ type: "power_up" }))
  ]);

  tiles.push({ id: uuid(), type: "chaos", reward: null, revealed: false });
  bumperRewards.forEach(reward => tiles.push({ id: uuid(), type: "bumper", reward, revealed: false }));
  redRewards.forEach(reward => tiles.push({ id: uuid(), type: "red", reward, revealed: false }));

  return shuffle(tiles);
}

function initBonusStageState() {
  return {
    open: false,
    tiles: buildBonusStageTiles(),
    message: "",
    awaitingExit: false,
    resetOnClose: false,
    activePlayerId: null
  };
}

function ensureBonusStageState(state) {
  if (!state.bonusStage) state.bonusStage = initBonusStageState();
  if (!state.bonusStage.tiles || !state.bonusStage.tiles.length) {
    state.bonusStage.tiles = buildBonusStageTiles();
  }
}

function canStartBonusStage(state) {
  if (!state) return false;
  return !state.pendingPowerUp &&
    !state.pendingDamage &&
    !state.pendingBadnikReward &&
    !state.pendingWallClimb &&
    !state.pendingAvoid &&
    !state.ui?.discard?.open &&
    !state.ui?.starPost?.open;
}

function queueBonusStage(state, reason) {
  if (!state) return;
  if (!canStartBonusStage(state) || state.bonusStage?.open) {
    if (!state.pendingBonusStage) state.pendingBonusStage = { reasons: [] };
    state.pendingBonusStage.reasons.push(reason);
    log(state, `Bonus Stage queued: ${reason}`);
    return;
  }
  enterBonusStage(state, reason);
}

function enterBonusStage(state, reason) {
  ensureBonusStageState(state);
  const stage = state.bonusStage;
  stage.open = true;
  stage.awaitingExit = false;
  stage.resetOnClose = false;
  stage.activePlayerId = state.activePlayer;
  stage.message = reason ? `Bonus Stage: ${reason}` : "Bonus Stage: flip a tile.";
  const p = state.players[state.activePlayer];
  log(state, `${p.name} enters the Bonus Stage.`);
}

function closeBonusStage(state) {
  const stage = state.bonusStage;
  if (!stage) return;
  stage.open = false;
  stage.awaitingExit = false;
  stage.message = "";
  if (stage.resetOnClose) {
    stage.tiles = buildBonusStageTiles();
    stage.resetOnClose = false;
    log(state, "Bonus Stage reset with a new tile grid.");
  }
}

function formatBonusStageRewardLabel(reward) {
  if (!reward) return "";
  if (reward.type === "rings") return "Ring";
  if (reward.type === "boost") return "Boost";
  if (reward.type === "power_up") return "Power Up";
  return formatRewardLabel(reward);
}

function flipBonusStageTile(state, tileId) {
  const stage = state.bonusStage;
  if (!stage || !stage.open || stage.awaitingExit) return;
  if (state.pendingPowerUp || state.pendingBadnikReward || state.pendingDamage || state.pendingWallClimb) {
    log(state, "Resolve the pending reward before flipping another Bonus Stage tile.");
    return;
  }
  const tile = stage.tiles.find(t => t.id === tileId);
  if (!tile || tile.revealed) return;
  tile.revealed = true;

  if (tile.type === "chaos") {
    drawChaosEmerald(state);
    stage.message = "Chaos Emerald found! Bonus Stage cleared.";
    stage.awaitingExit = true;
    stage.resetOnClose = true;
    log(state, "Bonus Stage cleared (Chaos Emerald found).");
    return;
  }

  const reward = tile.reward || null;
  if (reward) applyReward(state, reward);
  const rewardLabel = reward ? formatBonusStageRewardLabel(reward) : "Reward";

  if (tile.type === "red") {
    stage.message = `Red Sphere: ${rewardLabel}. Bonus Stage ends.`;
    stage.awaitingExit = true;
    log(state, "Bonus Stage ends on a Red Sphere.");
  } else {
    stage.message = `Bumper Sphere: ${rewardLabel}. Flip another tile.`;
    log(state, "Bonus Stage continues after Bumper Sphere.");
  }
}

/* =======================
   Zone (simplified)
   ======================= */
function generateZoneCard(genCfg) {
  const bumperCfg = genCfg.bumper || {};
  const maxGroups = bumperCfg.maxGroups ?? 0;
  const groupChance = bumperCfg.groupChance ?? 0;
  const tripleChance = bumperCfg.tripleChance ?? 0.3;
  const colorChance = bumperCfg.colorChance ?? 0.4;

  function rollBaseColor() {
    const r = rng()();
    return r < 0.1 ? DieColor.BLUE : r < 0.2 ? DieColor.YELLOW : r < 0.3 ? DieColor.RED : null;
  }

  function rollBumperColor() {
    const r = rng()();
    return r < 0.34 ? DieColor.BLUE : r < 0.67 ? DieColor.YELLOW : DieColor.RED;
  }

  function rollReward() {
    const rr = rng()();
    const rrr = rng()();
    const hr = rng()();
    return rr < 0.25 ? { type:"rings", amount: (rrr<0.1?4:(rrr<0.3?3:(rrr<0.6?2:1))) } :
           rr < 0.50  ? { type:"boost", amount:1 } :
           rr < 0.70 ? { type:"badnik", amount:1 } :
           rr < 0.75 ? { type:"hazard", amount: (hr < 0.88 ? 1 : (hr < 0.98 ? 2 : 3)) } :
           rr < 0.80 ? { type:"lose_die", amount:1 } :
           rr < 0.88 ? { type:"star_post", amount:1 } :
           rr < 0.93 ? { type:"big_ring" } :
                       { type:"power_up" };
  }

  const minChallenges = genCfg.challengesMin ?? genCfg.challengesPerCard ?? 7;
  const maxChallenges = genCfg.challengesMax ?? genCfg.challengesPerCard ?? minChallenges;
  const totalChallenges = minChallenges + Math.floor(rng()() * (maxChallenges - minChallenges + 1));

  const challenges = [];
  let lastRewardType = null;
  for (let i=0;i<totalChallenges;i++) {
    const n = rollD6();
    const color = rollBaseColor();
    let reward = rollReward();
    let attempts = 0;
    while (reward?.type === lastRewardType && attempts < 6) {
      reward = rollReward();
      attempts++;
    }
    lastRewardType = reward?.type ?? null;
    challenges.push({ id: uuid(), n, color, cleared:false, reward });
  }

  const occupied = Array(challenges.length).fill(false);
  const groupCount = Math.min(maxGroups, challenges.length > 2 ? maxGroups : 0);
  for (let g=0; g<groupCount; g++) {
    if (rng()() > groupChance) continue;
    const length = rng()() < tripleChance ? 3 : 2;
    if (length > challenges.length) continue;
    let placed = false;
    for (let attempts=0; attempts<25; attempts++) {
      const start = Math.floor(rng()() * (challenges.length - length + 1));
      if (occupied.slice(start, start + length).some(Boolean)) continue;
      const groupId = uuid();
      const bumperColor = rng()() < colorChance ? rollBumperColor() : null;
      for (let i=0;i<length;i++) {
        const ch = challenges[start + i];
        ch.bumper = { id: groupId, index: i, length };
        ch.n = null;
        ch.color = bumperColor;
        occupied[start + i] = true;
      }
      placed = true;
      break;
    }
    if (!placed) break;
  }

  return { id: uuid(), challenges, bumperLocks: {} };
}

function generateZone(genCfg, playerCount) {
  const deckCount = genCfg.deckCounts?.[playerCount] || genCfg.deckCounts?.[2] || 8;
  const deck = [];
  for (let i=0;i<deckCount;i++) deck.push(generateZoneCard(genCfg));
  shuffle(deck);

  const routes = ["Top","Middle","Bottom"].map(name => ({
    id: uuid(),
    name,
    activeCard: deck.shift() || null
  }));

  return { routes, deck, bossFightReady:false };
}

function generateActBoard(genCfg) {
  const routes = ["Top","Middle","Bottom"].map(name => ({
    id: uuid(),
    name,
    reward: genCfg.actBoardRewards?.[name] || { type:"rings", amount:1 }
  }));
  return {
    name: genCfg.actBoardName || "Act 1",
    routes,
    cardGradient: genCfg.cardGradient || null
  };
}

function getZoneConfig(zoneId) {
  const zones = CONFIG.zones || {};
  if (zoneId && zones[zoneId]) return zones[zoneId];
  const first = Object.values(zones)[0];
  return first || { id: "default", name: "Act 1", zoneGenerator: {} };
}

function resetBuddyFlightForTurn(state) {
  if (!state?.buddyFlight) return;
  const p = state.players[state.activePlayer];
  if (!p || p.character !== "Tails") return;
  state.buddyFlight.value = 2;
  log(state, "Buddy Flight die set to 2 (Tails' turn).");
}

/* =======================
   Game creation
   ======================= */
function newGame({ playerCount, seedStr, characterSelections, zoneId }) {
  const seed = hashSeed(seedStr);
  initGameRng(seed);

  const charNames = Object.keys(CONFIG.characters);
  const requested = Array.isArray(characterSelections) ? characterSelections : [];
  const used = new Set();
  const finalChars = [];
  for (let i = 0; i < playerCount; i++) {
    let choice = requested[i];
    if (!charNames.includes(choice) || used.has(choice)) {
      choice = charNames.find(c => !used.has(c)) || charNames[i % charNames.length];
    }
    finalChars.push(choice);
    used.add(choice);
  }

  const players = Array.from({length: playerCount}, (_,i) => {
    const character = finalChars[i];
    const rollActions = CONFIG.characters[character].rollActions;
    return {
      id: i,
      name: `P${i+1}`,
      character,
      chosenRollAction: rollActions[0].name,
      rollActionSelectedThisTurn: false,

      lives: 3,
      boost: 1,
      heldRings: 0,
      savedRings: 0,
      zoneCardsCompleted: 0,
      animalTokens: 0,
      timeTokensTaken: 0,
      chaosEmeralds: [],
      hyperRing: false,
      invincibleTokens: 0,
      shield: null,
      flameShieldArmed: false,
      lightningShieldArmed: false,
      blueShieldLostThisTurn: false,

      badniks: [],
      dicePool: [],
      selectedDieId: null,

      invulnerable: false,
      spentSinceLastReroll: 0,
      hasRerolledThisTurn: false,
      propellerTailBonusGivenSinceReroll: false,
      oncePerTurn: {},
      lastChainSpendRule: null, // used for Glide-like chaining
    };
  });

  const zoneConfig = getZoneConfig(zoneId);
  const zoneGen = { ...CONFIG.zoneGenerator, ...zoneConfig.zoneGenerator };
  const badnikDeckId = zoneConfig.badnikDeckId || "default";
  const badnikDeckSeed = BADNIK_DECKS[badnikDeckId] || BADNIK_DECKS.default || [];
  const badnikDeck = shuffle(clone(badnikDeckSeed));
  const zone = generateZone(zoneGen, playerCount);
  const actBoard = generateActBoard(zoneGen);
  const powerUpDeck = buildPowerUpDeck();
  const chaosEmeraldDeck = buildChaosEmeraldDeck();
  const bonusStage = initBonusStageState();
  const buddyFlight = finalChars.includes("Tails") ? { value: 0 } : null;

  const state = {
    phase: "ROLL_ACTION", // ROLL_ACTION | SPENDING | AVOID | REROLL | END_TURN | GAME_OVER
    activePlayer: 0,
    timeTokens: 7,
    players,
    buddyFlight,
    badnikDeck,
    badnikDiscard: [],
    pendingBadnikReward: null,
    powerUpDeck,
    powerUpDiscard: [],
    chaosEmeraldDeck,
    zone,
    actBoard,
    ui: { spend: null, discard: null, starPost: null },
    pendingPowerUp: null,
    pendingPowerUpQueue: [],
    pendingDamage: null,
    pendingWallClimb: null,
    pendingAvoid: null,
    pendingBonusStage: null,
    bonusStage,
    zoneId: zoneConfig.id,
    log: [`Game started (${playerCount}P), seed="${seedStr}"`]
  };
  resetBuddyFlightForTurn(state);
  return state;
}

/* =======================
   Core rules: damage / hazard / badnik draw
   ======================= */
function takeDamage(state, reason) {
  const p = state.players[state.activePlayer];

  if (p.invulnerable) {
    log(state, `No damage (invulnerable): ${reason}`);
    return state;
  }

  if (p.shield) {
    const shieldType = p.shield.type;
    p.shield = null;
    if (shieldType === "blue") p.blueShieldLostThisTurn = true;
    addPowerUpToDiscard(state, getShieldPowerUpId(shieldType));
    log(state, `${p.name} ignores damage with ${getShieldLabel(shieldType)} (shield discarded).`);
    return state;
  }

  if (p.invincibleTokens > 0 && p.dicePool.length > 0) {
    clearSpendUi(state);
    clearDiscardUi(state);
    clearStarPostUi(state);
    state.pendingDamage = {
      reason,
      selectedDieId: null,
      resumePhase: state.phase,
      resetAfterReroll: state.phase === "REROLL"
    };
    log(state, `${p.name} may discard a die to ignore damage (Invincible).`);
    return state;
  }

  return applyDamage(state, reason);
}

function applyDamage(state, reason) {
  const p = state.players[state.activePlayer];
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);

  const heldBefore = p.heldRings;
  if (heldBefore > 0 && p.hyperRing) {
    const kept = Math.ceil(heldBefore / 2);
    const lost = heldBefore - kept;
    p.heldRings = kept;
    log(state, `DAMAGE (${reason}): Hyper Ring keeps ${kept} Held Rings (lost ${lost}).`);
  } else {
    p.heldRings = 0;
    if (heldBefore > 0) {
      log(state, `DAMAGE (${reason}): ${p.name} loses all Held Rings (${heldBefore}).`);
    }
  }

  if (heldBefore === 0) {
    p.lives -= 1;
    log(state, `DAMAGE (${reason}): No held rings -> ${p.name} loses 1 Life (now ${p.lives}).`);
    if (p.hyperRing) {
      p.hyperRing = false;
      addPowerUpToDiscard(state, "hyper_ring");
      log(state, `${p.name} loses Hyper Ring after losing a Life.`);
    }
  }

  // Clear badniks and dice pool, end turn without time token
  if (p.badniks.length) {
    state.badnikDiscard.push(...p.badniks);
  }
  p.badniks = [];
  p.dicePool = [];
  p.selectedDieId = null;
  p.spentSinceLastReroll = 0;
  p.hasRerolledThisTurn = false;
  p.propellerTailBonusGivenSinceReroll = false;
  p.lastChainSpendRule = null;
  clearInvinciblePowerUps(state, p, "turn end");
  p.flameShieldArmed = false;
  p.lightningShieldArmed = false;
  state.pendingDamage = null;

  makeInvulnerable(p);
  state.phase = "END_TURN";

  const over = isGameOver(state);
  if (over) {
    state.phase = "GAME_OVER";
    log(state, `GAME OVER: ${over}`);
  } else {
    log(state, "Turn ends immediately (no Time Token taken).");
  }
  return state;
}

function hazardRoll(state, count = 1) {
  const p = state.players[state.activePlayer];
  const rolls = [];
  const total = Math.max(1, count || 1);
  for (let i = 0; i < total; i++) rolls.push(rollD6());
  log(state, `Hazard dice rolled (x${total}): ${rolls.join(", ")}`);
  const poolValues = new Set(p.dicePool.map(d => d.value));
  const matchedValues = [...new Set(rolls.filter(v => poolValues.has(v)))];
  if (matchedValues.length) {
    takeDamage(state, `Hazard matched a die value (${matchedValues.join(", ")})`);
  } else {
    log(state, "Hazard did not match Dice Pool -> no damage.");
  }
}

function drawBadnik(state, targetPlayer) {
  const p = targetPlayer;
  if (p.badniks.length >= 3) { log(state, `${p.name} cannot draw more Badniks (already 3).`); return; }
  if (!state.badnikDeck.length) {
    state.badnikDeck = shuffle(state.badnikDiscard);
    state.badnikDiscard = [];
    log(state, `Badnik deck reshuffled from discard.`);
  }
  const b = state.badnikDeck.shift();
  p.badniks.push(b);
  log(state, `${p.name} draws Badnik: ${b.name}`);
}

function getEligibleBadnikTargets(state) {
  return state.players.filter(pl => pl.badniks.length < 3);
}

function queueBadnikRewardChoice(state, count = 1) {
  for (let i = 0; i < count; i++) {
    const eligible = getEligibleBadnikTargets(state);
    if (!eligible.length) {
      log(state, "Badnik reward: no eligible players can draw (all at 3).");
      continue;
    }
    if (state.players.length === 1) {
      drawBadnik(state, eligible[0]);
      log(state, "Badnik reward: solo game -> extra Badnik assigned to the only player.");
      continue;
    }
    if (!state.pendingBadnikReward) {
      state.pendingBadnikReward = { remaining: 0 };
    }
    state.pendingBadnikReward.remaining += 1;
    log(state, "Badnik reward: choose a player with fewer than 3 Badniks to draw.");
  }
}

function resolveBadnikRewardChoice(state, targetPlayerId) {
  const pending = state.pendingBadnikReward;
  if (!pending) return;
  const target = state.players.find(pl => pl.id === targetPlayerId);
  if (!target) return;
  if (target.badniks.length >= 3) {
    log(state, `${target.name} cannot draw more Badniks (already 3).`);
    return;
  }
  drawBadnik(state, target);
  pending.remaining -= 1;
  if (pending.remaining <= 0) {
    state.pendingBadnikReward = null;
    return;
  }
  if (!getEligibleBadnikTargets(state).length) {
    log(state, "Badnik reward: no eligible players can draw (all at 3).");
    state.pendingBadnikReward = null;
  }
}

function queuePowerUp(state, powerUpId) {
  state.pendingPowerUpQueue.push(powerUpId);
  log(state, `Power Up queued: ${getPowerUpLabel(powerUpId)}.`);
}

function processQueuedPowerUps(state) {
  if (state.pendingPowerUp || !state.pendingPowerUpQueue.length) return;
  const next = state.pendingPowerUpQueue.shift();
  applyPowerUp(state, next);
}

function applyPowerUp(state, powerUpId) {
  const p = state.players[state.activePlayer];
  if (powerUpId === "super_ring") {
    p.heldRings += 5;
    log(state, `Power Up: Super Ring (+5 Rings). Held=${p.heldRings}`);
    return;
  }
  if (powerUpId === "hyper_ring") {
    p.hyperRing = true;
    removePowerUpFromDiscard(state, powerUpId);
    log(state, "Power Up: Hyper Ring (keep half held Rings when damaged).");
    return;
  }
  if (powerUpId === "power_sneakers") {
    p.boost += 2;
    log(state, `Power Up: Power Sneakers (+2 Boost). Boost=${p.boost}`);
    return;
  }
  if (powerUpId === "one_up") {
    if (state.pendingPowerUp) return queuePowerUp(state, powerUpId);
    state.pendingPowerUp = { kind: "one_up" };
    log(state, "Power Up: 1-Up. Choose a die color to add to your Dice Pool.");
    return;
  }
  if (powerUpId === "invincible") {
    p.invincibleTokens += 1;
    removePowerUpFromDiscard(state, powerUpId);
    log(state, "Power Up: Invincible (discard a die to ignore damage this turn).");
    return;
  }
  if (powerUpId === "eggman_mark") {
    if (state.pendingPowerUp) return queuePowerUp(state, powerUpId);
    state.pendingPowerUp = { kind: "eggman_mark" };
    log(state, "Power Up: Eggman Mark. Choose a player to receive a Badnik.");
    return;
  }
  if (isShieldPowerUp(powerUpId)) {
    const newShield = getShieldTypeFromPowerUp(powerUpId);
    if (!p.shield) {
      p.shield = { type: newShield };
      removePowerUpFromDiscard(state, powerUpId);
      log(state, `Power Up: ${getShieldLabel(newShield)} equipped.`);
      return;
    }
    if (state.pendingPowerUp) return queuePowerUp(state, powerUpId);
    state.pendingPowerUp = { kind: "shield_swap", newShield };
    log(state, `${p.name} drew ${getShieldLabel(newShield)} but already has ${getShieldLabel(p.shield.type)}.`);
    return;
  }
  log(state, `Unknown Power Up: ${powerUpId}`);
}

function resolveEggmanMark(state, targetPlayerId) {
  const target = state.players.find(pl => pl.id === targetPlayerId);
  if (!target) return;
  drawBadnik(state, target);
  state.pendingPowerUp = null;
  processQueuedPowerUps(state);
}

function resolveOneUp(state, color) {
  const p = state.players[state.activePlayer];
  const pending = state.pendingPowerUp;
  if (!pending || pending.kind !== "one_up") return;
  const d = makeDie(color, rollD6());
  p.dicePool.push(d);
  log(state, `${p.name} gains a ${color.toUpperCase()} die from 1-Up (${d.value}).`);
  state.pendingPowerUp = null;
  processQueuedPowerUps(state);
}

function resolveShieldSwap(state, keepCurrent) {
  const p = state.players[state.activePlayer];
  const pending = state.pendingPowerUp;
  if (!pending || pending.kind !== "shield_swap") return;
  if (keepCurrent) {
    log(state, `${p.name} keeps ${getShieldLabel(p.shield.type)} and discards ${getShieldLabel(pending.newShield)}.`);
  } else {
    log(state, `${p.name} swaps to ${getShieldLabel(pending.newShield)} (discarded ${getShieldLabel(p.shield.type)}).`);
    addPowerUpToDiscard(state, getShieldPowerUpId(p.shield.type));
    p.shield = { type: pending.newShield };
    removePowerUpFromDiscard(state, getShieldPowerUpId(pending.newShield));
  }
  state.pendingPowerUp = null;
  processQueuedPowerUps(state);
}

function maybeApplyLightningShield(state, reward) {
  const p = state.players[state.activePlayer];
  if (!p.shield || p.shield.type !== "lightning") return reward;
  if (!p.lightningShieldArmed || p.oncePerTurn.lightningShieldUsed) return reward;
  p.lightningShieldArmed = false;
  p.oncePerTurn.lightningShieldUsed = true;
  const amount = reward.type === "rings" ? reward.amount * 2 : 2;
  log(state, `${p.name} Lightning Shield: reward changed to rings x2 (${amount}).`);
  return { type:"rings", amount };
}

function confirmInvincibleDiscard(state) {
  const p = state.players[state.activePlayer];
  const pending = state.pendingDamage;
  if (!pending || !pending.selectedDieId) return;
  const idx = p.dicePool.findIndex(d => d.id === pending.selectedDieId);
  if (idx < 0) return;
  const removed = p.dicePool.splice(idx, 1)[0];
  if (p.selectedDieId === removed.id) p.selectedDieId = null;
  p.invincibleTokens = Math.max(0, p.invincibleTokens - 1);
  state.pendingDamage = null;
  log(state, `${p.name} uses Invincible: discards ${removed.color.toUpperCase()}-${removed.value} to ignore damage.`);
  if (pending.resetAfterReroll) {
    p.spentSinceLastReroll = 0;
    p.propellerTailBonusGivenSinceReroll = false;
    p.lastChainSpendRule = null;
    state.phase = "SPENDING";
  } else if (pending.resumePhase) {
    state.phase = pending.resumePhase;
  }
}

function declineInvincible(state) {
  const pending = state.pendingDamage;
  if (!pending) return;
  state.pendingDamage = null;
  applyDamage(state, pending.reason);
}

function applyReward(state, reward) {
  const p = state.players[state.activePlayer];
  if (!reward) return;
  const effectiveReward = maybeApplyLightningShield(state, reward);
  if (effectiveReward.type === "rings") {
    p.heldRings += effectiveReward.amount;
    log(state, `Reward: +${effectiveReward.amount} Rings (Held=${p.heldRings})`);
  } else if (effectiveReward.type === "boost") {
    p.boost += effectiveReward.amount;
    log(state, `Reward: +${effectiveReward.amount} Boost (Boost=${p.boost})`);
  } else if (effectiveReward.type === "badnik") {
    for (let i=0;i<effectiveReward.amount;i++) {
      drawBadnik(state, p);
      queueBadnikRewardChoice(state, 1);
    }
  } else if (effectiveReward.type === "hazard") {
    hazardRoll(state, effectiveReward.amount);
  } else if (effectiveReward.type === "lose_die") {
    queueLoseDieReward(state, "reward");
  } else if (effectiveReward.type === "star_post") {
    queueStarPostReward(state, "reward");
  } else if (effectiveReward.type === "big_ring") {
    queueBonusStage(state, "Big Ring reward");
  } else if (effectiveReward.type === "power_up") {
    const powerUpId = effectiveReward.powerUp || drawPowerUp(state);
    if (!powerUpId) return;
    if (effectiveReward.powerUp) {
      if (!state.powerUpDiscard) state.powerUpDiscard = [];
      state.powerUpDiscard.push(powerUpId);
    }
    if (state.pendingPowerUp) {
      queuePowerUp(state, powerUpId);
    } else {
      applyPowerUp(state, powerUpId);
    }
  }
}

function completeZoneCard(state, route) {
  const card = route.activeCard;
  if (!card) return;
  if (card.challenges.some(ch => !ch.cleared)) return;

  const p = state.players[state.activePlayer];
  p.zoneCardsCompleted = (p.zoneCardsCompleted || 0) + 1;
  log(state, `${p.name} completed a Zone Card on ${route.name} Route (total ${p.zoneCardsCompleted}).`);

  const actReward = getActBoardReward(state, route.name);
  if (actReward) {
    applyReward(state, actReward);
    log(state, `Act Board reward for ${route.name} Route: ${formatRewardLabel(actReward)}.`);
  }

  if (state.zone.deck.length) {
    route.activeCard = state.zone.deck.shift();
    log(state, `New Zone Card dealt to ${route.name} Route. (${state.zone.deck.length} left)`);
  } else {
    route.activeCard = null;
    state.zone.bossFightReady = true;
    log(state, "Zone Card Deck empty -> Boss Fight should begin (not implemented).");
  }
}

function clearSpendUi(state) {
  if (state?.ui) state.ui.spend = null;
}

function clearDiscardUi(state) {
  if (state?.ui) state.ui.discard = null;
}

function clearStarPostUi(state) {
  if (state?.ui) state.ui.starPost = null;
}

function startAvoidPhase(state, reason) {
  state.pendingAvoid = { reason };
  state.phase = "AVOID";
  log(state, `AVOID: ${reason}`);
}

function resolveAvoidTakeDamage(state) {
  const pending = state.pendingAvoid;
  if (!pending) return state;
  state.pendingAvoid = null;
  return takeDamage(state, pending.reason);
}

function resolveAvoidBoost(state) {
  const p = getActivePlayer(state);
  if (!state.pendingAvoid) return state;
  if (p.boost <= 0) {
    log(state, `${p.name} has no Boost tokens to avoid damage.`);
    return state;
  }
  p.boost -= 1;
  log(state, `${p.name} spends 1 Boost to avoid damage and reroll the Dice Pool.`);
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);
  state.pendingAvoid = null;
  state.phase = "REROLL";
  return rerollStep(state);
}

function resolveAvoidBubble(state) {
  const p = getActivePlayer(state);
  if (!state.pendingAvoid) return state;
  if (!p.shield || p.shield.type !== "bubble") {
    log(state, "Bubble Shield not available.");
    return state;
  }
  if (p.oncePerTurn.bubbleShieldUsed) {
    log(state, "Bubble Shield already used this turn.");
    return state;
  }
  const target = p.dicePool.find(d => d.id === p.selectedDieId) || (p.dicePool.length === 1 ? p.dicePool[0] : null);
  if (!target) {
    log(state, `${p.name} Bubble Shield: select a die to reroll.`);
    return state;
  }
  target.value = rollD6();
  p.oncePerTurn.bubbleShieldUsed = true;
  log(state, `${p.name} Bubble Shield rerolls ${target.color.toUpperCase()}-${target.value}.`);
  state.pendingAvoid = null;
  state.phase = "SPENDING";
  return state;
}

function formatRewardLabel(reward) {
  if (!reward) return "none";
  if (reward.type === "lose_die") return "lose die";
  if (reward.type === "star_post") return "star post";
  if (reward.type === "big_ring") return "big ring";
  if (reward.type === "power_up") return "power up";
  if (reward.amount != null) return `${reward.type} x${reward.amount}`;
  return `${reward.type}`;
}

function formatRewardDisplayHtml(reward) {
  if (!reward) return "none";
  if (reward.type === "power_up") {
    return `<span class="reward-icon" title="power up"><img src="img/power_up.png" alt="Power Up"></span>`;
  }
  if (reward.type === "boost") {
    return `<span class="reward-icon" title="boost"><img src="img/boost.png" alt="Boost"></span>`;
  }
  if (reward.type === "star_post") {
    return `<span class="reward-icon" title="star post"><img src="img/star_post.png" alt="Star Post"></span>`;
  }
  return formatRewardLabel(reward);
}

function formatActRewardHtml(reward) {
  if (!reward) return `<div class="act-reward-circle"><span class="act-reward-text">NONE</span></div>`;
  if (reward.type === "big_ring") {
    return `
      <div class="act-reward-circle">
        <img src="img/big_ring.png" alt="Big Ring">
      </div>
    `;
  }
  if (reward.type === "rings") {
    const amount = reward.amount ?? 1;
    const ringSrc = amount === 2 ? "img/ring_2.png" : amount === 3 ? "img/ring_3.png" : amount === 4 ? "img/ring_4.png" : "img/ring.png";
    return `
      <div class="act-reward-circle">
        <img src="${ringSrc}" alt="Rings">
      </div>
    `;
  }
  if (reward.type === "power_up") {
    return `
      <div class="act-reward-circle">
        <img src="img/power_up.png" alt="Power Up">
      </div>
    `;
  }
  if (reward.type === "badnik") {
    return `
      <div class="act-reward-circle">
        <img src="img/badnik.png" alt="Badnik">
      </div>
    `;
  }
  if (reward.type === "boost") {
    return `
      <div class="act-reward-circle">
        <img src="img/boost.png" alt="Boost">
      </div>
    `;
  }
  if (reward.type === "star_post") {
    return `
      <div class="act-reward-circle">
        <div class="reward-inner-mask">
          <img class="reward-star-post" src="img/star_post.png" alt="Star Post">
        </div>
      </div>
    `;
  }
  if (reward.type === "badnik") {
    return `<div class="act-reward-circle"><span class="act-reward-text">BADNIK</span></div>`;
  }
  if (reward.type === "hazard") {
    const amount = reward.amount ?? 1;
    if (amount === 1) {
      return `
        <div class="act-reward-circle">
          <img src="img/dice_black.png" alt="Hazard Die">
        </div>
      `;
    }
    const label = `HAZARD x${amount}`;
    return `<div class="act-reward-circle"><span class="act-reward-text">${label}</span></div>`;
  }
  if (reward.type === "lose_die") {
    return `
      <div class="act-reward-circle">
        <img src="img/lose_die.png" alt="Lose Die">
      </div>
    `;
  }
  return `<div class="act-reward-circle"><span class="act-reward-text">${escapeHtml(formatRewardLabel(reward))}</span></div>`;
}

function getActBoardReward(state, routeName) {
  const route = state?.actBoard?.routes?.find(r => r.name === routeName);
  return route?.reward || null;
}

function queueLoseDieReward(state, reason) {
  const p = getActivePlayer(state);
  if (!state.ui) state.ui = { spend: null, discard: null, starPost: null };
  if (state.ui.discard?.open) {
    log(state, `Lose a die (${reason}): discard already pending.`);
    return;
  }
  if (!p.dicePool.length) {
    log(state, `Lose a die (${reason}): no dice in pool.`);
    return;
  }
  if (p.dicePool.length === 1) {
    const removed = p.dicePool.pop();
    log(state, `Lose a die (${reason}): discarded ${removed.color.toUpperCase()}-${removed.value}.`);
    p.selectedDieId = null;
    return;
  }
  state.ui.discard = {
    open: true,
    reason,
    selectedDieId: null,
    postSpend: null
  };
  log(state, `Lose a die (${reason}): choose a die to discard.`);
}

function queueStarPostReward(state, reason) {
  const p = getActivePlayer(state);
  if (!state.ui) state.ui = { spend: null, discard: null, starPost: null };
  if (state.ui.starPost?.open) {
    log(state, `Star Post (${reason}): choice already pending.`);
    return;
  }
  if (p.heldRings <= 0) {
    log(state, `Star Post (${reason}): no held rings to save.`);
    return;
  }
  state.ui.starPost = {
    open: true,
    reason,
    postSpend: null
  };
  log(state, `Star Post (${reason}): choose to save all held rings or keep them held.`);
}

function getBumperLock(card, groupId) {
  if (!card) return null;
  if (!card.bumperLocks) card.bumperLocks = {};
  const value = card.bumperLocks[groupId];
  return value == null ? null : value;
}

function formatChallengeRequirement(ch, card) {
  if (!ch) return "NONE";
  const colorPrefix = ch.color ? `${ch.color.toUpperCase()}-` : "";
  if (ch.bumper) {
    const lock = getBumperLock(card, ch.bumper.id);
    return `${colorPrefix}BUMP-${lock == null ? "ANY" : lock}`;
  }
  const value = ch.n != null ? ch.n : "ANY";
  return `${colorPrefix || "ANY-"}${value}`;
}

function getChallengeColorClass(ch) {
  if (ch?.color === DieColor.BLUE) return "req-blue";
  if (ch?.color === DieColor.YELLOW) return "req-yellow";
  if (ch?.color === DieColor.RED) return "req-red";
  return "req-any";
}

function formatChallengeChip(ch, card) {
  const cls = getChallengeColorClass(ch);
  if (ch?.bumper) {
    const lock = getBumperLock(card, ch.bumper.id);
    const tip = lock == null ? "Bumper: any value" : `Bumper locked to ${lock}`;
    return `<span class="req-chip ${cls}" title="${tip}"><img src="img/bumper.png" alt="Bumper"></span>`;
  }
  if (ch?.n != null) {
    return `<span class="req-chip ${cls}"><img src="img/${ch.n}.png" alt="${ch.n}"></span>`;
  }
  return `<span class="req-chip ${cls}">ANY</span>`;
}

function isDieLegalForChallenge(ch, card, die) {
  if (!ch || !die) return false;
  if (ch.color && ch.color !== die.color) return false;
  if (ch.bumper) {
    if (ch.bumper.index === 0) return true;
    const lock = getBumperLock(card, ch.bumper.id);
    return lock != null && lock === die.value;
  }
  return ch.n === die.value;
}

function applyBumperLock(ch, card, die) {
  if (!ch?.bumper || !card) return;
  if (!card.bumperLocks) card.bumperLocks = {};
  const lock = card.bumperLocks[ch.bumper.id];
  if (lock == null && ch.bumper.index === 0) {
    card.bumperLocks[ch.bumper.id] = die.value;
  }
}

function getBuddyFlightValue(state) {
  return Math.max(0, Number(state?.buddyFlight?.value) || 0);
}

function getBuddyFlightDeltaRange(buddyValue, baseValue) {
  const safeBase = Math.max(1, Math.min(6, Number(baseValue) || 1));
  const available = Math.max(0, Number(buddyValue) || 0);
  if (!available) return { min: 0, max: 0 };
  const min = -Math.min(available, safeBase - 1);
  const max = Math.min(available, 6 - safeBase);
  return { min, max };
}

function clampBuddyFlightDelta(buddyValue, baseValue, delta) {
  const range = getBuddyFlightDeltaRange(buddyValue, baseValue);
  const desired = Math.trunc(delta) || 0;
  return Math.max(range.min, Math.min(range.max, desired));
}

function getBuddyFlightCandidateDeltas(buddyValue, baseValue) {
  const range = getBuddyFlightDeltaRange(buddyValue, baseValue);
  const maxAbs = Math.max(Math.abs(range.min), Math.abs(range.max));
  const deltas = [];
  for (let step = 1; step <= maxAbs; step++) {
    if (-step >= range.min) deltas.push(-step);
    if (step <= range.max) deltas.push(step);
  }
  return deltas;
}

function getEffectiveSpendDie(state, p, die, options = {}) {
  const amyEligible = p.character === "Amy" && die.color === DieColor.RED;
  const useAmyRaise = amyEligible && !!options.useAmyRaise;
  const raisedValue = useAmyRaise ? ((die.value % 6) + 1) : die.value;

  const buddyValue = getBuddyFlightValue(state);
  const buddyFlightDelta = clampBuddyFlightDelta(buddyValue, raisedValue, options.buddyFlightDelta);
  const buddyAdjustedValue = Math.max(1, Math.min(6, raisedValue + buddyFlightDelta));
  const buddyAdjustedDie = { ...die, value: buddyAdjustedValue };

  const canUseFlame = p.shield?.type === "flame" && !p.oncePerTurn.flameShieldUsed;
  const wantsFlame = options.useFlameShieldOverride ?? p.flameShieldArmed;
  const useFlameShield = canUseFlame && wantsFlame && buddyAdjustedDie.color !== DieColor.RED;
  const effectiveDie = useFlameShield ? { ...buddyAdjustedDie, color: DieColor.RED } : buddyAdjustedDie;
  return {
    effectiveDie,
    useFlameShield,
    useAmyRaise,
    buddyFlightDelta,
    buddyFlightBaseValue: raisedValue,
    buddyFlightAdjustedValue: buddyAdjustedValue,
    buddyFlightAvailable: buddyValue > 0
  };
}

function refreshSpendTargets(state, die) {
  const spendUi = state.ui?.spend;
  if (!spendUi || !die) return false;
  const p = getActivePlayer(state);
  const { effectiveDie, buddyFlightDelta } = getEffectiveSpendDie(state, p, die, {
    useFlameShieldOverride: spendUi.useFlameShield,
    useAmyRaise: spendUi.amyRaise,
    buddyFlightDelta: spendUi.buddyFlightDelta
  });
  const targets = buildSpendTargets(state, effectiveDie);
  spendUi.targets = targets;
  spendUi.selectedTargetId = targets[0]?.id || null;
  spendUi.buddyFlightDelta = buddyFlightDelta;
  return targets.length > 0;
}

function buildSpendTargets(state, die) {
  const p = getActivePlayer(state);
  const targets = [];

  for (const route of state.zone.routes) {
    const card = route.activeCard;
    const ch = card?.challenges.find(x=>!x.cleared);
    if (!ch) continue;
    if (isDieLegalForChallenge(ch, card, die)) {
      const rewardLabel = formatRewardLabel(ch.reward);
      const reqLabel = formatChallengeRequirement(ch, card);
      const label = `Zone: ${route.name} ${reqLabel} (reward: ${rewardLabel})`;
      targets.push({
        id: uuid(),
        type: "zone",
        routeId: route.id,
        challengeId: ch.id,
        label
      });
    }
  }

  for (let i=0;i<p.badniks.length;i++) {
    const b = p.badniks[i];
    const avoidOk = b.avoid && (b.avoid.color === die.color && b.avoid.value === die.value);
    const destroyOk = b.destroy && (die.color === DieColor.RED && b.destroy.value === die.value);
    if (avoidOk) {
      targets.push({
        id: uuid(),
        type: "badnik",
        badnikIndex: i,
        mode: "avoid",
        label: `Badnik: avoid ${b.name} (${b.avoid.color[0].toUpperCase()}${b.avoid.value})`
      });
    }
    if (destroyOk) {
      targets.push({
        id: uuid(),
        type: "badnik",
        badnikIndex: i,
        mode: "destroy",
        label: `Badnik: destroy ${b.name} (R${b.destroy.value})`
      });
    }
  }

  return targets;
}

function openSpendUiForDie(state, die) {
  if (!state.ui) state.ui = { spend: null, discard: null, starPost: null };
  const p = getActivePlayer(state);
  const base = getEffectiveSpendDie(state, p, die, { useAmyRaise: false, buddyFlightDelta: 0 });
  let targets = buildSpendTargets(state, base.effectiveDie);
  let buddyFlightDelta = base.buddyFlightDelta;
  if (!targets.length && base.buddyFlightAvailable) {
    const deltas = getBuddyFlightCandidateDeltas(getBuddyFlightValue(state), base.buddyFlightBaseValue);
    for (const delta of deltas) {
      const adjusted = getEffectiveSpendDie(state, p, die, { useAmyRaise: false, buddyFlightDelta: delta });
      const adjustedTargets = buildSpendTargets(state, adjusted.effectiveDie);
      if (adjustedTargets.length) {
        targets = adjustedTargets;
        buddyFlightDelta = adjusted.buddyFlightDelta;
        break;
      }
    }
  }
  if (!targets.length) return false;
  state.ui.spend = {
    open: true,
    dieId: die.id,
    targets,
    selectedTargetId: targets[0].id,
    useFlameShield: base.useFlameShield,
    amyRaise: false,
    buddyFlightDelta
  };
  return true;
}

function preselectSpendTarget(state, targetInfo) {
  const p = getActivePlayer(state);
  if (state.phase !== "SPENDING") return log(state, "Cannot select spend target outside SPENDING.");
  if (state.bonusStage?.open) return log(state, "Finish the Bonus Stage before selecting a spend target.");
  if (state.ui?.discard?.open) return log(state, "Resolve the discard before selecting a spend target.");
  if (state.ui?.starPost?.open) return log(state, "Resolve the Star Post before selecting a spend target.");
  if (state.pendingPowerUp || state.pendingDamage || state.pendingBadnikReward || state.pendingWallClimb || state.pendingAvoid) {
    return log(state, "Resolve the pending reward before selecting a target.");
  }
  const die = p.dicePool.find(d => d.id === p.selectedDieId) || p.dicePool[0];
  if (!die) return log(state, "Select a die before targeting.");

  if (!openSpendUiForDie(state, die)) {
    return log(state, "No legal spend targets for that die.");
  }

  const spendUi = state.ui?.spend;
  if (!spendUi) return state;

  let match = null;
  if (targetInfo.type === "zone") {
    match = spendUi.targets.find(t =>
      t.type === "zone" &&
      t.routeId === targetInfo.routeId &&
      t.challengeId === targetInfo.challengeId
    );
  } else if (targetInfo.type === "badnik") {
    const candidates = spendUi.targets.filter(t =>
      t.type === "badnik" && t.badnikIndex === targetInfo.badnikIndex
    );
    if (targetInfo.mode) {
      match = candidates.find(t => t.mode === targetInfo.mode);
    }
    if (!match) {
      match = candidates.find(t => t.mode === "destroy") || candidates[0];
    }
  }

  if (!match) {
    return log(state, "That target is not legal for the selected die.");
  }

  spendUi.selectedTargetId = match.id;
  return state;
}

/* =======================
   Roll Action lookup
   ======================= */
function getActivePlayer(state){ return state.players[state.activePlayer]; }
function getCharCfg(p){ return CONFIG.characters[p.character]; }
function getRollActionCfg(p){
  const c = getCharCfg(p);
  return c.rollActions.find(r=>r.name===p.chosenRollAction) || c.rollActions[0];
}

function rollWallClimbBatch() {
  return [
    makeDie(DieColor.RED, rollD6()),
    makeDie(DieColor.RED, rollD6()),
    makeDie(DieColor.RED, rollD6())
  ];
}

function startWallClimb(state, p) {
  p.dicePool = [];
  p.selectedDieId = null;
  state.pendingWallClimb = {
    rollIndex: 1,
    remaining: 3,
    lastSaved: 0,
    batch: rollWallClimbBatch(),
    selectedIds: []
  };
  state.phase = "WALL_CLIMB";
  log(state, `${p.name} Wall Climb roll 1: ${state.pendingWallClimb.batch.map(d=>`R${d.value}`).join(" ")}. Choose dice to save (> ${state.pendingWallClimb.lastSaved}).`);
}

function confirmWallClimbSelection(state, saveNone = false) {
  const p = getActivePlayer(state);
  const pending = state.pendingWallClimb;
  if (!pending) return;
  if (saveNone) pending.selectedIds = [];
  const selected = pending.batch.filter(d => pending.selectedIds.includes(d.id));
  const values = selected.map(d => d.value).sort((a, b) => a - b);
  let valid = values.every(v => v > pending.lastSaved);
  for (let i = 1; i < values.length; i++) {
    if (values[i] <= values[i - 1]) valid = false;
  }
  if (!valid) {
    log(state, "Wall Climb: selection must be strictly increasing and above the last saved die.");
    return;
  }
  if (selected.length) {
    p.dicePool.push(...selected);
    pending.lastSaved = values[values.length - 1];
    log(state, `${p.name} Wall Climb: saved ${selected.map(d=>`R${d.value}`).join(" ")}.`);
  } else {
    log(state, `${p.name} Wall Climb: saved no dice.`);
  }
  pending.remaining -= 1;
  if (pending.remaining > 0) {
    pending.rollIndex += 1;
    pending.batch = rollWallClimbBatch();
    pending.selectedIds = [];
    log(state, `${p.name} Wall Climb roll ${pending.rollIndex}: ${pending.batch.map(d=>`R${d.value}`).join(" ")}. Choose dice to save (> ${pending.lastSaved}).`);
    return;
  }
  state.pendingWallClimb = null;
  state.phase = "SPENDING";
  makeVulnerable(p);
  log(state, `${p.name} Dice Pool built: ${p.dicePool.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);
}

/* =======================
   Build dice pool (dashboard-accurate)
   ======================= */
function buildDicePool(state) {
  if (state.phase !== "ROLL_ACTION") return log(state, `Cannot build pool: phase=${state.phase}`);

  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);

  const p = getActivePlayer(state);
  if (!p.rollActionSelectedThisTurn) {
    return log(state, `${p.name} must select a Roll Action before building the Dice Pool.`);
  }
  p.oncePerTurn = {};                 // refresh "once per turn" flags
  p.spentSinceLastReroll = 0;
  p.hasRerolledThisTurn = false;
  p.propellerTailBonusGivenSinceReroll = false;
  p.lastChainSpendRule = null;

  const ra = getRollActionCfg(p);

  p.dicePool = [];
  p.selectedDieId = null;

  function rollBatch(diceSpec) {
    const out = [];
    for (const [color, count] of Object.entries(diceSpec)) {
      for (let i=0;i<count;i++) out.push(makeDie(color, rollD6()));
    }
    return out;
  }

  if (ra.buildMode === "repeatUntilPair") {
    // Roll the action dice repeatedly, add all rolled dice, stop once any pair of values matches in pool.
    let safety = 4;
    while (safety-- > 0) {
      const batch = rollBatch(ra.dice);
      p.dicePool.push(...batch);
      const counts = new Map();
      let hasPair = false;
      for (const d of p.dicePool) {
        counts.set(d.value, (counts.get(d.value)||0)+1);
        if (counts.get(d.value) >= 2) { hasPair = true; break; }
      }
      log(state, `${p.name} Spin Dash roll: ${batch.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")} → pool size ${p.dicePool.length}`);
      if (hasPair) { log(state, `Spin Dash condition met: at least one matching pair exists in Dice Pool.`); break; }
    }
  }
  else if (ra.buildMode === "tailsFlyX2") {
    // x2: each time roll 4 yellows; save matching pairs else save any 1; discard rest.
    for (let rep=1; rep<=2; rep++) {
      const batch = rollBatch(ra.dice); // 4 yellows
      const byVal = new Map();
      for (const d of batch) byVal.set(d.value, (byVal.get(d.value)||[]).concat([d]));
      const pairs = [];
      for (const [val, arr] of byVal.entries()) {
        if (arr.length >= 2) pairs.push(...arr.slice(0,2));
      }
      if (pairs.length > 0) {
        p.dicePool.push(...pairs);
        log(state, `${p.name} Fly (x${rep}): rolled ${batch.map(d=>`Y${d.value}`).join(" ")} → saved pairs ${pairs.map(d=>`Y${d.value}`).join(" ")}.`);
      } else {
        // save any 1 die (choose highest to be practical)
        batch.sort((a,b)=>b.value-a.value);
        p.dicePool.push(batch[0]);
        log(state, `${p.name} Fly (x${rep}): rolled ${batch.map(d=>`Y${d.value}`).join(" ")} → no pairs; saved one die Y${batch[0].value}.`);
      }
    }
  }
    else if (ra.buildMode === "knucklesWallClimbX3") {
    // x3: each repeat roll 3 reds; player chooses which dice to save (strictly increasing).
    startWallClimb(state, p);
    return state;
  }
else {
    // Standard: roll once, add all dice
    const batch = rollBatch(ra.dice);
    p.dicePool.push(...batch);
    log(state, `${p.name} rolled: ${batch.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);
  }

  // Apply any ROLL effect after building pool
  if (typeof ra.onBuildPool === "function") {
    ra.onBuildPool({ state, p });
  }

  makeVulnerable(p); // unless damage happened previously
  state.phase = "SPENDING";
  log(state, `${p.name} Dice Pool built: ${p.dicePool.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);
  return state;
}

/* =======================
   Boost after Roll Action
   ======================= */
function boostAfterRollAction(state) {
  const p = getActivePlayer(state);
  if (p.boost <= 0) return log(state, `${p.name} has no Boost tokens.`);
  if (state.phase !== "SPENDING" || p.dicePool.length === 0) return log(state, `Boost-after-roll-action must be used right after building a Dice Pool.`);

  p.boost -= 1;
  log(state, `${p.name} spends 1 Boost (after Roll Action): reroll Dice Pool and enter REROLL step (Badnik-vulnerable).`);
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);
  state.phase = "REROLL";
  return rerollStep(state);
}

/* =======================
   Spending
   ======================= */
function spendSelectedDie(state) {
  const p = getActivePlayer(state);
  if (state.phase !== "SPENDING") return log(state, `Cannot spend: phase=${state.phase}`);
  if (state.bonusStage?.open) return log(state, "Finish the Bonus Stage before spending.");
  if (state.pendingPowerUp || state.pendingDamage || state.pendingBadnikReward || state.pendingWallClimb || state.pendingAvoid) {
    return log(state, "Resolve the pending reward before spending.");
  }

  if (!p.dicePool.length) { state.phase = "END_TURN"; return log(state, `No dice left → End Turn`); }

  const die = p.dicePool.find(d => d.id === p.selectedDieId) || p.dicePool[0];

  if (!openSpendUiForDie(state, die)) {
    const canSpendAny = p.dicePool.some(candidate => {
      const base = getEffectiveSpendDie(state, p, candidate, { useAmyRaise: false, buddyFlightDelta: 0 });
      if (buildSpendTargets(state, base.effectiveDie).length > 0) return true;
      if (!base.buddyFlightAvailable) return false;
      const deltas = getBuddyFlightCandidateDeltas(getBuddyFlightValue(state), base.buddyFlightBaseValue);
      return deltas.some(delta => {
        const adjusted = getEffectiveSpendDie(state, p, candidate, { useAmyRaise: false, buddyFlightDelta: delta });
        return buildSpendTargets(state, adjusted.effectiveDie).length > 0;
      });
    });
    if (canSpendAny) {
      clearSpendUi(state);
      return log(state, "Selected die has no legal targets. Choose another die to spend.");
    }
    clearSpendUi(state);
    startAvoidPhase(state, "No legal spend available");
    return state;
  }
  return state;
}

function confirmSpendSelection(state) {
  const p = getActivePlayer(state);
  const spendUi = state.ui?.spend;
  if (state.phase !== "SPENDING") { clearSpendUi(state); return state; }
  if (!spendUi || !spendUi.open) return state;

  const die = p.dicePool.find(d => d.id === spendUi.dieId);
  if (!die) {
    log(state, "Spend canceled: selected die is no longer available.");
    clearSpendUi(state);
    return state;
  }

  const target = spendUi.targets.find(t => t.id === spendUi.selectedTargetId);
  if (!target) {
    log(state, "Spend canceled: no target selected.");
    clearSpendUi(state);
    return state;
  }

  const spendMeta = {
    useFlameShield: spendUi.useFlameShield,
    amyRaise: spendUi.amyRaise,
    buddyFlightDelta: spendUi.buddyFlightDelta
  };
  clearSpendUi(state);
  return spendDieOnTarget(state, die, target, spendMeta);
}

function cancelSpendSelection(state) {
  clearSpendUi(state);
  return state;
}

function finalizePostSpend(state, spentDie, ra) {
  const p = getActivePlayer(state);
  if (!spentDie) return state;

  if (!p.dicePool.length) { state.phase = "END_TURN"; return log(state, "Dice Pool empty -> End Turn"); }

  if (spentDie.color === DieColor.BLUE) {
    log(state, `Run die property: ${p.name} may spend another die without rerolling.`);
    state.phase = "SPENDING";
    return state;
  }

  if (p.lastChainSpendRule?.color === DieColor.YELLOW && ra?.name === "Glide") {
    const canChain = p.dicePool.some(d => d.color === DieColor.YELLOW && d.value < p.lastChainSpendRule.lastSpentValue);
    if (canChain) {
      log(state, `Knuckles Glide (SPEND): may spend another YELLOW without reroll if it is lower than last spent (${p.lastChainSpendRule.lastSpentValue}).`);
      state.phase = "SPENDING";
      return state;
    }
  }

  state.phase = "REROLL";
  log(state, "Must REROLL remaining dice before next spend.");
  return state;
}

function confirmDiscardSelection(state) {
  const p = getActivePlayer(state);
  const discardUi = state.ui?.discard;
  if (!discardUi?.open) return state;
  const die = p.dicePool.find(d => d.id === discardUi.selectedDieId);
  if (!die) {
    log(state, "Discard canceled: no die selected.");
    return state;
  }

  p.dicePool = p.dicePool.filter(d => d.id !== die.id);
  p.selectedDieId = null;
  log(state, `Lose a die (${discardUi.reason}): discarded ${die.color.toUpperCase()}-${die.value}.`);

  const post = discardUi.postSpend;
  clearDiscardUi(state);
  if (post?.spentDieColor) {
    const ra = getRollActionCfg(p);
    return finalizePostSpend(state, { color: post.spentDieColor }, ra);
  }
  return state;
}

function confirmStarPostSave(state) {
  const p = getActivePlayer(state);
  const starUi = state.ui?.starPost;
  if (!starUi?.open) return state;

  const savedNow = p.heldRings;
  p.heldRings = 0;
  p.savedRings += savedNow;
  log(state, `Star Post (${starUi.reason}): saved ${savedNow} Rings (Saved=${p.savedRings}).`);
  const triggerBonusStage = savedNow >= 5;

  const post = starUi.postSpend;
  clearStarPostUi(state);
  let outState = state;
  if (post?.spentDieColor) {
    const ra = getRollActionCfg(p);
    outState = finalizePostSpend(state, { color: post.spentDieColor }, ra);
  }
  if (triggerBonusStage) {
    queueBonusStage(outState, "Star Post saved 5+ Rings");
  }
  return outState;
}

function confirmStarPostKeep(state) {
  const p = getActivePlayer(state);
  const starUi = state.ui?.starPost;
  if (!starUi?.open) return state;
  log(state, `Star Post (${starUi.reason}): kept ${p.heldRings} Rings held.`);
  const post = starUi.postSpend;
  clearStarPostUi(state);
  if (post?.spentDieColor) {
    const ra = getRollActionCfg(p);
    return finalizePostSpend(state, { color: post.spentDieColor }, ra);
  }
  return state;
}

function spendDieOnTarget(state, die, target, spendMeta) {
  const p = getActivePlayer(state);
  const ra = getRollActionCfg(p);
  const {
    effectiveDie,
    useFlameShield,
    useAmyRaise,
    buddyFlightDelta,
    buddyFlightBaseValue,
    buddyFlightAdjustedValue
  } = getEffectiveSpendDie(state, p, die, {
    useFlameShieldOverride: spendMeta?.useFlameShield,
    useAmyRaise: spendMeta?.amyRaise,
    buddyFlightDelta: spendMeta?.buddyFlightDelta
  });
  let spendTarget = null;
  let challengeReward = null;
  let completedRoute = null;
  let spendLabel = `${die.color.toUpperCase()}-${die.value}`;
  if (useAmyRaise) {
    spendLabel += ` (Piko Piko Hammer -> ${buddyFlightBaseValue})`;
  }
  if (buddyFlightDelta) {
    const deltaLabel = buddyFlightDelta > 0 ? `+${buddyFlightDelta}` : `${buddyFlightDelta}`;
    spendLabel += ` (Buddy Flight ${deltaLabel} -> ${buddyFlightAdjustedValue})`;
  }

  if (target.type === "zone") {
    const route = state.zone.routes.find(r => r.id === target.routeId);
    const card = route?.activeCard;
    const ch = card?.challenges.find(c => c.id === target.challengeId);
    const next = card?.challenges.find(x => !x.cleared);
    const legal = ch && isDieLegalForChallenge(ch, card, effectiveDie);
    if (!route || !ch || !next || next.id !== ch.id || !legal) {
      log(state, "Spend failed: zone target no longer legal.");
      return state;
    }
    ch.cleared = true;
    applyBumperLock(ch, card, effectiveDie);
    spendTarget = { type:"zone", route: route.name, challengeId: ch.id };
    const reqLabel = formatChallengeRequirement(ch, card);
    log(state, `${p.name} spends ${spendLabel} to clear ${route.name} challenge (${reqLabel}).`);
    challengeReward = ch.reward;
    completedRoute = route;
  } else if (target.type === "badnik") {
    const b = p.badniks[target.badnikIndex];
    if (!b) {
      log(state, "Spend failed: badnik target no longer exists.");
      return state;
    }
    const avoidOk = b.avoid && (b.avoid.color === effectiveDie.color && b.avoid.value === effectiveDie.value);
    const destroyOk = b.destroy && (effectiveDie.color === DieColor.RED && b.destroy.value === effectiveDie.value);
    if (target.mode === "avoid" && !avoidOk) {
      log(state, "Spend failed: avoid target no longer legal.");
      return state;
    }
    if (target.mode === "destroy" && !destroyOk) {
      log(state, "Spend failed: destroy target no longer legal.");
      return state;
    }
    spendTarget = { type:"badnik", name: b.name, mode: target.mode };
    if (target.mode === "destroy") {
      p.animalTokens += 1;
      log(state, `${p.name} DESTROYS Badnik "${b.name}" with ${spendLabel} -> gained 1 Animal Token (total ${p.animalTokens}).`);
    } else {
      log(state, `${p.name} AVOIDS Badnik "${b.name}" with ${spendLabel}.`);
    }
    p.badniks.splice(target.badnikIndex, 1);
    state.badnikDiscard.push(b);
  } else {
    return state;
  }

  // Remove die from pool
  p.dicePool = p.dicePool.filter(d => d.id !== die.id);
  p.selectedDieId = null;

  // Spending ends invulnerability window
  makeVulnerable(p);

  // Update counters for "since last reroll"
  p.spentSinceLastReroll += 1;

  if (buddyFlightDelta) {
    const spendAmount = Math.abs(buddyFlightDelta);
    if (state.buddyFlight) {
      const before = state.buddyFlight.value;
      state.buddyFlight.value = Math.max(0, before - spendAmount);
      log(state, `Buddy Flight: spent ${spendAmount} (die ${before} -> ${state.buddyFlight.value}).`);
      if (state.buddyFlight.value === 0) {
        log(state, "Buddy Flight die removed (0).");
      }
    }
  }

  if (ra.name === "Propeller Tail" && !p.hasRerolledThisTurn && p.spentSinceLastReroll >= 2 && !p.propellerTailBonusGivenSinceReroll) {
    const bonusDie = makeDie(DieColor.YELLOW, rollD6());
    p.dicePool.push(bonusDie);
    p.propellerTailBonusGivenSinceReroll = true;
    log(state, `Tails Propeller Tail (SPEND): spent>=2 after initial roll -> gained a YELLOW die (${bonusDie.value}).`);
  }

  // Core dice properties (from rulebook)
  const spentDie = { ...die, value: effectiveDie.value };

  if (spentDie.color === DieColor.YELLOW) {
    p.heldRings += 1;
    log(state, `Jump die property: +1 Ring (Held=${p.heldRings}).`);
  }

  if (useFlameShield) {
    p.oncePerTurn.flameShieldUsed = true;
    p.flameShieldArmed = false;
    log(state, `${p.name} Flame Shield: spent die treated as RED.`);
  }

  // Apply roll-action SPEND effect hooks
  if (typeof ra.onSpend === "function") {
    const spentDieForEffects = useFlameShield ? { ...spentDie, color: DieColor.RED } : spentDie;
    ra.onSpend({ state, p, spentDie: spentDieForEffects, spendTarget });
  }

  // Knuckles Glide chaining rule: if the action specifies a chain rule, set it up for potential extra spend.
  if (ra.onSpendChainRule && spentDie.color === ra.onSpendChainRule.color) {
    p.lastChainSpendRule = { ...ra.onSpendChainRule, lastSpentValue: spentDie.value };
  } else {
    p.lastChainSpendRule = null;
  }

  if (challengeReward) applyReward(state, challengeReward);
  if (completedRoute) completeZoneCard(state, completedRoute);
  if (state.ui?.discard?.open) {
    state.ui.discard.postSpend = { spentDieColor: spentDie.color };
    return state;
  }
  if (state.ui?.starPost?.open) {
    state.ui.starPost.postSpend = { spentDieColor: spentDie.color };
    return state;
  }
  if (state.phase === "END_TURN" || state.phase === "GAME_OVER") return state;
  return finalizePostSpend(state, spentDie, ra);
}

/* =======================
   Reroll step
   ======================= */
function rerollStep(state) {
  const p = getActivePlayer(state);
  const canRerollNow = state.phase === "REROLL" || (state.phase === "SPENDING" && p.spentSinceLastReroll > 0);
  if (!canRerollNow) return log(state, `Cannot reroll: phase=${state.phase}`);
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);
  if (!p.dicePool.length) { state.phase = "END_TURN"; return log(state, `No dice to reroll → End Turn`); }

  const ra = getRollActionCfg(p);
  p.hasRerolledThisTurn = true;

  // Apply REROLL effects at the beginning of the reroll step
  if (typeof ra.onRerollStepStart === "function") {
    ra.onRerollStepStart({ state, p });
  }

  // Reroll all remaining dice
  for (const d of p.dicePool) d.value = rollD6();
  log(state, `${p.name} rerolls Dice Pool: ${p.dicePool.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);

  // Reroll ends invulnerability
  makeVulnerable(p);

  // Badnik attacks: if any rerolled die matches an attack, take damage.
  if (p.badniks.length) {
    const hits = [];
    for (const b of p.badniks) {
      for (const atk of (b.attacks||[])) {
        const hit = atk.color
          ? p.dicePool.some(d => d.color === atk.color && d.value === atk.value)
          : p.dicePool.some(d => d.value === atk.value);
        if (hit) hits.push({ b, atk });
      }
    }
    if (hits.length) {
      log(state, `🟥 Badnik attack hits: ${hits.map(h=>`${h.b.name}(${h.atk.color ? h.atk.color[0].toUpperCase() : "ANY"}${h.atk.value})`).join(", ")}`);
      takeDamage(state, "Badnik attack");
      if (state.pendingDamage || state.phase !== "REROLL") return state;
    } else {
      log(state, `No Badnik attacks hit.`);
    }
  } else {
    log(state, `No Badniks in front of ${p.name}.`);
  }

  // Reset counters after a reroll happens
  p.spentSinceLastReroll = 0;
  p.propellerTailBonusGivenSinceReroll = false;
  p.lastChainSpendRule = null;

  state.phase = "SPENDING";
  return state;
}

function boostInReroll(state) {
  const p = getActivePlayer(state);
  if (state.phase !== "REROLL") return log(state, `Boost-in-reroll only usable in REROLL phase.`);
  if (p.boost <= 0) return log(state, `${p.name} has no Boost tokens.`);
  p.boost -= 1;
  log(state, `${p.name} spends 1 Boost → immediately reroll Dice Pool again.`);
  return rerollStep(state);
}

/* =======================
   End turn
   ======================= */
function endTurn(state) {
  const p = getActivePlayer(state);
  if (state.phase === "GAME_OVER") return state;
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);

  // If dice remain and player ends normally → discard + take time
  if (p.dicePool.length) {
    p.dicePool = [];
    p.selectedDieId = null;
    if (p.blueShieldLostThisTurn) {
      log(state, `${p.name} ends turn with dice remaining but avoids taking a Time Token (Blue Shield).`);
    } else {
      state.timeTokens -= 1;
      p.timeTokensTaken += 1;
      log(state, `${p.name} ends turn with dice remaining -> discard dice and take 1 Time Token (Time left: ${state.timeTokens}).`);
    }
  } else {
    log(state, `${p.name} ends turn.`);
  }

  makeVulnerable(p);
  p.spentSinceLastReroll = 0;
  p.lastChainSpendRule = null;
  clearInvinciblePowerUps(state, p, "turn end");
  p.flameShieldArmed = false;
  p.lightningShieldArmed = false;
  p.blueShieldLostThisTurn = false;
  state.pendingDamage = null;

  const over = isGameOver(state);
  if (over) {
    state.phase = "GAME_OVER";
    log(state, `🛑 GAME OVER: ${over}`);
    return state;
  }

  state.activePlayer = (state.activePlayer + 1) % state.players.length;
  const np = getActivePlayer(state);
  np.oncePerTurn = {};
  np.rollActionSelectedThisTurn = false;
  state.phase = "ROLL_ACTION";
  log(state, `➡️ Turn passes to ${np.name} (${np.character}).`);
  resetBuddyFlightForTurn(state);
  return state;
}

/* =======================
   UI
   ======================= */
let STATE = null;

function escapeHtml(str) {
  return str.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}

function buildRollActionDiceHint(diceSpec) {
  if (!diceSpec) return "none";
  const order = [
    { key: "blue", src: "img/dice_blue.png" },
    { key: "red", src: "img/dice_red.png" },
    { key: "yellow", src: "img/dice_yellow.png" }
  ];
  let out = "";
  for (const item of order) {
    const count = diceSpec[item.key] || 0;
    if (count > 0) {
      for (let i = 0; i < count; i++) {
        out += `<img class="dice-hint-icon" src="${item.src}" alt="${item.key} die">`;
      }
    }
  }
  return out || "none";
}

function getBadnikDisplayLabels(b) {
  const attacksLabel = (b.attacks || [])
    .map(a => `${a.color ? a.color[0].toUpperCase() : "ANY"}${a.value ?? ""}`)
    .join(", ") || "none";
  const avoidLabel = b.avoid
    ? `${b.avoid.color ? b.avoid.color[0].toUpperCase() : "ANY"}${b.avoid.value ?? ""}`
    : "none";
  const destroyColor = b.destroy?.color ? b.destroy.color[0].toUpperCase() : "R";
  const destroyLabel = b.destroy ? `${destroyColor}${b.destroy.value ?? ""}` : "none";
  return { attacksLabel, avoidLabel, destroyLabel };
}

function getTimeBonusPoints(playerCount, place) {
  const table = {
    2: { 1: 100, 2: 0 },
    3: { 1: 150, 2: 50, 3: 0 },
    4: { 1: 200, 2: 100, 3: 50, 4: 0 }
  };
  return table[playerCount]?.[place] ?? 0;
}

function getSoloTimePoints(timeTokensTaken) {
  if (timeTokensTaken <= 0) return 200;
  if (timeTokensTaken <= 2) return 100;
  if (timeTokensTaken <= 4) return 50;
  return 0;
}

function getRingPoints(p) {
  const heldValue = p.hyperRing ? 15 : 10;
  return (p.heldRings * heldValue) + (p.savedRings * 10);
}

function getAnimalPoints(p) {
  return p.animalTokens * 20;
}

function getLifeLossPoints(p) {
  const startingLives = 3;
  const lost = Math.max(0, startingLives - p.lives);
  return lost * -30;
}

function getChaosEmeraldPoints(p) {
  const counts = getChaosCounts(p);
  return (counts.ready * 50) + (counts.spent * 20);
}

function computeTimeScores(state) {
  const entries = state.players.map(p => ({
    id: p.id,
    name: p.name,
    character: p.character,
    speed: (p.zoneCardsCompleted * 3) - p.timeTokensTaken
  }));

  if (entries.length <= 1) {
    return entries.map(e => ({
      ...e,
      place: null,
      points: getSoloTimePoints(state.players[0]?.timeTokensTaken ?? 0)
    }));
  }

  entries.sort((a, b) => b.speed - a.speed);
  let rank = 1;
  let i = 0;
  while (i < entries.length) {
    let j = i + 1;
    while (j < entries.length && entries[j].speed === entries[i].speed) j++;
    const groupSize = j - i;
    const assignedPlace = rank + groupSize - 1;
    const points = getTimeBonusPoints(entries.length, assignedPlace);
    for (let k = i; k < j; k++) {
      entries[k].place = assignedPlace;
      entries[k].points = points;
    }
    rank += groupSize;
    i = j;
  }
  return entries;
}

function computeScoreSummary(state) {
  const timeScores = computeTimeScores(state);
  const timeById = new Map(timeScores.map(entry => [entry.id, entry]));
  return state.players.map(p => {
    const timeEntry = timeById.get(p.id);
    const ringPoints = getRingPoints(p);
    const animalPoints = getAnimalPoints(p);
    const lifePoints = getLifeLossPoints(p);
    const chaosPoints = getChaosEmeraldPoints(p);
    const timePoints = timeEntry?.points ?? 0;
    return {
      id: p.id,
      name: p.name,
      character: p.character,
      speed: timeEntry?.speed ?? null,
      place: timeEntry?.place ?? null,
      timePoints,
      ringPoints,
      animalPoints,
      lifePoints,
      chaosPoints,
      totalPoints: timePoints + ringPoints + animalPoints + lifePoints + chaosPoints
    };
  });
}

function render() {
  const s = STATE;
  if (!s) return;

  if (s.pendingBonusStage && !s.bonusStage?.open && canStartBonusStage(s)) {
    const reason = s.pendingBonusStage.reasons.shift();
    if (!s.pendingBonusStage.reasons.length) s.pendingBonusStage = null;
    enterBonusStage(s, reason);
  }

  const p = getActivePlayer(s);
  const ra = getRollActionCfg(p);
  const chaosCounts = getChaosCounts(p);

  const controlsCard = document.getElementById("controlsCard");
  if (controlsCard) controlsCard.dataset.character = p.character;
  const characterHeading = document.getElementById("characterHeading");
  if (characterHeading) {
    const label = `${p.name} — ${p.character}`;
    characterHeading.innerHTML = `
      <span>${escapeHtml(label)}</span>
      <span class="badge badge-tight">Lives ${p.lives} | Boost ${p.boost} | Held ${p.heldRings} | Saved ${p.savedRings} | Animals ${p.animalTokens} | Time Taken ${p.timeTokensTaken} | Chaos Ready ${chaosCounts.ready} | Chaos Spent ${chaosCounts.spent}</span>
    `;
  }

  if (s.ui?.spend?.open) {
    const hasDie = p.dicePool.some(d => d.id === s.ui.spend.dieId);
    if (s.phase !== "SPENDING" || !hasDie) clearSpendUi(s);
  }
  if (s.ui?.discard?.open) {
    if (s.phase !== "SPENDING" || p.dicePool.length < 2) clearDiscardUi(s);
  }
  if (s.ui?.starPost?.open) {
    if (p.heldRings <= 0) clearStarPostUi(s);
  }
  if (s.pendingPowerUp || s.pendingDamage || s.pendingBadnikReward || s.pendingWallClimb || s.pendingAvoid || s.bonusStage?.open) {
    clearSpendUi(s);
  }

  document.getElementById("phase").textContent = s.phase;
  document.getElementById("invuln").textContent = p.invulnerable ? "YES" : "NO";

  const counters = document.getElementById("counters");
  const buddyFlightValue = s.buddyFlight?.value ?? 0;
  const buddyFlightMarkup = buddyFlightValue > 0
    ? `<div class="pill tiny"><b>Buddy Flight</b><div class="die buddy-flight">${buildDieFaceHtml(buddyFlightValue)}</div></div>`
    : "";
  counters.innerHTML = `
    <div class="pill tiny"><b>spentSinceLastReroll</b> ${p.spentSinceLastReroll}</div>
    <div class="pill tiny"><b>Roll Action</b> ${escapeHtml(ra.name)}</div>
    ${buddyFlightMarkup}
    ${p.lastChainSpendRule ? `<div class="pill tiny warn"><b>Chain rule</b> ${p.lastChainSpendRule.color.toUpperCase()} must be lower than ${p.lastChainSpendRule.lastSpentValue}</div>` : ""}
  `;

  const powerStatus = document.getElementById("powerUpStatus");
  if (powerStatus) {
    powerStatus.innerHTML = `
      <div class="pill tiny"><b>Shield</b> ${p.shield ? getShieldLabel(p.shield.type) : "None"}</div>
      <div class="pill tiny"><b>Hyper Ring</b> ${p.hyperRing ? "ON" : "OFF"}</div>
      <div class="pill tiny"><b>Invincible</b> ${p.invincibleTokens}</div>
      ${p.flameShieldArmed ? `<div class="pill tiny warn"><b>Flame Armed</b> yes</div>` : ""}
      ${p.lightningShieldArmed ? `<div class="pill tiny warn"><b>Lightning Armed</b> yes</div>` : ""}
    `;
  }

  const powerPanel = document.getElementById("powerUpPanel");
  if (powerPanel) {
    if (s.pendingAvoid) {
      const canBoost = p.boost > 0;
      const canBubble = p.shield?.type === "bubble" && !p.oncePerTurn.bubbleShieldUsed && p.dicePool.length > 0;
      powerPanel.innerHTML = `
        <div class="pill tiny warn"><b>Avoid Damage</b> ${escapeHtml(s.pendingAvoid.reason || "No legal spend available")}</div>
        <div class="row">
          <button id="avoidBoostBtn">Use Boost Token</button>
          ${canBubble ? `<button id="avoidBubbleBtn">Bubble Shield: Reroll Selected Die</button>` : ""}
          <button id="avoidDamageBtn">Take Damage</button>
        </div>
      `;
      const boostBtn = powerPanel.querySelector("#avoidBoostBtn");
      if (boostBtn) {
        boostBtn.disabled = !canBoost;
        boostBtn.addEventListener("click", () => {
          resolveAvoidBoost(STATE);
          render();
        });
      }
      const bubbleBtn = powerPanel.querySelector("#avoidBubbleBtn");
      if (bubbleBtn) {
        bubbleBtn.disabled = !canBubble;
        bubbleBtn.addEventListener("click", () => {
          resolveAvoidBubble(STATE);
          render();
        });
      }
      const dmgBtn = powerPanel.querySelector("#avoidDamageBtn");
      if (dmgBtn) {
        dmgBtn.addEventListener("click", () => {
          resolveAvoidTakeDamage(STATE);
          render();
        });
      }
    } else if (s.pendingDamage) {
      powerPanel.innerHTML = `
        <div class="pill tiny warn"><b>Invincible</b> Discard a die to ignore damage.</div>
        <div id="invincibleDice"></div>
        <div class="row">
          <button id="invincibleConfirm">Discard Selected Die</button>
          <button id="invincibleDecline">Take Damage</button>
        </div>
      `;
      const diceWrap = powerPanel.querySelector("#invincibleDice");
      for (const d of p.dicePool) {
        const el = document.createElement("div");
        el.className = `die ${d.color}` + (s.pendingDamage.selectedDieId === d.id ? " selected" : "");
        el.innerHTML = buildDieFaceHtml(d.value);
        el.title = d.color;
        el.addEventListener("click", () => {
          s.pendingDamage.selectedDieId = d.id;
          render();
        });
        diceWrap.appendChild(el);
      }
      const confirmBtn = powerPanel.querySelector("#invincibleConfirm");
      confirmBtn.disabled = !s.pendingDamage.selectedDieId;
      confirmBtn.addEventListener("click", () => {
        confirmInvincibleDiscard(STATE);
        render();
      });
      powerPanel.querySelector("#invincibleDecline").addEventListener("click", () => {
        declineInvincible(STATE);
        render();
      });
    } else if (s.pendingPowerUp) {
      if (s.pendingPowerUp.kind === "eggman_mark") {
        powerPanel.innerHTML = `
          <div class="pill tiny warn"><b>Eggman Mark</b> Choose a player to receive a Badnik.</div>
          <div id="eggmanTargets" class="row"></div>
        `;
        const targetWrap = powerPanel.querySelector("#eggmanTargets");
        for (const pl of s.players) {
          const btn = document.createElement("button");
          btn.textContent = `${pl.name} (${pl.character})`;
          btn.addEventListener("click", () => {
            resolveEggmanMark(STATE, pl.id);
            render();
          });
          targetWrap.appendChild(btn);
        }
      } else if (s.pendingPowerUp.kind === "one_up") {
        powerPanel.innerHTML = `
          <div class="pill tiny warn"><b>1-Up</b> Choose a die color to add.</div>
          <div class="row">
            <button id="oneUpBlue">Blue Die</button>
            <button id="oneUpYellow">Yellow Die</button>
            <button id="oneUpRed">Red Die</button>
          </div>
        `;
        powerPanel.querySelector("#oneUpBlue").addEventListener("click", () => {
          resolveOneUp(STATE, DieColor.BLUE);
          render();
        });
        powerPanel.querySelector("#oneUpYellow").addEventListener("click", () => {
          resolveOneUp(STATE, DieColor.YELLOW);
          render();
        });
        powerPanel.querySelector("#oneUpRed").addEventListener("click", () => {
          resolveOneUp(STATE, DieColor.RED);
          render();
        });
      } else if (s.pendingPowerUp.kind === "shield_swap") {
        const pendingShield = s.pendingPowerUp.newShield;
        powerPanel.innerHTML = `
          <div class="pill tiny warn"><b>Shield Choice</b> Keep current or swap.</div>
          <div class="tiny">Current: ${p.shield ? getShieldLabel(p.shield.type) : "None"}</div>
          <div class="tiny">New: ${getShieldLabel(pendingShield)}</div>
          <div class="row">
            <button id="shieldKeepBtn">Keep Current</button>
            <button id="shieldSwapBtn">Take New</button>
          </div>
        `;
        powerPanel.querySelector("#shieldKeepBtn").addEventListener("click", () => {
          resolveShieldSwap(STATE, true);
          render();
        });
        powerPanel.querySelector("#shieldSwapBtn").addEventListener("click", () => {
          resolveShieldSwap(STATE, false);
          render();
        });
      }
    } else if (s.pendingBadnikReward) {
      const eligible = getEligibleBadnikTargets(s);
      powerPanel.innerHTML = `
        <div class="pill tiny warn"><b>Badnik Reward</b> Choose a player to draw a Badnik.</div>
        <div class="tiny">Remaining selections: ${s.pendingBadnikReward.remaining}</div>
        <div id="badnikRewardTargets" class="row"></div>
      `;
      const targetWrap = powerPanel.querySelector("#badnikRewardTargets");
      for (const pl of eligible) {
        const btn = document.createElement("button");
        btn.textContent = `${pl.name} (${pl.character})`;
        btn.addEventListener("click", () => {
          resolveBadnikRewardChoice(STATE, pl.id);
          render();
        });
        targetWrap.appendChild(btn);
      }
    } else {
      powerPanel.innerHTML = "";
      const actions = [];
      if (p.shield && p.shield.type === "flame") {
        actions.push(`<button id="flameShieldBtn">${p.flameShieldArmed ? "Flame Shield Armed" : "Use Flame Shield"}</button>`);
      }
      if (p.shield && p.shield.type === "bubble") {
        actions.push(`<button id="bubbleShieldBtn">Bubble Shield: Reroll Selected Die</button>`);
      }
      if (p.shield && p.shield.type === "lightning") {
        actions.push(`<button id="lightningShieldBtn">${p.lightningShieldArmed ? "Lightning Armed" : "Arm Lightning Shield"}</button>`);
      }
      if (actions.length) {
        powerPanel.innerHTML = `<div class="row">${actions.join("")}</div>`;
      } else {
        powerPanel.innerHTML = `<div class="muted">No pending Power Ups.</div>`;
      }

      const flameBtn = powerPanel.querySelector("#flameShieldBtn");
      if (flameBtn) {
        flameBtn.disabled = s.phase !== "SPENDING" || p.oncePerTurn.flameShieldUsed;
        flameBtn.addEventListener("click", () => {
          p.flameShieldArmed = !p.flameShieldArmed;
          log(s, `${p.name} ${p.flameShieldArmed ? "arms" : "disarms"} Flame Shield for the next spend.`);
          render();
        });
      }

      const bubbleBtn = powerPanel.querySelector("#bubbleShieldBtn");
      if (bubbleBtn) {
        bubbleBtn.disabled = p.oncePerTurn.bubbleShieldUsed || p.dicePool.length === 0;
        bubbleBtn.addEventListener("click", () => {
          const target = p.dicePool.find(d => d.id === p.selectedDieId) || (p.dicePool.length === 1 ? p.dicePool[0] : null);
          if (!target) {
            log(s, `${p.name} Bubble Shield: select a die to reroll.`);
            return;
          }
          const newValue = rollD6();
          target.value = newValue;
          p.oncePerTurn.bubbleShieldUsed = true;
          log(s, `${p.name} Bubble Shield rerolls ${target.color.toUpperCase()}-${newValue}.`);
          render();
        });
      }

      const lightningBtn = powerPanel.querySelector("#lightningShieldBtn");
      if (lightningBtn) {
        lightningBtn.disabled = p.oncePerTurn.lightningShieldUsed || p.lightningShieldArmed;
        lightningBtn.addEventListener("click", () => {
          p.lightningShieldArmed = true;
          log(s, `${p.name} arms Lightning Shield to change the next reward to rings x2.`);
          render();
        });
      }
    }
  }

  const chaosPanel = document.getElementById("chaosEmeraldPanel");
  if (chaosPanel) {
    const emeralds = p.chaosEmeralds || [];
    if (!emeralds.length) {
      chaosPanel.textContent = "No Chaos Emeralds.";
    } else {
      const chaosBlocked = !!s.ui?.discard?.open || !!s.ui?.starPost?.open ||
        s.pendingPowerUp || s.pendingDamage || s.pendingBadnikReward || s.pendingWallClimb || s.bonusStage?.open;
      chaosPanel.innerHTML = `<div class="chaos-emerald-list"></div>`;
      const list = chaosPanel.querySelector(".chaos-emerald-list");
      emeralds.forEach(card => {
        const cardEl = document.createElement("div");
        cardEl.className = `chaos-emerald-card ${card.spent ? "spent" : ""}`;
        cardEl.innerHTML = `
          <img src="${card.img}" alt="${escapeHtml(getChaosEmeraldLabel(card))}">
          <div>${escapeHtml(getChaosEmeraldLabel(card))}</div>
        `;
        if (!card.spent) {
          const canSpend = Array.isArray(card.diceBonusColors) && card.diceBonusColors.length === 2;
          const btn = document.createElement("button");
          btn.textContent = canSpend ? "Spend" : "Spend (TBD)";
          btn.disabled = chaosBlocked || !canSpend;
          btn.addEventListener("click", () => {
            spendChaosEmerald(STATE, card.id);
            render();
          });
          cardEl.appendChild(btn);
        } else {
          const tag = document.createElement("div");
          tag.className = "muted";
          tag.textContent = "Spent";
          cardEl.appendChild(tag);
        }
        list.appendChild(cardEl);
      });
    }
  }

  // Buttons
  const dis = (id, v) => document.getElementById(id).disabled = !!v;
  const discardOpen = !!s.ui?.discard?.open;
  const starPostOpen = !!s.ui?.starPost?.open;
  const powerOpen = !!s.pendingPowerUp;
  const damageOpen = !!s.pendingDamage;
  const badnikRewardOpen = !!s.pendingBadnikReward;
  const wallClimbOpen = !!s.pendingWallClimb;
  const bonusStageOpen = !!s.bonusStage?.open;
  const avoidOpen = !!s.pendingAvoid;
  const actionBlocked = discardOpen || starPostOpen || powerOpen || damageOpen || badnikRewardOpen || wallClimbOpen || avoidOpen || bonusStageOpen;
  dis("btnBuildPool", s.phase !== "ROLL_ACTION" || actionBlocked || !p.rollActionSelectedThisTurn);
  dis("btnSpendDie", s.phase !== "SPENDING" || !p.dicePool.length || actionBlocked);
  const canOptionalReroll = s.phase === "SPENDING" && p.spentSinceLastReroll > 0 && p.dicePool.length > 0;
  dis("btnRerollStep", !(s.phase === "REROLL" || canOptionalReroll) || actionBlocked);
  const canUseBoost =
    (s.phase === "SPENDING" && p.boost > 0 && p.dicePool.length > 0);
  dis("btnUseBoostToken", !canUseBoost || actionBlocked);
  dis("btnEndTurn", !(s.phase==="SPENDING" || s.phase==="REROLL" || s.phase==="END_TURN") || actionBlocked);
  dis("btnForceBonusStage", bonusStageOpen);

  // Roll action buttons
  const raWrap = document.getElementById("rollActionButtons");
  raWrap.innerHTML = "";
  for (const a of getCharCfg(p).rollActions) {
    const btn = document.createElement("button");
    const hint = buildRollActionDiceHint(a.dice);
    btn.className = `roll-action-btn ${p.rollActionSelectedThisTurn && p.chosenRollAction === a.name ? "active" : ""}`;
    btn.innerHTML = `
      <div class="roll-action-icon">${hint === "none" ? "" : hint}</div>
      <div>${escapeHtml(a.name)}</div>
    `;
    btn.disabled = s.phase !== "ROLL_ACTION" || actionBlocked;
    btn.addEventListener("click", () => {
      p.chosenRollAction = a.name;
      p.rollActionSelectedThisTurn = true;
      log(s, `${p.name} set Roll Action to: ${p.chosenRollAction}`);
      render();
    });
    raWrap.appendChild(btn);
  }
  // Dice pool
  const dp = document.getElementById("dicePool");
  dp.innerHTML = "";
  const discardUi = s.ui?.discard;
  const selectedDieId = discardUi?.open ? discardUi.selectedDieId : p.selectedDieId;
  for (const d of p.dicePool) {
    const el = document.createElement("div");
    el.className = `die ${d.color}` + (selectedDieId === d.id ? " selected" : "");
    el.innerHTML = buildDieFaceHtml(d.value);
    el.title = d.color;
    el.addEventListener("click", () => {
      if (damageOpen || powerOpen || badnikRewardOpen || wallClimbOpen || avoidOpen || bonusStageOpen) return;
      if (discardUi?.open) {
        discardUi.selectedDieId = d.id;
      } else {
        p.selectedDieId = d.id;
      }
      render();
    });
    dp.appendChild(el);
  }

  // Wall Climb panel
  const wallSection = document.getElementById("wallClimbSection");
  const wallPanel = document.getElementById("wallClimbPanel");
  const pendingWall = s.pendingWallClimb;
  if (wallPanel) {
    if (!pendingWall) {
      if (wallSection) wallSection.style.display = "none";
      wallPanel.textContent = "";
    } else {
      if (wallSection) wallSection.style.display = "";
      const lastLabel = pendingWall.lastSaved > 0 ? pendingWall.lastSaved : "-";
      wallPanel.innerHTML = `
        <div class="pill tiny">Roll ${pendingWall.rollIndex}/3 | Last Saved ${lastLabel}</div>
        <div id="wallClimbDice" class="row"></div>
        <div class="row target-actions">
          <button id="wallClimbConfirm">Save Selected Dice</button>
          <button id="wallClimbSaveNone">Save None</button>
        </div>
      `;
      const diceWrap = wallPanel.querySelector("#wallClimbDice");
      for (const d of pendingWall.batch) {
        const disabled = d.value <= pendingWall.lastSaved;
        const selected = pendingWall.selectedIds.includes(d.id);
        const el = document.createElement("div");
        el.className = `die ${d.color}` + (selected ? " selected" : "") + (disabled ? " disabled" : "");
        el.innerHTML = buildDieFaceHtml(d.value);
        el.title = d.color;
        el.addEventListener("click", () => {
          if (disabled) return;
          if (pendingWall.selectedIds.includes(d.id)) {
            pendingWall.selectedIds = pendingWall.selectedIds.filter(id => id !== d.id);
          } else {
            pendingWall.selectedIds.push(d.id);
          }
          render();
        });
        diceWrap.appendChild(el);
      }
      const selectedDice = pendingWall.batch.filter(d => pendingWall.selectedIds.includes(d.id));
      const values = selectedDice.map(d => d.value).sort((a, b) => a - b);
      let valid = values.every(v => v > pendingWall.lastSaved);
      for (let i = 1; i < values.length; i++) {
        if (values[i] <= values[i - 1]) valid = false;
      }
      const confirmBtn = wallPanel.querySelector("#wallClimbConfirm");
      const saveNoneBtn = wallPanel.querySelector("#wallClimbSaveNone");
      confirmBtn.disabled = !valid;
      confirmBtn.addEventListener("click", () => {
        confirmWallClimbSelection(STATE);
        render();
      });
      saveNoneBtn.addEventListener("click", () => {
        confirmWallClimbSelection(STATE, true);
        render();
      });
    }
  }

  // Discard panel
  const discardSection = document.getElementById("discardSection");
  const discardPanel = document.getElementById("discardPanel");
  if (discardPanel) {
    if (!discardUi || !discardUi.open) {
      if (discardSection) discardSection.style.display = "none";
      discardPanel.textContent = "";
    } else {
      if (discardSection) discardSection.style.display = "";
      const selected = p.dicePool.find(d => d.id === discardUi.selectedDieId);
      const label = selected ? `${selected.color.toUpperCase()}-${selected.value}` : "Select a die to discard.";
      discardPanel.innerHTML = `
        <div class="pill tiny">Discard: ${label}</div>
        <div class="row target-actions">
          <button id="btnConfirmDiscard">Discard Selected Die</button>
        </div>
      `;
      const btn = discardPanel.querySelector("#btnConfirmDiscard");
      if (btn) {
        btn.disabled = !selected;
        btn.addEventListener("click", () => { confirmDiscardSelection(STATE); render(); });
      }
    }
  }

  // Star Post panel
  const starPostSection = document.getElementById("starPostSection");
  const starPostPanel = document.getElementById("starPostPanel");
  const starUi = s.ui?.starPost;
  if (starPostPanel) {
    if (!starUi || !starUi.open) {
      if (starPostSection) starPostSection.style.display = "none";
      starPostPanel.textContent = "";
    } else {
      if (starPostSection) starPostSection.style.display = "";
      starPostPanel.innerHTML = `
        <div class="pill tiny">Held Rings: ${p.heldRings}</div>
        <div class="row target-actions">
          <button id="btnStarPostSave">Save All Rings</button>
          <button id="btnStarPostKeep">Keep Held Rings</button>
        </div>
      `;
      const btnSave = starPostPanel.querySelector("#btnStarPostSave");
      const btnKeep = starPostPanel.querySelector("#btnStarPostKeep");
      if (btnSave) btnSave.addEventListener("click", () => { confirmStarPostSave(STATE); render(); });
      if (btnKeep) btnKeep.addEventListener("click", () => { confirmStarPostKeep(STATE); render(); });
    }
  }

  // Spend target selection
  const spendPanel = document.getElementById("spendTargetPanel");
  const spendUi = s.ui?.spend;
  if (!spendUi || !spendUi.open) {
    spendPanel.textContent = `Select a die and click "Spend Selected Die" to choose a target. Tip: click a Zone/Badnik card to preselect.`;
  } else {
    const die = p.dicePool.find(d => d.id === spendUi.dieId);
    const dieLabel = die ? `${die.color.toUpperCase()}-${die.value}` : "Unknown";
    const canAmyRaise = p.character === "Amy" && die && die.color === DieColor.RED;
    const buddyFlightValue = s.buddyFlight?.value ?? 0;
    const buddyFlightAvailable = buddyFlightValue > 0 && !!die;
    const buddyInfo = buddyFlightAvailable ? getEffectiveSpendDie(s, p, die, {
      useFlameShieldOverride: spendUi.useFlameShield,
      useAmyRaise: spendUi.amyRaise,
      buddyFlightDelta: spendUi.buddyFlightDelta
    }) : null;
    const buddyDeltaLabel = buddyInfo
      ? (buddyInfo.buddyFlightDelta > 0 ? `+${buddyInfo.buddyFlightDelta}` : `${buddyInfo.buddyFlightDelta}`)
      : "0";
    const buddyRange = buddyInfo ? getBuddyFlightDeltaRange(buddyFlightValue, buddyInfo.buddyFlightBaseValue) : { min: 0, max: 0 };
    spendPanel.innerHTML = `
      <div class="pill tiny">Die: ${dieLabel}</div>
      ${canAmyRaise ? `<div class="row target-actions">
        <button id="btnAmyRaise">${spendUi.amyRaise ? "Piko Piko Hammer (+1) ON" : "Use Piko Piko Hammer (+1)"}</button>
      </div>` : ""}
      ${buddyFlightAvailable ? `
        <div class="pill tiny">
          <b>Buddy Flight</b>
          <div class="die buddy-flight">${buildDieFaceHtml(buddyFlightValue)}</div>
          <span class="muted">Adjust ${buddyInfo.buddyFlightBaseValue} → ${buddyInfo.buddyFlightAdjustedValue} (${buddyDeltaLabel})</span>
        </div>
        <div class="row target-actions">
          <button id="buddyFlightDown">-1</button>
          <button id="buddyFlightReset">Reset</button>
          <button id="buddyFlightUp">+1</button>
        </div>
      ` : ""}
      <div class="target-list"></div>
      <div class="row target-actions">
        <button id="btnConfirmSpend">Confirm Spend</button>
        <button id="btnCancelSpend">Cancel</button>
      </div>
    `;
    if (canAmyRaise) {
      const btnAmy = spendPanel.querySelector("#btnAmyRaise");
      btnAmy.addEventListener("click", () => {
        spendUi.amyRaise = !spendUi.amyRaise;
        const ok = refreshSpendTargets(STATE, die);
        if (!ok) {
          log(s, "No legal spend targets with Piko Piko Hammer.");
        }
        render();
      });
    }
    if (buddyFlightAvailable) {
      const btnDown = spendPanel.querySelector("#buddyFlightDown");
      const btnUp = spendPanel.querySelector("#buddyFlightUp");
      const btnReset = spendPanel.querySelector("#buddyFlightReset");
      if (btnDown) {
        btnDown.disabled = buddyInfo.buddyFlightDelta <= buddyRange.min;
        btnDown.addEventListener("click", () => {
          spendUi.buddyFlightDelta = buddyInfo.buddyFlightDelta - 1;
          const ok = refreshSpendTargets(STATE, die);
          if (!ok) {
            log(s, "No legal spend targets with Buddy Flight adjustment.");
          }
          render();
        });
      }
      if (btnUp) {
        btnUp.disabled = buddyInfo.buddyFlightDelta >= buddyRange.max;
        btnUp.addEventListener("click", () => {
          spendUi.buddyFlightDelta = buddyInfo.buddyFlightDelta + 1;
          const ok = refreshSpendTargets(STATE, die);
          if (!ok) {
            log(s, "No legal spend targets with Buddy Flight adjustment.");
          }
          render();
        });
      }
      if (btnReset) {
        btnReset.disabled = buddyInfo.buddyFlightDelta === 0;
        btnReset.addEventListener("click", () => {
          spendUi.buddyFlightDelta = 0;
          const ok = refreshSpendTargets(STATE, die);
          if (!ok) {
            log(s, "No legal spend targets with Buddy Flight adjustment.");
          }
          render();
        });
      }
    }
    const list = spendPanel.querySelector(".target-list");
    for (const t of spendUi.targets) {
      const item = document.createElement("div");
      item.className = `target-item ${t.id === spendUi.selectedTargetId ? "selected" : ""}`;
      item.textContent = t.label;
      item.addEventListener("click", () => { spendUi.selectedTargetId = t.id; render(); });
      list.appendChild(item);
    }
    const btnConfirm = spendPanel.querySelector("#btnConfirmSpend");
    const btnCancel = spendPanel.querySelector("#btnCancelSpend");
    if (btnConfirm) {
      btnConfirm.disabled = !die || !spendUi.selectedTargetId;
      btnConfirm.addEventListener("click", () => { confirmSpendSelection(STATE); render(); });
    }
    if (btnCancel) {
      btnCancel.addEventListener("click", () => { cancelSpendSelection(STATE); render(); });
    }
  }

  // Zone view
  const zv = document.getElementById("zoneView");
  zv.innerHTML = "";
  const zoneHeader = document.getElementById("zoneHeaderInfo");
  if (zoneHeader) {
    const deckRemaining = s.zone?.deck?.length ?? 0;
    const actName = s.actBoard?.name || "Act 1";
    zoneHeader.innerHTML = `
      <div class="zone-level-name">
        <span class="zone-title">${escapeHtml(actName)}</span>
        <span class="zone-deck">Deck ${deckRemaining}</span>
      </div>
    `;
  }
  const actBoardView = document.getElementById("actBoardView");
  if (actBoardView) {
    const routes = ["Top","Middle","Bottom"].map(name => ({
      name,
      reward: getActBoardReward(s, name)
    }));
    actBoardView.innerHTML = `
      <div class="act-board-lanes">
        ${routes.map(route => `
          <div class="act-lane">
            <div class="act-lane-arrow"></div>
            ${formatActRewardHtml(route.reward)}
          </div>
        `).join("")}
      </div>
    `;
  }
  for (const route of s.zone.routes) {
    const cardData = route.activeCard;
    const next = cardData?.challenges.find(x=>!x.cleared);
    const card = document.createElement("div");
    card.className = `card zone-card ${next ? "clickable" : ""}`;
    const gradient = buildGradientCss(s.actBoard?.cardGradient);
    if (gradient) card.style.background = gradient;
    const challengeCount = cardData?.challenges?.length ?? 0;
    const evenLayout = challengeCount === 5 || challengeCount === 6;
    const trackClass = evenLayout ? "track-list track-list-even" : "track-list";
    const trackStyle = "";
    const trackHtml = cardData
      ? `<div class="${trackClass}"${trackStyle}>
          ${cardData.challenges.map(ch => {
            const req = formatChallengeChip(ch, cardData);
            const reward = formatActRewardHtml(ch.reward);
            return `<div class="track-item ${ch.cleared ? "cleared" : ""}">
              <div class="track-label">${req}</div>
              <div class="track-reward">${reward}</div>
            </div>`;
          }).join("")}
        </div>`
      : `<div class="tiny muted">No active card.</div>`;
    card.innerHTML = `
      ${trackHtml}
    `;
    if (next) {
      card.title = "Click to preselect spend target";
      card.addEventListener("click", () => {
        preselectSpendTarget(STATE, { type:"zone", routeId: route.id, challengeId: next.id });
        render();
      });
    }
    zv.appendChild(card);
  }

  // Badniks
  const bv = document.getElementById("badnikView");
  bv.innerHTML = "";
  if (!p.badniks.length) {
    bv.innerHTML = `<div class="tiny muted">No Badniks.</div>`;
  } else {
    for (let i = 0; i < p.badniks.length; i++) {
      const b = p.badniks[i];
      const labels = getBadnikDisplayLabels(b);
      const el = document.createElement("div");
      el.className = "pill tiny clickable";
      el.innerHTML = `<b>${escapeHtml(b.name)}</b>
        <span class="muted">attacks:</span> ${labels.attacksLabel}
        <span class="muted">avoid:</span> ${labels.avoidLabel}
        <span class="muted">destroy:</span> ${labels.destroyLabel}`;
      el.title = "Click to preselect spend target";
      el.addEventListener("click", () => {
        preselectSpendTarget(STATE, { type:"badnik", badnikIndex: i });
        render();
      });
      bv.appendChild(el);
    }
  }

  // Log
  const logEl = document.getElementById("log");
  logEl.innerHTML = s.log.slice(-400).map(line => `<div>${escapeHtml(line)}</div>`).join("");
  logEl.scrollTop = logEl.scrollHeight;

  // Discards
  const powerDiscardEl = document.getElementById("powerUpDiscardView");
  if (powerDiscardEl) {
    const discards = s.powerUpDiscard || [];
    powerDiscardEl.textContent = discards.length
      ? discards.map(id => getPowerUpLabel(id)).join(", ")
      : "No discarded Power Ups.";
  }
  const badnikDiscardEl = document.getElementById("badnikDiscardView");
  if (badnikDiscardEl) {
    const discards = s.badnikDiscard || [];
    badnikDiscardEl.innerHTML = discards.length
      ? discards.map(b => {
          const labels = getBadnikDisplayLabels(b);
          return `<div class="pill tiny"><b>${escapeHtml(b.name)}</b>
            <span class="muted">attacks:</span> ${labels.attacksLabel}
            <span class="muted">avoid:</span> ${labels.avoidLabel}
            <span class="muted">defeat:</span> ${labels.destroyLabel}</div>`;
        }).join("")
      : `<div class="tiny muted">No discarded Badniks.</div>`;
  }

  const timeScoreEl = document.getElementById("timeScoringView");
  if (timeScoreEl) {
    if (s.players.length <= 1) {
      const solo = computeTimeScores(s)[0];
      const summary = computeScoreSummary(s)[0];
      timeScoreEl.innerHTML = `
        <div class="muted">Solo time scoring by Time Tokens taken.</div>
        <div class="pill tiny">
          <b>${escapeHtml(solo.name)} (${escapeHtml(solo.character)})</b>
          Time Taken ${s.players[0].timeTokensTaken} | Time Points ${solo.points}
        </div>
        <div class="pill tiny">Rings Points ${summary.ringPoints} | Animal Points ${summary.animalPoints} | Chaos ${summary.chaosPoints} | Life Loss ${summary.lifePoints} | Total ${summary.totalPoints}</div>
      `;
    } else {
      const scores = computeTimeScores(s);
      const summary = computeScoreSummary(s);
      timeScoreEl.innerHTML = `
        <div class="muted">Speed = (Zone Cards x3) - (Time Tokens taken)</div>
        ${scores.map(entry => {
          const extra = summary.find(sx => sx.id === entry.id);
          return `
          <div class="pill tiny">
            <b>${escapeHtml(entry.name)} (${escapeHtml(entry.character)})</b>
            Speed ${entry.speed} | Place ${entry.place} | Time Points ${entry.points}
            | Rings ${extra?.ringPoints ?? 0} | Animals ${extra?.animalPoints ?? 0} | Chaos ${extra?.chaosPoints ?? 0} | Life ${extra?.lifePoints ?? 0} | Total ${extra?.totalPoints ?? entry.points}
          </div>
        `;
        }).join("")}
      `;
    }
  }

  const bonusModal = document.getElementById("bonusStageModal");
  if (bonusModal) {
    const stage = s.bonusStage;
    if (!stage || !stage.open) {
      bonusModal.classList.remove("open");
    } else {
      bonusModal.classList.add("open");
      const statusEl = document.getElementById("bonusStageStatus");
      const gridEl = document.getElementById("bonusStageGrid");
      const exitBtn = document.getElementById("bonusStageExit");
      const activeName = s.players[stage.activePlayerId ?? s.activePlayer]?.name || p.name;
      const remaining = stage.tiles.filter(t => !t.revealed).length;
      if (statusEl) {
        const baseMsg = stage.message || `Bonus Stage: ${activeName} is flipping tiles.`;
        statusEl.textContent = `${baseMsg} (Unflipped: ${remaining})`;
      }
      if (gridEl) {
        gridEl.innerHTML = "";
        for (const tile of stage.tiles) {
          const tileEl = document.createElement("div");
          const classes = ["bonus-tile"];
          let label = "Blue Sphere";
          let icon = "🔵";
          if (tile.revealed) {
            classes.push("revealed");
            if (tile.type === "red") {
              classes.push("red");
              label = "Red Sphere";
              icon = "🔴";
            } else if (tile.type === "bumper") {
              classes.push("bumper");
              label = "Bumper Sphere";
              icon = "⚪";
            } else if (tile.type === "chaos") {
              classes.push("chaos");
              label = "Chaos Emerald";
              icon = "💎";
            }
          }
          if (stage.awaitingExit) classes.push("disabled");
          tileEl.className = classes.join(" ");
          tileEl.title = label;
          const iconEl = document.createElement("div");
          iconEl.className = "bonus-icon";
          iconEl.textContent = icon;
          tileEl.appendChild(iconEl);
          if (tile.revealed && tile.reward) {
            const badge = document.createElement("div");
            badge.className = "bonus-reward";
            if (tile.reward.type === "rings") {
              const img = document.createElement("img");
              img.src = "img/ring.png";
              img.alt = "Ring";
              badge.appendChild(img);
            } else if (tile.reward.type === "power_up") {
              const img = document.createElement("img");
              img.src = "img/power_up.png";
              img.alt = "Power Up";
              badge.appendChild(img);
            } else if (tile.reward.type === "boost") {
              const img = document.createElement("img");
              img.src = "img/boost.png";
              img.alt = "Boost";
              badge.appendChild(img);
            } else {
              badge.textContent = formatBonusStageRewardLabel(tile.reward);
            }
            tileEl.appendChild(badge);
          }
          tileEl.addEventListener("click", () => {
            flipBonusStageTile(STATE, tile.id);
            render();
          });
          gridEl.appendChild(tileEl);
        }
      }
      if (exitBtn) {
        exitBtn.disabled = !stage.awaitingExit;
        exitBtn.textContent = stage.awaitingExit ? "Return to Zone" : "Finish Bonus Stage";
        exitBtn.onclick = () => {
          if (!stage.awaitingExit) return;
          closeBonusStage(STATE);
          render();
        };
      }
    }
  }
}

/* =======================
   UI events
   ======================= */
function openNewGameModal() {
  const modal = document.getElementById("newGameModal");
  if (modal) modal.classList.add("open");
}

function closeNewGameModal() {
  const modal = document.getElementById("newGameModal");
  if (modal) modal.classList.remove("open");
}

function generateSeed() {
  return Math.floor(Math.random() * 1000000000).toString();
}

function ensureSeedValue() {
  const seedInput = document.getElementById("seed");
  if (!seedInput) return generateSeed();
  if (!seedInput.value.trim()) seedInput.value = generateSeed();
  return seedInput.value;
}

function startNewGame({ closeModal = false } = {}) {
  const playerCount = parseInt(document.getElementById("playerCount").value, 10);
  const seedStr = ensureSeedValue();
  const characterSelections = readCharacterSelections(playerCount);
  const zoneId = readZoneSelection();
  STATE = newGame({ playerCount, seedStr, characterSelections, zoneId });
  if (closeModal) closeNewGameModal();
  render();
}

const menuWrapper = document.getElementById("menuWrapper");
const menuBtn = document.getElementById("menuBtn");
const menuDropdown = document.getElementById("menuDropdown");
const menuNewGame = document.getElementById("menuNewGame");
if (menuBtn && menuDropdown) {
  menuBtn.addEventListener("click", (event) => {
    event.stopPropagation();
    menuDropdown.classList.toggle("open");
  });
}
if (menuNewGame) {
  menuNewGame.addEventListener("click", () => {
    menuDropdown?.classList.remove("open");
    renderCharacterSelectors();
    renderZoneSelector();
    openNewGameModal();
  });
}
document.addEventListener("click", (event) => {
  if (!menuWrapper) return;
  if (!menuWrapper.contains(event.target)) {
    menuDropdown?.classList.remove("open");
  }
});

const confirmNewGameBtn = document.getElementById("confirmNewGameBtn");
if (confirmNewGameBtn) {
  confirmNewGameBtn.addEventListener("click", () => {
    startNewGame({ closeModal: true });
  });
}

const cancelNewGameBtn = document.getElementById("cancelNewGameBtn");
if (cancelNewGameBtn) {
  cancelNewGameBtn.addEventListener("click", () => {
    closeNewGameModal();
  });
}

document.getElementById("playerCount").addEventListener("change", () => {
  renderCharacterSelectors();
});

document.getElementById("btnBuildPool").addEventListener("click", () => {
  buildDicePool(STATE);
  render();
});

document.getElementById("btnUseBoostToken").addEventListener("click", () => {
  if (STATE?.phase === "REROLL") {
    boostInReroll(STATE);
  } else {
    boostAfterRollAction(STATE);
  }
  render();
});

document.getElementById("btnSpendDie").addEventListener("click", () => {
  spendSelectedDie(STATE);
  render();
});

document.getElementById("btnRerollStep").addEventListener("click", () => {
  rerollStep(STATE);
  render();
});

document.getElementById("btnEndTurn").addEventListener("click", () => {
  endTurn(STATE);
  render();
});

const forceBonusBtn = document.getElementById("btnForceBonusStage");
if (forceBonusBtn) {
  forceBonusBtn.addEventListener("click", () => {
    if (!STATE) return;
    if (STATE.pendingPowerUp || STATE.pendingDamage || STATE.pendingBadnikReward || STATE.pendingWallClimb) {
      log(STATE, "Resolve the pending reward before forcing the Bonus Stage.");
      render();
      return;
    }
    enterBonusStage(STATE, "Debug trigger");
    render();
  });
}

// Auto-start
renderCharacterSelectors();
renderZoneSelector();
ensureSeedValue();
startNewGame();
</script>
</body>
</html>

