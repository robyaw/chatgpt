<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sonic Roll - Rules Engine (Dashboards Implemented)</title>
  <style>
    :root { font-family: Jost, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body {
      margin: 16px;
      color:#e8ecff;
      background: linear-gradient(45deg, #8fbfe8 25%, transparent 25%, transparent 75%, #8fbfe8 75%, #8fbfe8),
                  linear-gradient(45deg, #8fbfe8 25%, transparent 25%, transparent 75%, #8fbfe8 75%, #8fbfe8);
      background-size: 120px 120px;
      background-position: 0 0, 60px 60px;
      background-color: #9fc7ea;
    }
    h1,h2 { margin: 8px 0; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    .card { background:#121a33; border:1px solid #23305a; border-radius:14px; padding:12px; box-shadow: 0 8px 25px rgba(0,0,0,.25); }
    .card h2 { font-size: 14px; letter-spacing:.04em; text-transform:uppercase; color:#b8c6ff; }
    .controls-card { background:#121a33; border-color:#23305a; }
    .controls-card[data-character="Sonic"] { background:#0f2347; border-color:#2a4f96; }
    .controls-card[data-character="Tails"] { background:#3a220f; border-color:#8b5b2a; }
    .controls-card[data-character="Knuckles"] { background:#3a0f12; border-color:#8a2a2a; }
    .controls-card[data-character="Amy"] { background:#351126; border-color:#7a2d53; }
    .character-heading { display:flex; flex-direction:column; align-items:flex-start; gap:4px; font-size:18px; font-weight:700; margin:0 0 6px; color:#e8ecff; }
    .character-heading-row { display:flex; align-items:center; justify-content:space-between; width:100%; gap:10px; }
    .character-heading-score { text-align:left; display:inline-flex; align-items:center; gap:6px; }
    .character-heading-score img { height:14px; width:auto; image-rendering: pixelated; }
    .score-digits { display:inline-flex; align-items:center; }
    .score-digit { height:14px; width:auto; image-rendering: pixelated; margin-left:-4px; }
    .score-digit:first-child { margin-left:0; }
    .character-heading-name { text-align:right; }
    .badge-tight { padding:2px 6px; font-size:11px; }
    button, select, input { background:#1a2550; border:1px solid #2d3b73; color:#e8ecff; padding:8px 10px; border-radius:10px; cursor:pointer; }
    button:hover { filter:brightness(1.1); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { display:inline-flex; gap:8px; padding:6px 10px; border:1px solid #2d3b73; border-radius:999px; background:#0f1733; margin:4px 4px 0 0; align-items:center; }
    .badge.buddy-flight { background:#e7c240; border-color:#caa62c; color:#2d2d2d; }
    .buddy-flight-value { font-weight:700; }
    .muted { color:#b0b8e8; }
    .log { max-height: 300px; overflow:auto; font-size: 13px; line-height:1.35; }
    .grid { display:grid; grid-template-columns: minmax(240px, 1fr); gap:10px; }
    .tiny { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .badge { font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #2d3b73; background:#0f1733; }
    .dice-pool-header { align-items:center; justify-content:space-between; }
    .dice-pool-header h2 { margin:0; }
    .dice-pool-footer { align-items:center; justify-content:space-between; }
    .chain-spend-badge { display:flex; justify-content:flex-end; flex:1; }
    .roll-action-btn { padding:8px 10px; border-radius:10px; border:1px solid #2d3b73; background:#0f1733; color:#e8ecff; cursor:pointer; display:flex; flex-direction:column; align-items:center; gap:6px; min-width:90px; }
    .roll-action-icon { display:grid; grid-template-columns: repeat(2, 16px); grid-auto-rows: 16px; gap:2px; justify-content:center; align-content:center; }
    .roll-action-icon-box {
      background:#f2c84b;
      border-radius:8px;
      padding:4px 6px;
      display:flex;
      align-items:center;
      justify-content:center;
      height:74px;
      min-height:74px;
      min-width:70px;
      box-sizing:border-box;
    }
    .roll-action-label {
      font-family: Jost, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-style: italic;
      font-weight: 700;
      text-transform: uppercase;
      font-size: 12px;
    }
    .roll-action-icon .dice-hint-icon { width:16px; height:16px; display:block; }
    .roll-action-btn.active { border-color:#7cb6ff; box-shadow: 0 0 0 2px rgba(124,182,255,.35); background:#15234a; }
    .die {
      width: 44px; height: 44px; border-radius:10px; display:inline-flex; align-items:center; justify-content:center;
      margin:4px; font-weight:700; border:1px solid transparent; background:#0f1733; color:#f7f9ff;
      user-select:none; opacity:.82; transform:scale(1);
    }
    .die.roll-shake { animation: dice-shake 0.25s ease-in-out; }
    .die.blue { background:#2f7cff; border-color:#2f7cff; outline:2px solid #2f7cff; }
    .die.yellow { background:#e7c240; border-color:#e7c240; color:#f7f9ff; outline:2px solid #e7c240; }
    .die.red { background:#ff3b30; border-color:#ff3b30; outline:2px solid #ff3b30; }
    .die.black { background:#2d2d2d; border-color:#2d2d2d; outline:2px solid #2d2d2d; }
    .pip-grid {
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      width:100%;
      height:100%;
    }
    .pip {
      width:11px;
      height:11px;
      border-radius:50%;
      background:currentColor;
      opacity:0;
      justify-self:center;
      align-self:center;
    }
    .pip.on { opacity:1; }
    .die.selected { box-shadow: 0 0 0 2px #b8c6ff; opacity:1; transform:scale(1.05); }
    .die.disabled { opacity:.35; cursor:not-allowed; }
    @keyframes dice-shake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      50% { transform: translateX(3px); }
      75% { transform: translateX(-2px); }
      100% { transform: translateX(0); }
    }
    textarea { width:100%; min-height:120px; border-radius:10px; background:#0f1733; border:1px solid #2d3b73; color:#e8ecff; padding:10px; }
    .hr { height:1px; background:#23305a; margin:10px 0; }
    .ok { color:#b8ffcf; }
    .warn { color:#ffe7a6; }
    .clickable { cursor:pointer; }
    .clickable:hover { filter:brightness(1.08); }
    .track-label.clickable:hover { filter:none; }
    .track-label.clickable:hover .req-chip { filter:brightness(1.08); }
    .target-list { display:flex; flex-direction:column; gap:6px; margin-top:6px; }
    .target-item { padding:6px 8px; border:1px solid #2d3b73; border-radius:10px; background:#0f1733; cursor:pointer; }
    .target-item.selected { outline:2px solid rgba(120,200,255,.6); background:#15234a; }
    .target-actions { margin-top:8px; }
    .track-list { display:flex; flex-wrap:wrap; gap:4px; margin-top:6px; position:relative; z-index:0; }
    .track-list-even {
      justify-content:space-between;
      gap:0;
      width:100%;
      flex-wrap:nowrap;
    }
    .track-list-even.spaces-7 {
      justify-content:space-between;
      gap:0;
    }
    .track-space {
      display:flex;
      flex-direction:column;
      align-items:stretch;
      gap:4px;
    }
    .space-reward {
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:52px;
      position:relative;
      z-index:4;
    }
    .space-reward.empty { visibility:hidden; }
    .track-item {
      border:none;
      border-radius:10px;
      background:transparent;
      padding:4px 6px;
      font-size:13px;
      display:flex;
      flex-direction:column;
      justify-content:flex-start;
      min-height:120px;
      box-sizing:border-box;
      position:relative;
      --space-bg-image: none;
    }
    .track-item::before {
      content:"";
      position:absolute;
      left:0;
      right:0;
      top:-12px;
      bottom:-12px;
      background-color:var(--zone-space-bg, #0f1733);
      background-image:var(--space-bg-image);
      background-repeat:no-repeat;
      background-position:center;
      background-size:contain;
      border:1px solid #2d3b73;
      border-radius:10px;
      z-index:0;
    }
    .track-item > * {
      position:relative;
    }
    .track-item.single {
      justify-content:center;
    }
    .track-item.multi {
      justify-content:space-between;
    }
    .track-reward.cleared { text-decoration: line-through; }
    .track-label { font-weight:600; font-size:14px; }
    .track-reward { color:#b0b8e8; font-size:12px; }
    .track-reward .act-reward-circle {
      width:46px;
      height:46px;
      border-width:3px;
      --reward-border: 1px;
      --reward-gap: 0px;
    }
    .track-reward .reward-inner-mask {
      padding-top: 10%;
      box-sizing: border-box;
    }
    .track-reward .reward-inner-mask .reward-star-post {
      width:31%;
    }
    .track-reward .act-reward-circle img {
      width:24px;
      height:24px;
    }
    .track-reward .act-reward-circle img.reward-badnik {
      width:28px;
    }
    .track-reward .act-reward-circle img.reward-big-ring,
    .track-reward .act-reward-circle img.reward-badnik,
    .track-reward .act-reward-circle img.reward-time,
    .track-reward .act-reward-circle img.reward-hazard-2,
    .track-reward .act-reward-circle img.reward-hazard-3 {
      height:auto;
    }
    .track-reward .act-reward-circle img.reward-ring-2 {
      height:auto;
    }
    .track-reward .act-reward-circle img.reward-star-post {
      width:31%;
      height:auto;
    }
    .track-reward .act-reward-tag {
      font-size:7px;
      padding:1px 4px;
    }
    .track-reward .act-reward-text {
      font-size:8px;
    }
    .req-chip-stack { display:inline-flex; align-items:center; justify-content:center; width:42px; height:42px; position:relative; }
    .req-chip-border { position:absolute; inset:0; background:#111; border-radius:8px; z-index:0; }
    .req-chip-border.bumper { background:#8f8f8f; }
    .track-label.cleared .req-chip-border { background:#c01818; }
    .track-label.clickable .req-chip-border {
      animation: selectableBorderPulse 2.2s ease-in-out infinite;
    }
    .track-label.cleared .req-chip-border { animation:none; }
    .req-chip { display:inline-flex; align-items:center; justify-content:center; width:calc(100% - 6px); height:calc(100% - 6px); padding:0; border-radius:5px; border:0; background:#d7dbe6; color:#111; font-weight:700; letter-spacing:.02em; box-sizing:border-box; position:relative; z-index:2; }
    .req-chip img { width:28px; height:28px; display:block; }
    .req-chip.req-blue { background:#5aa3ff; color:#0b1020; }
    .req-chip.req-yellow { background:#ffd756; color:#3a2a00; }
    .req-chip.req-red { background:#f04848; color:#2a0b0b; }
    .req-chip.req-any { background:#d7dbe6; color:#111; }
    .req-number { font-size:1.15em; }
    @keyframes selectableBorderPulse {
      0% { background:#111; }
      50% { background:#c5cbd8; }
      100% { background:#111; }
    }
    .player-setup { display:flex; flex-direction:column; gap:6px; }
    .player-setup-row { display:flex; align-items:center; gap:8px; }
    .player-setup-row select { min-width:150px; }
    .portrait { width:28px; height:28px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; font-weight:700; font-size:12px; border:1px solid #2d3b73; background:#1a2550; color:#e8ecff; }
    .portrait.sonic { background:#1a4fa3; }
    .portrait.tails { background:#b56a1f; }
    .portrait.knuckles { background:#a33131; }
    .portrait.amy { background:#8e2f60; }
    .header-bar { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; margin:6px 0 12px; }
    .header-bar h1 { margin:0; }
    .header-logo img { height:48px; width:auto; display:block; }
    .header-center { flex:1; display:flex; justify-content:center; }
    .top-bar { display:flex; justify-content:flex-end; }
    .menu-wrapper { position:relative; }
    .menu-button { width:36px; height:32px; display:flex; flex-direction:column; justify-content:center; gap:4px; padding:6px; }
    .menu-button span { display:block; width:18px; height:2px; background:#e8ecff; border-radius:2px; }
    .menu-dropdown { position:absolute; right:0; top:40px; background:#121a33; border:1px solid #23305a; border-radius:10px; padding:6px; min-width:140px; display:none; z-index:900; }
    .menu-dropdown.open { display:block; }
    .menu-dropdown button { width:100%; text-align:left; }
    .modal-overlay { position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal-overlay.open { display:flex; }
    .modal { max-width:540px; width:calc(100% - 32px); }
    .modal-actions { justify-content:flex-end; }
    .zone-json-modal .modal { max-width:720px; }
    .zone-json-text {
      width:100%;
      min-height:320px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
    }
    .bonus-stage-modal .modal {
      background:
        linear-gradient(45deg, #fb7 25%, transparent 25%, transparent 75%, #fb7 75%, #fb7),
        linear-gradient(45deg, #fb7 25%, transparent 25%, transparent 75%, #fb7 75%, #fb7);
      background-size: 120px 120px;
      background-position: 0 0, 60px 60px;
      background-color: #da9;
      color:#1a1a1a;
    }
    .bonus-stage-modal .modal h2 {
      color:#1a1a1a;
    }
    .bonus-stage-modal .modal .tiny,
    .bonus-stage-modal .modal .muted {
      color:#2a1a0a;
    }
    .bonus-stage-modal .modal .pill {
      background:#fff1c9;
      border-color:#b8894a;
      color:#1a1a1a;
    }
    .bonus-stage-modal .modal button {
      background:#33d;
      color:#fff;
      border-color:#2240a0;
    }
    .bonus-stage-modal .modal button:hover {
      filter:brightness(1.08);
    }
    .bonus-stage-grid {
      display:grid;
      grid-template-columns: repeat(4, 120px);
      gap:16px;
      justify-content:center;
      margin-top:20px;
    }
    .bonus-tile {
      width:120px;
      height:120px;
      border-radius:12px;
      border:1px solid #2d3b73;
      background:linear-gradient(to bottom, #fdb418, #fee306);
      color:#1a1a1a;
      font-size:11px;
      font-weight:600;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      position:relative;
      cursor:pointer;
      user-select:none;
      padding:6px;
      box-sizing:border-box;
      box-shadow: 0 2px 4px rgba(0,0,0,.8);
    }
    .bonus-tile.revealed { cursor:default; }
    .bonus-tile.revealed { background:linear-gradient(to bottom, #fff3b0, #ffd6a5); }
    .bonus-tile.red { border-color:#8a2a2a; }
    .bonus-tile.bumper { border-color:#8b5b2a; }
    .bonus-tile.chaos {
      background:linear-gradient(to bottom, #fff, #ddd);
      border-color:#b8c6ff;
    }
    .bonus-tile.disabled { opacity:.6; cursor:not-allowed; }
    .bonus-reward {
      position:absolute;
      top:4px;
      right:4px;
      font-size:10px;
      background:#0f1733;
      border:1px solid #2d3b73;
      border-radius:6px;
      padding:1px 4px;
    }
    .bonus-reward img {
      width:18px;
      height:18px;
      display:block;
    }
    .zone-header { display:block; }
    .header-center .zone-level-name {
      width:auto;
      min-width:280px;
    }
    .zone-level-name {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:20px;
      width:100%;
      box-sizing:border-box;
      padding:8px 14px;
      border-radius:14px;
      background:linear-gradient(135deg, #0a47c8, #3ddcff, #ffd756);
      color:#ffffff;
      font-weight:900;
      font-size:13px;
      letter-spacing:.12em;
      text-transform:uppercase;
      border:1px solid #e8f3ff;
      box-shadow: 0 4px 12px rgba(0,0,0,.35);
      position:relative;
      text-shadow:
        -1px -1px 0 rgba(0,0,0,.7),
        1px -1px 0 rgba(0,0,0,.7),
        -1px 1px 0 rgba(0,0,0,.7),
        1px 1px 0 rgba(0,0,0,.7);
    }
    .zone-level-name::after {
      content:"";
      position:absolute;
      inset:0;
      border-radius:16px;
      background:linear-gradient(120deg, rgba(255,255,255,.6), rgba(255,255,255,0));
      z-index:-1;
      filter:blur(6px);
    }
    .zone-card {
      background:transparent;
      position:relative;
      overflow:hidden;
      z-index:0;
      perspective:1200px;
      padding:0;
    }
    .zone-level-name .zone-title {
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .zone-level-name .zone-deck {
      font-size:11px;
      letter-spacing:.18em;
      text-transform:uppercase;
      opacity:.95;
    }
    #zoneView { justify-items:start; }
    .zone-card {
      max-width:460px;
      width:100%;
      min-height:230px;
    }
    .zone-card-inner {
      position:relative;
      width:100%;
      min-height:100%;
      transform-style:preserve-3d;
      transform:rotateY(0deg);
    }
    .zone-card.flip-in .zone-card-inner {
      transform: rotateY(180deg);
      animation: card-flip-in 0.7s ease 0.4s;
    }
    @keyframes card-flip-in {
      0% { transform: rotateY(180deg); }
      100% { transform: rotateY(0deg); }
    }
    .zone-card-face {
      backface-visibility:hidden;
      border-radius:14px;
      overflow:hidden;
      box-sizing:border-box;
    }
    .zone-card-front {
      position:relative;
      --zone-card-texture: url("img/zone_card_checkboard.png");
      background-image: var(--zone-card-texture), var(--zone-card-gradient, linear-gradient(180deg, #121a33, #121a33));
      background-repeat: repeat, no-repeat;
      background-size: auto, cover;
      background-position: center, center;
      padding:2px 6px;
    }
    .zone-card-back {
      position:absolute;
      inset:0;
      transform: rotateY(180deg);
      background:#f2d86a;
      border:3px solid #ffffff;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:16px;
      color:#1b2a3d;
      text-transform:uppercase;
      font-weight:800;
      letter-spacing:.08em;
    }
    .secret-passage-back {
      background:#7a1b1b;
      color:#ffffff;
    }
    .track-connectors {
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
      z-index:1;
      --connector-stroke: 9;
      --connector-active: #c01818;
      --connector-muted: #e8ecff;
      --chevron-height: 7px;
      --chevron-width: 7px;
      --chevron-gap: 0.01px;
      --chevron-angle-factor: 0.45;
    }
    .track-connectors line {
      stroke: var(--connector-muted);
      stroke-width: var(--connector-stroke);
      stroke-linecap: butt;
      vector-effect: non-scaling-stroke;
    }
    .track-connectors line.active { stroke: var(--connector-active); }
    .zone-layout {
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:stretch;
    }
    .zone-row {
      display:flex;
      gap:6px;
      align-items:stretch;
    }
    .zone-secret-row {
      align-items:flex-start;
    }
    .zone-cards {
      flex:1;
      min-width:240px;
    }
    .act-board {
      flex:0 0 320px;
      --act-arrow-start: #58b6ff;
      --act-arrow-end: #2f7cff;
      background:linear-gradient(180deg, #0f2347, #0a142b);
      border:1px solid #23305a;
      border-radius:14px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      box-shadow: 0 8px 25px rgba(0,0,0,.25);
    }
    .act-board-mini {
      flex:0 0 320px;
      min-height:230px;
      padding:10px;
    }
    .act-board-mini .act-board-lanes { gap:0; height:100%; }
    .act-board-mini .act-lane { min-height:0; }
    .act-board-lanes {
      display:flex;
      flex-direction:column;
      gap:8px;
      flex:1;
    }
    .act-lane {
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#0f1733;
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:8px;
      position:relative;
    }
    .act-lane-arrow {
      width:110px;
      height:82px;
      position:absolute;
      left:6px;
      top:50%;
      transform:translateY(-50%);
      z-index:2;
      pointer-events:none;
    }
    .act-lane-arrow svg { width:100%; height:100%; display:block; }
    .act-reward-circle {
      --reward-border: 7px;
      --reward-gap: 1px;
      --reward-inset: calc(var(--reward-border) + var(--reward-gap));
      width:176px;
      height:176px;
      border-radius:50%;
      background:transparent;
      border:var(--reward-border) solid #d8b24c;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      z-index:1;
      color:#0a142b;
      font-weight:800;
      text-align:center;
      padding:8px;
      box-sizing:border-box;
      overflow:hidden;
    }
    .act-reward-circle::before {
      content:"";
      position:absolute;
      inset:var(--reward-inset);
      border-radius:50%;
      background:radial-gradient(circle at 30% 30%, #ffffff, #b6c8ff);
      z-index:0;
    }
    .act-reward-circle > * { position:relative; z-index:1; }
    .act-reward-circle img {
      width:83.2px;
      height:83.2px;
      display:block;
    }
    .act-lane .act-reward-circle {
      position:absolute;
      left:60%;
      top:50%;
      transform:translate(-50%, -50%);
    }
    .act-reward-circle img.reward-badnik {
      width:58px;
    }
    .act-reward-circle img.reward-big-ring,
    .act-reward-circle img.reward-badnik,
    .act-reward-circle img.reward-time,
    .act-reward-circle img.reward-hazard-2,
    .act-reward-circle img.reward-hazard-3 {
      height:auto;
    }
    .act-reward-circle img.reward-ring-2 { height:auto; }
    .reward-inner-mask {
      position:absolute;
      inset:var(--reward-inset);
      border-radius:50%;
      overflow:hidden;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      z-index:1;
    }
    .reward-inner-mask .reward-star-post {
      width:26%;
      height:auto;
      display:block;
    }
    .act-reward-tag {
      position:absolute;
      bottom:6px;
      font-size:9px;
      letter-spacing:.1em;
      text-transform:uppercase;
      background:#0a47c8;
      color:#fff;
      padding:2px 6px;
      border-radius:999px;
    }
    .act-reward-text {
      font-size:10px;
      letter-spacing:.08em;
      text-transform:uppercase;
    }
    .reward-icon {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:18px;
      height:18px;
      vertical-align:middle;
    }
    .reward-icon img {
      width:18px;
      height:18px;
      display:block;
    }
    .badnik-card {
      width:336px;
      max-width:100%;
      aspect-ratio: 7 / 5;
      border:8px solid var(--badnik-path-color, #101010);
      border-radius:14px;
      overflow:hidden;
      display:grid;
      grid-template-columns: 56px 16px 1fr;
      background:#111;
      box-shadow: 0 6px 12px rgba(0,0,0,.35);
      cursor:pointer;
      transition: transform 0.35s ease;
      transform-origin: center;
      will-change: transform;
    }
    .badnik-card.flipped {
      transform: rotate(180deg);
    }
    .badnik-card.flip-anim {
      animation: badnikFlip 0.35s ease;
    }
    @keyframes badnikFlip {
      from { transform: rotate(0deg); }
      to { transform: rotate(180deg); }
    }
    #badnikView {
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .badnik-attack-col {
      background-color:#a5adb6;
      background-image:
        url("img/badnik_card_checkerboard.png"),
        linear-gradient(180deg, #d6dde6 0%, #b2bcc8 48%, #8a95a3 100%);
      background-repeat: repeat, no-repeat;
      background-size: auto, cover;
      background-position: center, center;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:8px 6px 0;
      gap:0;
      position:relative;
      --attack-die-size: 42px;
    }
    .badnik-attack-dice {
      display:flex;
      flex-direction:column;
      gap:0;
      margin-bottom:0;
      position:relative;
      width:100%;
      align-items:center;
      overflow:visible;
    }
    .badnik-attack-top {
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .badnik-attack-overlap {
      position:absolute;
      top:calc(var(--attack-die-size) + 3px);
      left:50%;
      transform:translateX(-50%);
      display:flex;
      flex-direction:column;
      gap:6px;
      z-index:2;
    }
    .badnik-connector {
      background:var(--badnik-path-color, #101010);
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:999px;
    }
    .badnik-connector.vertical {
      width:18px;
      flex:1;
      padding:0;
      align-self:center;
      margin-top:0;
      border-radius:0;
    }
    .badnik-connector.horizontal {
      height:16px;
      width:var(--badnik-connector-width, 86px);
      padding:0 6px;
    }
    .badnik-chevrons {
      display:flex;
      gap:1px;
    }
    .badnik-connector.vertical .badnik-chevrons {
      flex-direction:column;
    }
    .badnik-chevron {
      width:12px;
      height:10px;
      background:#d85a2a;
      clip-path: polygon(0 0, 75% 0, 100% 50%, 75% 100%, 0 100%, 25% 50%);
    }
    .badnik-connector.vertical .badnik-chevron {
      transform: rotate(90deg);
    }
    .badnik-sonic {
      width:46px;
      height:46px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:absolute;
      left:50%;
      bottom:6px;
      transform:translateX(-50%);
      z-index:2;
      pointer-events:none;
    }
    .badnik-sonic img {
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
    }
    .badnik-hatch {
      background: repeating-linear-gradient(135deg, #f2a83a 0 16.2px, #111 16.2px 32.4px);
      border-left:3px solid #000;
      border-right:3px solid #000;
    }
    .badnik-main {
      position:relative;
      background:var(--badnik-panel-base, #3a2315);
      overflow:hidden;
      padding:8px;
    }
    .badnik-main::before {
      content:"";
      position:absolute;
      left:0;
      right:0;
      top:0;
      bottom:20%;
      background-image:var(--badnik-art, none);
      background-size:cover;
      background-position:center;
      border-bottom:3px solid #000;
      opacity:1;
      z-index:0;
    }
    .badnik-name {
      position:absolute;
      top:8px;
      left:0;
      background:#c91818;
      color:#fff;
      padding:4px 26px 4px 16px;
      font-weight:400;
      font-style:italic;
      text-transform:uppercase;
      letter-spacing:.08em;
      font-size:14px;
      z-index:2;
      border-radius:0;
      line-height:1;
      clip-path: polygon(0 0, 100% 0, 88% 100%, 0 100%);
    }
    .badnik-right {
      position:absolute;
      right:-8px;
      top:16px;
      display:flex;
      flex-direction:column;
      gap:10px;
      z-index:2;
      align-items:flex-end;
    }
    .badnik-right-row {
      display:flex;
      align-items:center;
      gap:6px;
      position:relative;
      --badnik-connector-width: 85px;
      --badnik-animal-size: 46px;
    }
    .badnik-right-row .req-chip-stack {
      margin-right:-14px;
      z-index:2;
    }
    .badnik-animal {
      position:absolute;
      right: calc(var(--badnik-connector-width) / 2 - var(--badnik-animal-size) / 2);
      top:50%;
      transform:translateY(-50%);
      width:var(--badnik-animal-size);
      height:var(--badnik-animal-size);
      border-radius:50%;
      background:#fff;
      border:3px solid #d8b24c;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:9px;
      font-weight:700;
      color:#111;
      z-index:3;
    }
    .badnik-animal img {
      width:75%;
      height:75%;
      object-fit:contain;
      display:block;
      border-radius:50%;
    }
    .badnik-ability {
      position:absolute;
      left:12px;
      right:12px;
      top:80%;
      transform:translateY(-50%);
      background:#0a0a0a;
      border:2px solid #ffffff;
      color:#ffffff;
      padding:12px 8px;
      min-height:36px;
      font-size:10px;
      letter-spacing:.04em;
      text-transform:none;
      z-index:2;
      line-height:1.25;
      display:flex;
      align-items:center;
    }
    .badnik-ability .ability-text {
      display:inline;
    }
    .badnik-ability .inline-icon {
      height:12px;
      width:auto;
      margin:0 2px;
      vertical-align:-2px;
      image-rendering: pixelated;
    }
    .badnik-ability .ability-prefix {
      font-weight:700;
      font-style:italic;
      text-transform:uppercase;
      margin-right:4px;
    }
    .badnik-zone {
      position:absolute;
      right:6px;
      bottom:1px;
      font-size:12px;
      font-weight:700;
      color:#ffffff;
      text-shadow: 0 1px 2px rgba(0,0,0,.7);
      z-index:3;
    }
    .power-up-status {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .power-up-slot {
      width:40px;
      height:40px;
      border-radius:10px;
      border:1px solid #2d3b73;
      background:#0f1733;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
    }
    .power-up-slot img {
      width:28px;
      height:auto;
      display:block;
    }
    .power-up-count {
      position:absolute;
      right:-6px;
      top:-6px;
      background:#0a47c8;
      color:#fff;
      border-radius:999px;
      font-size:10px;
      padding:1px 5px;
      border:1px solid #2d3b73;
    }
    .power-up-discard-grid {
      display:flex;
      flex-wrap:wrap;
      gap:6px;
    }
    .power-up-discard-grid img {
      width:24px;
      height:auto;
      display:block;
    }
    .chaos-emerald-list { display:flex; flex-wrap:wrap; gap:8px; margin-top:6px; }
    .chaos-emerald-card {
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
      padding:6px 8px;
      border:1px solid #2d3b73;
      border-radius:10px;
      background:#0f1733;
      color:#e8ecff;
      font-size:11px;
      min-width:90px;
    }
    .chaos-emerald-card img { width:36px; height:auto; display:block; }
    .chaos-emerald-card.spent { opacity:.6; text-decoration: line-through; }
    .bonus-icon {
      font-size:70px;
      line-height:1;
    }
  </style>
</head>
<body>
  <div class="header-bar">
    <h1 class="header-logo"><img src="img/Sonic_Roll_Logo.webp" alt="Sonic Roll"></h1>
    <div class="header-center">
      <div id="zoneHeaderInfo" class="zone-header"></div>
    </div>
    <div id="top-bar" class="top-bar">
      <div id="menuWrapper" class="menu-wrapper">
        <button id="menuBtn" class="menu-button" aria-label="Menu">
          <span></span><span></span><span></span>
        </button>
        <div id="menuDropdown" class="menu-dropdown">
          <button id="menuNewGame">New Game</button>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <div id="controlsCard" class="card controls-card" style="flex:0.85; min-width:300px;">
      <div id="characterHeading" class="character-heading"></div>
      <div class="hr"></div>

      <div class="row">
        <div id="rollActionButtons" class="row"></div>
        <button id="btnBuildPool">Roll / Build Dice Pool</button>
      </div>

      <div class="row" style="margin-top:8px;">
        <button id="btnUseBoostToken">Use Boost Token</button>
        <button id="btnSpendDie">Spend Selected Die</button>
        <button id="btnRerollStep">Reroll Step</button>
        <button id="btnEndTurn">End Turn (Discard + Time)</button>
      </div>

      <div class="hr"></div>

      <div class="tiny row">
        <div><span class="badge">Phase</span> <span id="phase"></span></div>
        <div><span class="badge">Invulnerable</span> <span id="invuln"></span></div>
        <div><span class="badge">Spent Since Reroll</span> <span id="spentSinceReroll"></span></div>
        <div id="buddyFlightBadge"></div>
      </div>

      <div class="hr"></div>

      <div class="row dice-pool-header">
        <h2>Dice Pool</h2>
      </div>
      <div id="dicePool"></div>
      <div class="row dice-pool-footer">
        <div class="tiny muted">Click a die to select it for spending.</div>
        <div id="chainSpendRuleBadge" class="chain-spend-badge"></div>
      </div>

      <div class="hr"></div>

      <div id="wallClimbSection">
        <h2>Wall Climb</h2>
        <div id="wallClimbPanel" class="tiny muted"></div>
        <div class="hr"></div>
      </div>

      <div id="discardSection">
        <h2>Discard a Die</h2>
        <div id="discardPanel" class="tiny muted"></div>
        <div class="hr"></div>
      </div>

      <div id="starPostSection">
        <h2>Star Post</h2>
        <div id="starPostPanel" class="tiny muted"></div>
        <div class="hr"></div>
      </div>

      <h2>Spend Target</h2>
      <div id="spendTargetPanel" class="tiny muted">Select a die and click "Spend Selected Die" to choose a target. Tip: click a Zone/Badnik card to preselect.</div>

      <div class="hr"></div>

      <h2>Power Ups</h2>
      <div id="powerUpStatus" class="tiny"></div>
      <div id="powerUpPanel" class="tiny muted">No pending Power Ups.</div>

      <div class="hr"></div>

      <h2>Chaos Emeralds</h2>
      <div id="chaosEmeraldPanel" class="tiny muted"></div>

      <div class="hr"></div>

      <h2>Badniks</h2>
      <div id="badnikView"></div>

    </div>

    <div class="card" style="flex:1.2; min-width:360px;">
      <h2 style="display:none;">Zone (Simplified Track)</h2>
      <div class="zone-layout">
        <div class="zone-row">
          <div class="zone-cards">
            <div id="zoneView" class="grid"></div>
          </div>
          <div id="actBoardView" class="act-board"></div>
        </div>
        <div id="secretPassageRow" class="zone-row zone-secret-row" style="display:none;">
          <div class="zone-cards">
            <div id="secretPassageView" class="grid"></div>
          </div>
          <div id="secretActBoardView" class="act-board act-board-mini"></div>
        </div>
      </div>
    </div>

    <div class="card" style="flex:0 0 380px; min-width:360px;">
      <h2>Debug</h2>
      <button id="btnForceBonusStage">Force Bonus Stage</button>
      <button id="btnShowPowerUpDeck">Show Power-Up Deck Order</button>
      <button id="btnShowZoneJson">Show Zone Card JSON</button>

      <div class="hr"></div>

      <h2>Log</h2>
      <div id="log" class="log mono"></div>

      <div class="hr"></div>

      <h2>Discarded Power Ups</h2>
      <div id="powerUpDiscardView" class="tiny muted"></div>

      <div class="hr"></div>

      <h2>Discarded Badniks</h2>
      <div id="badnikDiscardView" class="tiny muted"></div>

      <div class="hr"></div>

      <h2>Time Scoring</h2>
      <div id="timeScoringView" class="tiny muted"></div>

    </div>
  </div>

  <div id="newGameModal" class="modal-overlay">
    <div class="card modal">
      <h2>New Game</h2>
      <h2>Game Controls</h2>
      <div class="row">
        <label class="pill tiny">Players
          <select id="playerCount">
            <option>1</option><option selected>2</option><option>3</option><option>4</option>
          </select>
        </label>
        <label class="pill tiny">Seed
          <input id="seed" value="" size="10" />
        </label>
        <label class="pill tiny">Zone
          <select id="zoneSelect"></select>
        </label>
      </div>

      <div class="hr"></div>

      <h2>Characters</h2>
      <div id="playerSetup" class="player-setup tiny"></div>
      <div class="tiny muted">Each character can only be used once per game.</div>

      <div class="hr"></div>

      <div class="row modal-actions">
        <button id="cancelNewGameBtn">Cancel</button>
        <button id="confirmNewGameBtn">Start New Game</button>
      </div>
    </div>
  </div>

  <div id="bonusStageModal" class="modal-overlay bonus-stage-modal">
    <div class="card modal">
      <h2>Bonus Stage</h2>
      <div id="bonusStageStatus" class="tiny muted"></div>
      <div id="bonusStageGrid" class="bonus-stage-grid"></div>
      <div class="row modal-actions">
        <button id="bonusStageExit">Return to Zone</button>
      </div>
    </div>
  </div>

  <div id="zoneJsonModal" class="modal-overlay zone-json-modal">
    <div class="card modal">
      <h2>Zone Card JSON</h2>
      <textarea id="zoneJsonText" class="zone-json-text" readonly></textarea>
      <div class="row modal-actions">
        <button id="zoneJsonCopy">Copy JSON</button>
        <button id="zoneJsonClose">Close</button>
      </div>
    </div>
  </div>

<script>
/* =======================
   RNG (seeded)
   ======================= */
function mulberry32(seed) {
  let a = seed >>> 0;
  return function() {
    a += 0x6D2B79F5;
    let t = a;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function hashSeed(str) {
  let h = 2166136261 >>> 0;
  for (let i=0;i<str.length;i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}
let __rng = null;
function initGameRng(seed) { __rng = mulberry32(seed); }
function rng(){ return __rng; }
function rollD6(){ return 1 + Math.floor(rng()()*6); }

/* =======================
   Types / helpers
   ======================= */
const DieColor = Object.freeze({ BLUE:"blue", YELLOW:"yellow", RED:"red", BLACK:"black" });

let PRE_GAME_CHARACTERS = [];
let PRE_GAME_ZONE = "green_hill";

function uuid() {
  // browser-safe UUID fallback
  if (crypto?.randomUUID) return crypto.randomUUID();
  return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now();
}

function makeDie(color, value) { return { id: uuid(), color, value }; }
function clone(obj) { return JSON.parse(JSON.stringify(obj)); }
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng()() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function log(state, msg) { state.log.push(msg); return state; }
function makeVulnerable(p){ p.invulnerable = false; }
function makeInvulnerable(p){ p.invulnerable = true; }

function getPipPositions(value) {
  switch (value) {
    case 1: return [4];
    case 2: return [0, 8];
    case 3: return [0, 4, 8];
    case 4: return [0, 2, 6, 8];
    case 5: return [0, 2, 4, 6, 8];
    case 6: return [0, 2, 3, 5, 6, 8];
    default: return [4];
  }
}

function buildDieFaceHtml(value) {
  const v = Math.max(1, Math.min(6, Number(value) || 1));
  const on = new Set(getPipPositions(v));
  const pips = Array.from({ length: 9 }, (_, i) => {
    return `<span class="pip${on.has(i) ? " on" : ""}"></span>`;
  }).join("");
  return `<div class="pip-grid">${pips}</div>`;
}

function buildGradientCss(colors) {
  if (!Array.isArray(colors) || !colors.length) return "";
  if (colors.length === 1 && typeof colors[0] === "string") return colors[0];
  const stops = colors.map((entry, index) => {
    if (typeof entry === "string") {
      const pct = Math.round((index / (colors.length - 1)) * 100);
      return `${entry} ${pct}%`;
    }
    if (entry && typeof entry === "object") {
      const pct = Number.isFinite(entry.stop) ? entry.stop : Math.round((index / (colors.length - 1)) * 100);
      return `${entry.color} ${pct}%`;
    }
    return "";
  }).filter(Boolean);
  return `linear-gradient(180deg, ${stops.join(", ")})`;
}

function getGradientEndpoints(colors) {
  if (!Array.isArray(colors) || !colors.length) return null;
  if (colors.length === 1 && typeof colors[0] === "string") {
    return { start: colors[0], end: colors[0] };
  }
  const points = colors.map((entry, index) => {
    if (typeof entry === "string") {
      const pct = colors.length > 1 ? (index / (colors.length - 1)) * 100 : 0;
      return { color: entry, stop: pct };
    }
    if (entry && typeof entry === "object") {
      const pct = Number.isFinite(entry.stop)
        ? entry.stop
        : (colors.length > 1 ? (index / (colors.length - 1)) * 100 : 0);
      return { color: entry.color, stop: pct };
    }
    return null;
  }).filter(Boolean);
  if (!points.length) return null;
  let minPoint = points[0];
  let maxPoint = points[0];
  for (const point of points) {
    if (point.stop < minPoint.stop) minPoint = point;
    if (point.stop > maxPoint.stop) maxPoint = point;
  }
  return { start: minPoint.color, end: maxPoint.color };
}

function getChevronGradient(zoneConfig) {
  const zoneGen = zoneConfig?.zoneGenerator;
  const cardGradient = zoneGen?.cardGradient;
  const fromCard = getGradientEndpoints(cardGradient);
  if (fromCard) return fromCard;
  const fallback = zoneGen?.chevronGradient || zoneGen?.actBoardArrowColors || CONFIG.zoneGenerator?.chevronGradient;
  if (fallback?.start && fallback?.end) return fallback;
  return { start: "#58b6ff", end: "#2f7cff" };
}

function getActChevronGradient(zoneConfig) {
  const zoneGen = zoneConfig?.zoneGenerator;
  const explicit = zoneGen?.actChevronGradient;
  if (explicit?.top && explicit?.bottom) return explicit;
  const fromCard = getGradientEndpoints(zoneGen?.cardGradient);
  if (fromCard) return { top: fromCard.start, bottom: fromCard.end };
  return { top: "#58b6ff", bottom: "#2f7cff" };
}


function isGameOver(state) {
  if (state.timeTokens <= 0) return "Time ran out (0 Time Tokens)";
  for (const p of state.players) if (p.lives <= 0) return `${p.name} lost final Life`;
  return null;
}

function getDefaultCharacterOrder() {
  return Object.keys(CONFIG.characters);
}

const CHARACTER_PORTRAITS = {
  Sonic: { label: "S", className: "sonic" },
  Tails: { label: "T", className: "tails" },
  Knuckles: { label: "K", className: "knuckles" },
  Amy: { label: "A", className: "amy" }
};

function applyPortrait(el, character) {
  if (!el) return;
  const def = CHARACTER_PORTRAITS[character] || { label: "?", className: "" };
  el.textContent = def.label;
  el.className = `portrait ${def.className}`;
  el.title = character || "Unknown";
}

function updatePortraitsFromSelectors() {
  const selects = Array.from(document.querySelectorAll("[id^='playerCharSelect-']"));
  for (const sel of selects) {
    const idx = sel.id.split("-")[1];
    const portrait = document.getElementById(`playerPortrait-${idx}`);
    applyPortrait(portrait, sel.value);
  }
}

function getPreGameCharacterSelections(playerCount) {
  const allChars = getDefaultCharacterOrder();
  const used = new Set();
  const out = [];
  for (let i = 0; i < playerCount; i++) {
    let choice = PRE_GAME_CHARACTERS[i];
    if (!allChars.includes(choice) || used.has(choice)) {
      choice = allChars.find(c => !used.has(c)) || allChars[i % allChars.length];
    }
    out.push(choice);
    used.add(choice);
  }
  PRE_GAME_CHARACTERS = out.slice();
  return out;
}

function enforceUniqueCharacterSelections() {
  const selects = Array.from(document.querySelectorAll("[id^='playerCharSelect-']"));
  const allChars = getDefaultCharacterOrder();
  const used = new Set();
  for (const sel of selects) {
    let choice = sel.value;
    if (!allChars.includes(choice) || used.has(choice)) {
      choice = allChars.find(c => !used.has(c)) || allChars[0];
      sel.value = choice;
    }
    used.add(choice);
  }
  for (const sel of selects) {
    for (const opt of sel.options) {
      opt.disabled = used.has(opt.value) && opt.value !== sel.value;
    }
  }
  PRE_GAME_CHARACTERS = selects.map(s => s.value);
  updatePortraitsFromSelectors();
}

function renderCharacterSelectors() {
  const container = document.getElementById("playerSetup");
  if (!container) return;
  const playerCount = parseInt(document.getElementById("playerCount").value, 10);
  const selections = getPreGameCharacterSelections(playerCount);
  const allChars = getDefaultCharacterOrder();
  container.innerHTML = "";

  for (let i = 0; i < playerCount; i++) {
    const row = document.createElement("div");
    row.className = "player-setup-row";
    row.innerHTML = `
      <span class="badge">P${i+1}</span>
      <span id="playerPortrait-${i}" class="portrait"></span>
      <select id="playerCharSelect-${i}"></select>
    `;
    const sel = row.querySelector("select");
    for (const name of allChars) {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      sel.appendChild(opt);
    }
    sel.value = selections[i] || allChars[i % allChars.length];
    sel.addEventListener("change", () => {
      PRE_GAME_CHARACTERS[i] = sel.value;
      enforceUniqueCharacterSelections();
    });
    const portrait = row.querySelector(`#playerPortrait-${i}`);
    applyPortrait(portrait, sel.value);
    container.appendChild(row);
  }
  enforceUniqueCharacterSelections();
}

function renderZoneSelector() {
  const select = document.getElementById("zoneSelect");
  if (!select) return;
  select.innerHTML = "";
  for (const zone of Object.values(CONFIG.zones)) {
    const opt = document.createElement("option");
    opt.value = zone.id;
    opt.textContent = zone.name;
    select.appendChild(opt);
  }
  if (!CONFIG.zones[PRE_GAME_ZONE]) {
    PRE_GAME_ZONE = Object.keys(CONFIG.zones)[0];
  }
  select.value = PRE_GAME_ZONE;
  select.addEventListener("change", () => {
    PRE_GAME_ZONE = select.value;
  });
}

function readZoneSelection() {
  const select = document.getElementById("zoneSelect");
  return select?.value || PRE_GAME_ZONE || Object.keys(CONFIG.zones)[0];
}

function readCharacterSelections(playerCount) {
  const selections = [];
  for (let i = 0; i < playerCount; i++) {
    const sel = document.getElementById(`playerCharSelect-${i}`);
    selections.push(sel ? sel.value : null);
  }
  return selections;
}

/* =======================
   Dashboard-accurate config
   (from the four images you provided)
   ======================= */
const BIG_RING_AMOUNT = 5; // Reference value for Big Ring rewards (Bonus Stage trigger).

const BADNIK_TYPES = [
  { id:"moto_bug", name:"Moto Bug", image:"img/badniks/moto_bug.png" },
  { id:"newtron", name:"Newtron", image:"img/badniks/newtron.png" },
  { id:"buzz_bomber", name:"Buzz Bomber", image:"img/badniks/buzz_bomber.png" },
  { id:"chopper", name:"Chopper", image:"img/badniks/chopper.png" },
  { id:"fireworm", name:"Fireworm", image:"img/badniks/fireworm.png" },
  { id:"iwamodoki", name:"Iwamodoki", image:"img/badniks/iwamodoki.png" },
  { id:"rexon", name:"Rexon", image:"img/badniks/rexon.png" },
  { id:"toxomister", name:"Toxomister", image:"img/badniks/toxomister.png" },
  { id:"catakiller_jr", name:"Catakiller Jr.", image:"img/badniks/catakiller_jr.png" },
  { id:"grabber", name:"Grabber", image:"img/badniks/grabber.png" },
  { id:"spiny", name:"Spiny", image:"img/badniks/spiny.png" },
  { id:"sweep", name:"Sweep", image:"img/badniks/sweep.png" },
  { id:"horatu", name:"Horatu", image:"img/badniks/horatu.png" },
  { id:"kabasira", name:"Kabasira", image:"img/badniks/kabasira.png" },
  { id:"dango", name:"Dango", image:"img/badniks/dango.png" },
  { id:"kanabun", name:"Kanabun", image:"img/badniks/kanabun.png" }
];
const BADNIK_TYPE_MAP = Object.fromEntries(BADNIK_TYPES.map(t => [t.id, t]));

// Zone-specific Badnik decks (swap per zone via badnikDeckId).
const BADNIK_DECKS = {
  default: [
    { type:"moto_bug", name:"Moto Bug", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"newtron", name:"Newtron", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"buzz_bomber", name:"Buzz Bomber", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"chopper", name:"Chopper", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } },
    { type:"moto_bug", name:"Moto Bug", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"newtron", name:"Newtron", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"buzz_bomber", name:"Buzz Bomber", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"chopper", name:"Chopper", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } },
    { type:"moto_bug", name:"Moto Bug", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"newtron", name:"Newtron", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"buzz_bomber", name:"Buzz Bomber", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"chopper", name:"Chopper", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } },
    { type:"moto_bug", name:"Moto Bug", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"newtron", name:"Newtron", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"buzz_bomber", name:"Buzz Bomber", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"chopper", name:"Chopper", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } }
  ],
  green_hill: [
    { type:"moto_bug", name:"Moto Bug", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"newtron", name:"Newtron", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"buzz_bomber", name:"Buzz Bomber", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"chopper", name:"Chopper", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } },
    { type:"moto_bug", name:"Moto Bug", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"newtron", name:"Newtron", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"buzz_bomber", name:"Buzz Bomber", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"chopper", name:"Chopper", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } },
    { type:"moto_bug", name:"Moto Bug", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"newtron", name:"Newtron", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"buzz_bomber", name:"Buzz Bomber", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"chopper", name:"Chopper", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } },
    { type:"moto_bug", name:"Moto Bug", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"newtron", name:"Newtron", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"buzz_bomber", name:"Buzz Bomber", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"chopper", name:"Chopper", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } }
  ],
  stardust_speedway: [
    { type:"horatu", name:"Horatu", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"kabasira", name:"Kabasira", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"dango", name:"Dango", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"kanabun", name:"Kanabun", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } },
    { type:"horatu", name:"Horatu", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"kabasira", name:"Kabasira", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"dango", name:"Dango", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"kanabun", name:"Kanabun", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } },
    { type:"horatu", name:"Horatu", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"kabasira", name:"Kabasira", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"dango", name:"Dango", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"kanabun", name:"Kanabun", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } },
    { type:"horatu", name:"Horatu", attacks:[{color:"blue", value:5},{color:"blue", value:1}], avoid:{color:"yellow", value:6}, destroy:{color:"red", value:6}, ability:{ type:"spend" } },
    { type:"kabasira", name:"Kabasira", attacks:[{color:"yellow", value:2}], avoid:{color:"yellow", value:3}, destroy:{color:"red", value:3}, ability:{ type:"reroll" } },
    { type:"dango", name:"Dango", attacks:[{color:"blue", value:5},{color:"yellow", value:5}], avoid:{color:"blue", value:2}, destroy:{color:"red", value:2}, ability:{ type:"defeat" } },
    { type:"kanabun", name:"Kanabun", attacks:[{value:3}], avoid:{color:"blue", value:5}, destroy:{color:"red", value:5}, ability:{ type:"defeat" } }
  ]
};

const LAVA_REEF_FIREWORMS = [
  {
    type:"fireworm",
    name:"Fireworm",
    attacks:[{color:"yellow", value:5},{color:"yellow", value:2}],
    avoid:{color:"yellow", value:4},
    destroy:{color:"red", value:4},
    ability:{ type:"passive", effect:"rule", rule:"no_power_ups" },
    text:"Cannot draw Power Ups"
  },
  {
    type:"fireworm",
    name:"Fireworm",
    attacks:[{color:"yellow", value:5},{color:"yellow", value:2}],
    avoid:{color:"yellow", value:6},
    destroy:{color:"red", value:6},
    ability:{ type:"passive", effect:"rule", rule:"no_power_ups" },
    text:"Cannot draw Power Ups"
  },
  {
    type:"fireworm",
    name:"Fireworm",
    attacks:[{color:"yellow", value:6},{color:"yellow", value:1}],
    avoid:{color:"yellow", value:5},
    destroy:{color:"red", value:5},
    ability:{ type:"passive", effect:"rule", rule:"no_power_ups" },
    text:"Cannot draw Power Ups"
  },
  {
    type:"fireworm",
    name:"Fireworm",
    attacks:[{color:"yellow", value:6},{color:"yellow", value:3}],
    avoid:{color:"yellow", value:2},
    destroy:{color:"red", value:2},
    ability:{ type:"passive", effect:"rule", rule:"no_power_ups" },
    text:"Cannot draw Power Ups"
  },
  {
    type:"fireworm",
    name:"Fireworm",
    attacks:[{color:"yellow", value:4},{color:"yellow", value:1}],
    avoid:{color:"yellow", value:1},
    destroy:{color:"red", value:1},
    ability:{ type:"passive", effect:"rule", rule:"no_power_ups" },
    text:"Cannot draw Power Ups"
  }
];

const LAVA_REEF_REXONS = [
  {
    type:"rexon",
    name:"Rexon",
    attacks:[{value:5}],
    avoid:{color:"yellow", value:2},
    destroy:{color:"red", value:2},
    ability:{ type:"defeat", effect:"hazard_if_no_yellow", amount:2 },
    text:"{two_hazard_dice} if no {yellow_die} are in your Dice Pool."
  },
  {
    type:"rexon",
    name:"Rexon",
    attacks:[{value:4}],
    avoid:{color:"yellow", value:5},
    destroy:{color:"red", value:5},
    ability:{ type:"defeat", effect:"hazard_if_no_yellow", amount:2 },
    text:"{two_hazard_dice} if no {yellow_die} are in your Dice Pool."
  },
  {
    type:"rexon",
    name:"Rexon",
    attacks:[{value:2}],
    avoid:{color:"yellow", value:6},
    destroy:{color:"red", value:6},
    ability:{ type:"defeat", effect:"hazard_if_no_yellow", amount:2 },
    text:"{two_hazard_dice} if no {yellow_die} are in your Dice Pool."
  },
  {
    type:"rexon",
    name:"Rexon",
    attacks:[{value:3}],
    avoid:{color:"yellow", value:1},
    destroy:{color:"red", value:1},
    ability:{ type:"defeat", effect:"hazard_if_no_yellow", amount:2 },
    text:"{two_hazard_dice} if no {yellow_die} are in your Dice Pool."
  },
  {
    type:"rexon",
    name:"Rexon",
    attacks:[{value:1}],
    avoid:{color:"yellow", value:3},
    destroy:{color:"red", value:3},
    ability:{ type:"defeat", effect:"hazard_if_no_yellow", amount:2 },
    text:"{two_hazard_dice} if no {yellow_die} are in your Dice Pool."
  }
];

const LAVA_REEF_TOXOMISTERS = [
  {
    type:"toxomister",
    name:"Toxomister",
    attacks:[{color:"blue", value:6}],
    avoid:{color:"blue", value:2},
    destroy:{color:"red", value:2},
    ability:{ type:"reroll", effect:"discard_ring" },
    text:"Discard a {ring}."
  },
  {
    type:"toxomister",
    name:"Toxomister",
    attacks:[{color:"blue", value:1}],
    avoid:{color:"blue", value:3},
    destroy:{color:"red", value:3},
    ability:{ type:"reroll", effect:"discard_ring" },
    text:"Discard a {ring}."
  },
  {
    type:"toxomister",
    name:"Toxomister",
    attacks:[{color:"blue", value:2}],
    avoid:{color:"blue", value:5},
    destroy:{color:"red", value:5},
    ability:{ type:"reroll", effect:"discard_ring" },
    text:"Discard a {ring}."
  },
  {
    type:"toxomister",
    name:"Toxomister",
    attacks:[{color:"blue", value:4}],
    avoid:{color:"blue", value:1},
    destroy:{color:"red", value:1},
    ability:{ type:"reroll", effect:"discard_ring" },
    text:"Discard a {ring}."
  },
  {
    type:"toxomister",
    name:"Toxomister",
    attacks:[{color:"blue", value:5}],
    avoid:{color:"blue", value:6},
    destroy:{color:"red", value:6},
    ability:{ type:"reroll", effect:"discard_ring" },
    text:"Discard a {ring}."
  }
];

const LAVA_REEF_IWAMODOKIS = [
  {
    type:"iwamodoki",
    name:"Iwamodoki",
    attacks:[],
    avoid:{value:1},
    ability:{ type:"end_turn", effect:"damage", discardOnTrigger:true },
    text:"Take damage and discard this Badnik"
  },
  {
    type:"iwamodoki",
    name:"Iwamodoki",
    attacks:[],
    avoid:{value:2},
    ability:{ type:"end_turn", effect:"damage", discardOnTrigger:true },
    text:"Take damage and discard this Badnik"
  },
  {
    type:"iwamodoki",
    name:"Iwamodoki",
    attacks:[],
    avoid:{value:4},
    ability:{ type:"end_turn", effect:"damage", discardOnTrigger:true },
    text:"Take damage and discard this Badnik"
  },
  {
    type:"iwamodoki",
    name:"Iwamodoki",
    attacks:[],
    avoid:{value:5},
    ability:{ type:"end_turn", effect:"damage", discardOnTrigger:true },
    text:"Take damage and discard this Badnik"
  },
  {
    type:"iwamodoki",
    name:"Iwamodoki",
    attacks:[],
    avoid:{value:6},
    ability:{ type:"end_turn", effect:"damage", discardOnTrigger:true },
    text:"Take damage and discard this Badnik"
  }
];

BADNIK_DECKS.lava_reef = [
  ...LAVA_REEF_FIREWORMS,
  ...LAVA_REEF_REXONS,
  ...LAVA_REEF_TOXOMISTERS,
  ...LAVA_REEF_IWAMODOKIS
];

const CONFIG = {
  characters: {
    Sonic: {
      ability: { name:"Insta-Shield", perTurnToken:true },
      rollActions: [
        {
          name:"Super Peel Out",
          dice:{ blue:6 },
          // ROLL: Discard the lowest result(s) in your Dice Pool.
          onBuildPool: (ctx) => {
            const { p, state } = ctx;
            const min = Math.min(...p.dicePool.map(d=>d.value));
            const removed = p.dicePool.filter(d => d.value === min);
            if (removed.length) {
              p.dicePool = p.dicePool.filter(d => d.value !== min);
              const label = removed.map(d => `${d.color.toUpperCase()}-${d.value}`).join(" ");
              log(state, `Sonic Super Peel Out (ROLL): discard lowest dice (${label}).`);
            }
          }
        },
        {
          name:"Spin Dash",
          dice:{ blue:1, red:1 },
          // ROLL: Repeat roll until 2 results in your Dice Pool match.
          buildMode:"repeatUntilPair"
        },
        {
          name:"Drop Dash",
          dice:{ yellow:3 },
          // SPEND: If a yellow die is spent on a Zone Card, gain a blue die.
          onSpend: (ctx) => {
            const { state, p, spendTarget, spentDie } = ctx;
            if (spendTarget?.type === "zone" && spentDie?.color === DieColor.YELLOW) {
              const d = makeDie(DieColor.BLUE, rollD6());
              p.dicePool.push(d);
              log(state, `Sonic Drop Dash (SPEND): gained a BLUE die (${d.value}) for spending on a Zone.`);
            }
          }
        }
      ]
    },

    Tails: {
      ability: { name:"Buddy Flight", perTurnToken:false }, // model later
      rollActions: [
        {
          name:"Fly",
          dice:{ yellow:4 },
          // x2, ROLL: Save matching pairs, discard the rest.
          // If no pairs, instead save any 1 die, discard the rest.
          buildMode:"tailsFlyX2"
        },
        {
          name:"Spin Jump",
          dice:{ red:3 },
          // SPEND: Gain yellow die if spent on a Badnik.
          onSpend: (ctx) => {
            const { state, p, spendTarget } = ctx;
            if (spendTarget?.type === "badnik") {
              const d = makeDie(DieColor.YELLOW, rollD6());
              p.dicePool.push(d);
              log(state, `Tails Spin Jump (SPEND): gained a YELLOW die (${d.value}) for spending on a Badnik.`);
            }
          }
        },
        {
          name:"Propeller Tail",
          dice:{ blue:4 },
          // REROLL: Gain yellow die if 2 or more dice were spent since the last Reroll.
          onRerollStepStart: (ctx) => {
            const { state, p } = ctx;
            if (p.spentSinceLastReroll >= 2 && !p.propellerTailBonusGivenSinceReroll) {
              const d = makeDie(DieColor.YELLOW, rollD6());
              p.dicePool.push(d);
              p.propellerTailBonusGivenSinceReroll = true;
              log(state, `Tails Propeller Tail (REROLL): spent>=2 since last reroll -> gained a YELLOW die (${d.value}).`);
            }
          }
        }
      ]
    },

    Knuckles: {
      ability: { name:"Secret Passage", perTurnToken:false }, // model later
      rollActions: [
        {
          name:"Wall Climb",
          dice:{ red:3 },
          repeats:3,
          // ROLL: Save a die as long as its result is higher than last saved die. Discard all unsaved dice.
          buildMode:"knucklesWallClimbX3"
        },
        {
          name:"Spin Attack",
          dice:{ blue:4 },
          // AVOID: May change a blue into a red.
          // For now: we expose a simple "convert selected blue->red" hotkey in UI later if desired.
          onAvoidConvert: { from: DieColor.BLUE, to: DieColor.RED }
        },
        {
          name:"Glide",
          dice:{ yellow:4 },
          // SPEND: May spend another yellow without rerolling if its result is lower than last spent die.
          onSpendChainRule: { color: DieColor.YELLOW, direction:"lower" }
        }
      ]
    },

    Amy: {
      ability: { name:"Piko Piko Hammer", perTurnToken:false },
      rollActions: [
        {
          name:"Hammer Throw",
          dice:{ red:3 },
          // SPEND red: May spend on any player's Badnik (once per turn).
          // Engine note: cross-player targeting is not wired into UI yet; placeholder logs when spending on own badnik.
          onSpend: (ctx) => {
            const { state, p, spentDie, spendTarget } = ctx;
            if (spentDie?.color === DieColor.RED && spendTarget?.type === "badnik") {
              if (p.oncePerTurn?.hammerThrowUsed) return;
              p.oncePerTurn.hammerThrowUsed = true;
              log(state, `Amy Hammer Throw (SPEND): would allow targeting any player's Badnik (once/turn). (UI currently spends on own Badnik.)`);
            }
          }
        },
        {
          name:"Spin Dash",
          dice:{ blue:1, red:1 },
          buildMode:"repeatUntilPair"
        },
        {
          name:"Hammer Rush",
          dice:{ yellow:3 },
          // SPEND yellow: Gain red die if a yellow die is spent on a Zone Card.
          onSpend: (ctx) => {
            const { state, p, spendTarget, spentDie } = ctx;
            if (spendTarget?.type === "zone" && spentDie?.color === DieColor.YELLOW) {
              const d = makeDie(DieColor.RED, rollD6());
              p.dicePool.push(d);
              log(state, `Amy Hammer Rush (SPEND): gained a RED die (${d.value}) for spending on a Zone.`);
            }
          }
        }
      ]
    }
  },

  // Simplified Zone generator (placeholder until we encode real Zone Cards)
  zoneGenerator: {
    challengesMin: 5,
    challengesMax: 7,
    deckCounts: { 1: 8, 2: 8, 3: 9, 4: 10 },
    splitChance: 0.3,
    splitStreakChance: 0.6,
    spaceBackground: "#0f1733",
    spaceBackgroundImages: [
      "img/zone_bg/green_hill_01.png",
      "img/zone_bg/green_hill_02.png"
    ],
    bumper: {
      maxGroups: 1,
      groupChance: 0.55,
      tripleChance: 0.35,
      colorChance: 0.2
    }
  },
  zones: {
    green_hill: {
      id: "green_hill",
      name: "Green Hill Zone Act 1",
      badnikDeckId: "green_hill",
      zoneGenerator: {
        actBoardName: "Green Hill Zone Act 1",
        actBoardRewards: {
          Top: { type:"big_ring" },
          Middle: { type:"star_post", amount:1 },
          Bottom: { type:"power_up" }
        },
        actBoardArrowColors: { start: "#58b6ff", end: "#2f7cff" },
        rewardWeightMultipliers: { time: 0.6 },
        hazardAmountChances: { two: 0.06, three: 0.01 },
        cardGradient: ["#1c2d66", "#2f7cff", "#78b5ff"],
        actChevronGradient: { top: "#1c2d66", bottom: "#78b5ff" },
        spaceBackground: "#1f4ea8",
        badnikPanelColor: "#2c5fb3"
      }
    },
    stardust_speedway: {
      id: "stardust_speedway",
      name: "Stardust Speedway Zone Act 1",
      badnikDeckId: "stardust_speedway",
      zoneGenerator: {
        actBoardName: "Stardust Speedway Zone Act 1",
        actBoardRewards: {
          Top: { type:"rings", amount:5 },
          Middle: { type:"star_post", amount:1 },
          Bottom: { type:"boost", amount:1 }
        },
        actBoardArrowColors: { start: "#58b6ff", end: "#2f7cff" },
        cardGradient: [
          { color: "#14246b", stop: 0 },
          { color: "#4a1c7a", stop: 47 },
          { color: "#b7c800", stop: 47 },
          { color: "#8f5dcc", stop: 52 },
          { color: "#6a2a7a", stop: 80 },
          { color: "#54286f", stop: 100 }
        ],
        actChevronGradient: { top: "#b7c800", bottom: "#6a2a7a" },
        spaceBackground: "#0f1733",
        badnikPanelColor: "#3a1b5a"
      }
    },
    lava_reef: {
      id: "lava_reef",
      name: "Lava Reef Zone Act 1",
      badnikDeckId: "lava_reef",
      zoneGenerator: {
        actBoardName: "Lava Reef Zone Act 1",
        actBoardRewards: {
          Top: { type:"power_up" },
          Middle: { type:"hazard", amount:2 },
          Bottom: { type:"big_ring" }
        },
        actBoardArrowColors: { start: "#58b6ff", end: "#2f7cff" },
        cardGradient: [
          { color: "#d65a2a", stop: 0 },
          { color: "#ffd257", stop: 33 },
          { color: "#e37a2f", stop: 66 },
          { color: "#c7743f", stop: 66 },
          { color: "#8a5a36", stop: 100 }
        ],
        actChevronGradient: { top: "#7a3a12", bottom: "#ff8c2a" },
        spaceBackground: "#4b2b1a",
        badnikPanelColor: "#d65a2a"
      }
    },
    chemical_plant: {
      id: "chemical_plant",
      name: "Chemical Plant Zone Act 1",
      badnikDeckId: "chemical_plant",
      zoneGenerator: {
        actBoardName: "Chemical Plant Zone Act 1",
        actBoardRewards: {
          Top: { type:"badnik", amount:1 },
          Middle: { type:"big_ring" },
          Bottom: { type:"add_dice", amount:1 }
        },
        actBoardArrowColors: { start: "#58b6ff", end: "#2f7cff" },
        hazardAmountChances: { two: 0.18, three: 0.04 },
        cardGradient: [
          { color: "#3a3a3a", stop: 0 },
          { color: "#3a3a3a", stop: 15 },
          { color: "#fdfdfd", stop: 80 },
          { color: "#fdfdfd", stop: 100 }
        ],
        actChevronGradient: { top: "#d15a1f", bottom: "#3fa64a" },
        spaceBackground: "#6b3b14",
        badnikPanelColor: "#8ad63e"
      }
    }
  }
};

const SECRET_PASSAGE_STYLE = {
  cardGradient: ["#d65a2a", "#c9461f"],
  spaceBackground: "#1b120c"
};

const SECRET_PASSAGE_TEMPLATE = {
  id: "secret_passage",
  name: "Secret Passage",
  spaces: [
    {
      id: "secret_passage_1",
      backgroundImage: "img/zone_bg/secret_passage_01.png",
      challenges: [
        {
          id: "secret_passage_1_s",
          n: null,
          color: null,
          reward: { type: "rings", amount: 2 },
          lane: "shared",
          next: ["secret_passage_2_s"],
          bumper: { id: "secret_passage_bump", index: 0, length: 2 }
        }
      ]
    },
    {
      id: "secret_passage_2",
      backgroundImage: "img/zone_bg/secret_passage_01.png",
      challenges: [
        {
          id: "secret_passage_2_s",
          n: null,
          color: null,
          reward: { type: "rings", amount: 2 },
          lane: "shared",
          next: ["secret_passage_3_top", "secret_passage_3_bottom"],
          bumper: { id: "secret_passage_bump", index: 1, length: 2 }
        }
      ]
    },
    {
      id: "secret_passage_3",
      challenges: [
        {
          id: "secret_passage_3_top",
          n: 5,
          color: null,
          reward: { type: "boost", amount: 1 },
          lane: "top",
          next: ["secret_passage_4_s"]
        },
        {
          id: "secret_passage_3_bottom",
          n: 5,
          color: "red",
          reward: { type: "power_up" },
          lane: "bottom",
          next: ["secret_passage_4_s"]
        }
      ]
    },
    {
      id: "secret_passage_4",
      backgroundImage: "img/zone_bg/secret_passage_02.png",
      challenges: [
        {
          id: "secret_passage_4_s",
          n: 4,
          color: null,
          reward: { type: "rings", amount: 2 },
          lane: "shared",
          next: ["secret_passage_5_top", "secret_passage_5_bottom"]
        }
      ]
    },
    {
      id: "secret_passage_5",
      challenges: [
        {
          id: "secret_passage_5_top",
          n: 3,
          color: "yellow",
          reward: { type: "power_up" },
          lane: "top",
          next: ["secret_passage_6_s"]
        },
        {
          id: "secret_passage_5_bottom",
          n: 3,
          color: null,
          reward: { type: "boost", amount: 1 },
          lane: "bottom",
          next: ["secret_passage_6_s"]
        }
      ]
    },
    {
      id: "secret_passage_6",
      backgroundImage: "img/zone_bg/secret_passage_01.png",
      challenges: [
        {
          id: "secret_passage_6_s",
          n: 6,
          color: null,
          reward: { type: "rings", amount: 2 },
          lane: "shared",
          next: []
        }
      ]
    }
  ]
};

const POWER_UPS = [
  { id: "super_ring", label: "Super Ring", count: 3 },
  { id: "hyper_ring", label: "Hyper Ring", count: 2 },
  { id: "eggman_mark", label: "Eggman Mark", count: 2 },
  { id: "power_sneakers", label: "Power Sneakers", count: 3 },
  { id: "invincible", label: "Invincible", count: 2 },
  { id: "one_up", label: "1-Up", count: 3 },
  { id: "shield_flame", label: "Flame Shield", count: 2 },
  { id: "shield_bubble", label: "Bubble Shield", count: 2 },
  { id: "shield_lightning", label: "Lightning Shield", count: 2 },
  { id: "shield_blue", label: "Blue Shield", count: 2 }
];

const CHAOS_EMERALDS = [
  { id: "chaos_emerald_green", color: "green", img: "img/chaos_emerald_01_green.png" },
  { id: "chaos_emerald_yellow", color: "yellow", img: "img/chaos_emerald_02_yellow.png" },
  { id: "chaos_emerald_blue", color: "blue", img: "img/chaos_emerald_03_blue.png" },
  { id: "chaos_emerald_purple", color: "purple", img: "img/chaos_emerald_04_purple.png" },
  { id: "chaos_emerald_white", color: "white", img: "img/chaos_emerald_05_white.png" },
  { id: "chaos_emerald_cyan", color: "cyan", img: "img/chaos_emerald_06_cyan.png" },
  { id: "chaos_emerald_red", color: "red", img: "img/chaos_emerald_07_red.png" }
].map(card => ({
  ...card,
  diceBonusColors: [],
  extraReward: null
}));

function getPowerUpLabel(id) {
  const entry = POWER_UPS.find(p => p.id === id);
  return entry ? entry.label : id;
}

function getChaosEmeraldLabel(card) {
  if (!card) return "Chaos Emerald";
  const color = card.color ? `${card.color[0].toUpperCase()}${card.color.slice(1)}` : "Unknown";
  return `${color} Chaos Emerald`;
}

function getShieldLabel(type) {
  if (type === "flame") return "Flame Shield";
  if (type === "bubble") return "Bubble Shield";
  if (type === "lightning") return "Lightning Shield";
  if (type === "blue") return "Blue Shield";
  return type;
}

function getShieldImageSrc(type) {
  if (!type) return "img/power_up_shield_off.png";
  const id = `shield_${type}`;
  return `img/power_up_${id}.png`;
}

function isShieldPowerUp(id) {
  return id && id.startsWith("shield_");
}

function getShieldTypeFromPowerUp(id) {
  return id.replace("shield_", "");
}

function getShieldPowerUpId(type) {
  return `shield_${type}`;
}

function buildPowerUpDeck() {
  const deck = [];
  for (const p of POWER_UPS) {
    const count = Math.max(0, p.count ?? 1);
    for (let i = 0; i < count; i++) deck.push(p.id);
  }
  return shuffle(deck);
}

function drawPowerUp(state) {
  if (!state.powerUpDeck) state.powerUpDeck = [];
  if (!state.powerUpDiscard) state.powerUpDiscard = [];
  if (!state.powerUpDeck.length) {
    if (state.powerUpDiscard.length) {
      state.powerUpDeck = shuffle(state.powerUpDiscard);
      state.powerUpDiscard = [];
      log(state, "Power Up deck reshuffled from discard.");
    } else {
      log(state, "Power Up deck empty: no Power Ups available.");
      return null;
    }
  }
  const next = state.powerUpDeck.shift();
  state.powerUpDiscard.push(next);
  log(state, `Power Up drawn: ${getPowerUpLabel(next)}.`);
  return next;
}

function removePowerUpFromDiscard(state, powerUpId) {
  if (!state.powerUpDiscard) state.powerUpDiscard = [];
  const idx = state.powerUpDiscard.indexOf(powerUpId);
  if (idx >= 0) state.powerUpDiscard.splice(idx, 1);
}

function addPowerUpToDiscard(state, powerUpId) {
  if (!state.powerUpDiscard) state.powerUpDiscard = [];
  state.powerUpDiscard.push(powerUpId);
}

function clearInvinciblePowerUps(state, p, reason) {
  if (!p.invincible) return;
  addPowerUpToDiscard(state, "invincible");
  log(state, `${p.name} discards Invincible (${reason}).`);
  p.invincible = false;
}

function buildChaosEmeraldDeck() {
  return shuffle(CHAOS_EMERALDS.map(card => ({
    ...card,
    spent: false,
    instanceId: uuid()
  })));
}

function getChaosCounts(p) {
  const list = p.chaosEmeralds || [];
  const spent = list.filter(c => c.spent).length;
  return { ready: list.length - spent, spent };
}

function drawChaosEmerald(state) {
  if (!state.chaosEmeraldDeck || !state.chaosEmeraldDeck.length) {
    log(state, "Chaos Emerald deck empty: no Emeralds available.");
    return null;
  }
  const p = state.players[state.activePlayer];
  const card = state.chaosEmeraldDeck.shift();
  p.chaosEmeralds.push(card);
  log(state, `${p.name} gains the ${getChaosEmeraldLabel(card)}.`);
  return true;
}

function spendChaosEmerald(state, emeraldId) {
  if (state.ui?.discard?.open || state.ui?.starPost?.open) {
    log(state, "Resolve the current prompt before spending a Chaos Emerald.");
    return;
  }
  if (state.pendingPowerUp || state.pendingDamage || state.pendingBadnikReward || state.pendingWallClimb || state.pendingAvoid || state.bonusStage?.open) {
    log(state, "Resolve the pending reward before spending a Chaos Emerald.");
    return;
  }
  const p = state.players[state.activePlayer];
  const card = p.chaosEmeralds.find(c => c.id === emeraldId && !c.spent);
  if (!card) {
    log(state, "Chaos Emerald spend failed: no unspent Emerald found.");
    return;
  }
  const colors = Array.isArray(card.diceBonusColors) ? card.diceBonusColors : [];
  if (colors.length !== 2) {
    log(state, "Chaos Emerald dice bonus colors not configured yet.");
    return;
  }
  card.spent = true;
  log(state, `${p.name} spends the ${getChaosEmeraldLabel(card)}.`);
  colors.forEach(color => {
    if (!color) return;
    const d = makeDie(color, rollD6());
    p.dicePool.push(d);
  });
  log(state, "Chaos Emerald bonus: added two dice to the Dice Pool.");
  if (card.extraReward) {
    applyReward(state, card.extraReward);
    log(state, "Chaos Emerald extra reward applied.");
  }
}

function buildBonusStageTiles() {
  const tiles = [];
  const bumperRewards = shuffle([
    ...Array(4).fill(0).map(() => ({ type: "rings", amount: 1 })),
    ...Array(3).fill(0).map(() => ({ type: "boost", amount: 1 }))
  ]);
  const redRewards = shuffle([
    ...Array(2).fill(0).map(() => ({ type: "boost", amount: 1 })),
    ...Array(6).fill(0).map(() => ({ type: "power_up" }))
  ]);

  tiles.push({ id: uuid(), type: "chaos", reward: null, revealed: false });
  bumperRewards.forEach(reward => tiles.push({ id: uuid(), type: "bumper", reward, revealed: false }));
  redRewards.forEach(reward => tiles.push({ id: uuid(), type: "red", reward, revealed: false }));

  return shuffle(tiles);
}

function initBonusStageState() {
  return {
    open: false,
    tiles: buildBonusStageTiles(),
    message: "",
    awaitingExit: false,
    resetOnClose: false,
    activePlayerId: null
  };
}

function ensureBonusStageState(state) {
  if (!state.bonusStage) state.bonusStage = initBonusStageState();
  if (!state.bonusStage.tiles || !state.bonusStage.tiles.length) {
    state.bonusStage.tiles = buildBonusStageTiles();
  }
}

function canStartBonusStage(state) {
  if (!state) return false;
  return !state.pendingPowerUp &&
    !state.pendingDamage &&
    !state.pendingBadnikReward &&
    !state.pendingWallClimb &&
    !state.pendingAvoid &&
    !state.ui?.discard?.open &&
    !state.ui?.starPost?.open;
}

function queueBonusStage(state, reason) {
  if (!state) return;
  if (!canStartBonusStage(state) || state.bonusStage?.open) {
    if (!state.pendingBonusStage) state.pendingBonusStage = { reasons: [] };
    state.pendingBonusStage.reasons.push(reason);
    log(state, `Bonus Stage queued: ${reason}`);
    return;
  }
  enterBonusStage(state, reason);
}

function enterBonusStage(state, reason) {
  ensureBonusStageState(state);
  const stage = state.bonusStage;
  stage.open = true;
  stage.awaitingExit = false;
  stage.resetOnClose = false;
  stage.activePlayerId = state.activePlayer;
  stage.message = reason ? `Bonus Stage: ${reason}` : "Bonus Stage: flip a tile.";
  const p = state.players[state.activePlayer];
  log(state, `${p.name} enters the Bonus Stage.`);
}

function closeBonusStage(state) {
  const stage = state.bonusStage;
  if (!stage) return;
  stage.open = false;
  stage.awaitingExit = false;
  stage.message = "";
  if (stage.resetOnClose) {
    stage.tiles = buildBonusStageTiles();
    stage.resetOnClose = false;
    log(state, "Bonus Stage reset with a new tile grid.");
  }
}

function formatBonusStageRewardLabel(reward) {
  if (!reward) return "";
  if (reward.type === "rings") return "Ring";
  if (reward.type === "boost") return "Boost";
  if (reward.type === "power_up") return "Power Up";
  return formatRewardLabel(reward);
}

function flipBonusStageTile(state, tileId) {
  const stage = state.bonusStage;
  if (!stage || !stage.open || stage.awaitingExit) return;
  if (state.pendingPowerUp || state.pendingBadnikReward || state.pendingDamage || state.pendingWallClimb) {
    log(state, "Resolve the pending reward before flipping another Bonus Stage tile.");
    return;
  }
  const tile = stage.tiles.find(t => t.id === tileId);
  if (!tile || tile.revealed) return;
  tile.revealed = true;

  if (tile.type === "chaos") {
    drawChaosEmerald(state);
    stage.message = "Chaos Emerald found! Bonus Stage cleared.";
    stage.awaitingExit = true;
    stage.resetOnClose = true;
    log(state, "Bonus Stage cleared (Chaos Emerald found).");
    return;
  }

  const reward = tile.reward || null;
  if (reward) applyReward(state, reward);
  const rewardLabel = reward ? formatBonusStageRewardLabel(reward) : "Reward";

  if (tile.type === "red") {
    stage.message = `Red Sphere: ${rewardLabel}. Bonus Stage ends.`;
    stage.awaitingExit = true;
    log(state, "Bonus Stage ends on a Red Sphere.");
  } else {
    stage.message = `Bumper Sphere: ${rewardLabel}. Flip another tile.`;
    log(state, "Bonus Stage continues after Bumper Sphere.");
  }
}

/* =======================
   Zone (simplified)
   ======================= */
function generateZoneCard(genCfg) {
  const bumperCfg = genCfg.bumper || {};
  const maxGroups = bumperCfg.maxGroups ?? 0;
  const groupChance = bumperCfg.groupChance ?? 0;
  const tripleChance = bumperCfg.tripleChance ?? 0.3;
  const colorChance = bumperCfg.colorChance ?? 0.4;

  function rollBaseColor() {
    const r = rng()();
    return r < 0.08 ? DieColor.BLUE : r < 0.16 ? DieColor.YELLOW : r < 0.24 ? DieColor.RED : null;
  }

  function rollBumperColor() {
    const r = rng()();
    return r < 0.34 ? DieColor.BLUE : r < 0.67 ? DieColor.YELLOW : DieColor.RED;
  }

  function rollReward() {
    const rrr = rng()();
    const hr = rng()();
    const baseRewards = [
      { type: "rings", weight: 0.25 },
      { type: "boost", weight: 0.23 },
      { type: "badnik", weight: 0.20 },
      { type: "hazard", weight: 0.05 },
      { type: "lose_die", weight: 0.05 },
      { type: "star_post", weight: 0.07 },
      { type: "time", weight: 0.05 },
      { type: "big_ring", weight: 0.04 },
      { type: "power_up", weight: 0.06 }
    ];
    const multipliers = genCfg.rewardWeightMultipliers || {};
    const weighted = baseRewards.map(entry => ({
      ...entry,
      weight: entry.weight * (multipliers[entry.type] ?? 1)
    }));
    const totalWeight = weighted.reduce((sum, entry) => sum + entry.weight, 0);
    let pick = rng()() * totalWeight;
    let rewardType = weighted[weighted.length - 1].type;
    for (const entry of weighted) {
      if (pick < entry.weight) { rewardType = entry.type; break; }
      pick -= entry.weight;
    }
    if (rewardType === "rings") {
      return { type:"rings", amount: (rrr<0.1?4:(rrr<0.3?3:2)) };
    }
    if (rewardType === "boost") return { type:"boost", amount:1 };
    if (rewardType === "badnik") return { type:"badnik", amount:1 };
    if (rewardType === "hazard") {
      const hazardCfg = genCfg.hazardAmountChances || {};
      const baseTwo = Number.isFinite(hazardCfg.two) ? hazardCfg.two : 0.10;
      const baseThree = Number.isFinite(hazardCfg.three) ? hazardCfg.three : 0.02;
      const two = Math.max(0, Math.min(1, baseTwo));
      const three = Math.max(0, Math.min(1 - two, baseThree));
      const one = Math.max(0, 1 - two - three);
      const amount = hr < one ? 1 : (hr < one + two ? 2 : 3);
      return { type:"hazard", amount };
    }
    if (rewardType === "lose_die") return { type:"lose_die", amount:1 };
    if (rewardType === "star_post") return { type:"star_post", amount:1 };
    if (rewardType === "time") return { type:"time", amount:1 };
    if (rewardType === "big_ring") return { type:"big_ring" };
    return { type:"power_up" };
  }

  const minChallenges = genCfg.challengesMin ?? genCfg.challengesPerCard ?? 7;
  const maxChallenges = genCfg.challengesMax ?? genCfg.challengesPerCard ?? minChallenges;
  const totalSpaces = minChallenges + Math.floor(rng()() * (maxChallenges - minChallenges + 1));
  const splitChance = genCfg.splitChance ?? 0.3;
  const splitStreakChance = genCfg.splitStreakChance ?? splitChance;
  const spaceBackgroundImages = Array.isArray(genCfg.spaceBackgroundImages)
    ? genCfg.spaceBackgroundImages.filter(Boolean)
    : [];
  const defaultSpaceBackgroundImage = genCfg.spaceBackgroundImage || null;

  const spaces = [];
  let hasSplit = false;
  let prevSplit = false;
  let prevSpaceRewardTypes = new Set();
  for (let i = 0; i < totalSpaces; i++) {
    const chance = prevSplit ? splitStreakChance : splitChance;
    const isSplit = rng()() < chance;
    prevSplit = isSplit;
    if (isSplit) hasSplit = true;
    const lanes = isSplit ? ["top", "bottom"] : ["shared"];
    const spaceRewardTypes = new Set();
    const challenges = lanes.map(lane => {
      const n = rollD6();
      const color = isSplit ? rollBaseColor() : null;
      let reward = rollReward();
      let attempts = 0;
      while ((prevSpaceRewardTypes.has(reward?.type) || spaceRewardTypes.has(reward?.type)) && attempts < 10) {
        reward = rollReward();
        attempts++;
      }
      if (reward?.type) spaceRewardTypes.add(reward.type);
      return { id: uuid(), n, color, cleared:false, reward, lane, next: [] };
    });
    prevSpaceRewardTypes = spaceRewardTypes;
    const backgroundImage = spaceBackgroundImages.length
      ? spaceBackgroundImages[Math.floor(rng()() * spaceBackgroundImages.length)]
      : defaultSpaceBackgroundImage;
    spaces.push({ id: uuid(), challenges, backgroundImage });
  }

  function applyBumperGroupsToList(list, allowColor = true) {
    if (!list.length) return;
    const occupied = Array(list.length).fill(false);
    const groupCount = Math.min(maxGroups, list.length > 2 ? maxGroups : 0);
    for (let g = 0; g < groupCount; g++) {
      if (rng()() > groupChance) continue;
      const length = rng()() < tripleChance ? 3 : 2;
      if (length > list.length) continue;
      let placed = false;
      for (let attempts = 0; attempts < 25; attempts++) {
        const start = Math.floor(rng()() * (list.length - length + 1));
        if (occupied.slice(start, start + length).some(Boolean)) continue;
        const groupId = uuid();
        const bumperColor = allowColor && rng()() < colorChance ? rollBumperColor() : null;
        for (let i = 0; i < length; i++) {
          const ch = list[start + i];
          ch.bumper = { id: groupId, index: i, length };
          ch.n = null;
          ch.color = bumperColor;
          occupied[start + i] = true;
        }
        placed = true;
        break;
      }
      if (!placed) break;
    }
  }

  if (!hasSplit) {
    applyBumperGroupsToList(spaces.map(space => space.challenges[0]), false);
  } else {
    const topLane = [];
    const bottomLane = [];
    for (const space of spaces) {
      const top = space.challenges.find(ch => ch.lane === "top");
      const bottom = space.challenges.find(ch => ch.lane === "bottom");
      if (top) topLane.push(top);
      if (bottom) bottomLane.push(bottom);
    }
    applyBumperGroupsToList(topLane, true);
    applyBumperGroupsToList(bottomLane, true);
  }

  for (let i = 0; i < spaces.length - 1; i++) {
    const current = spaces[i].challenges;
    const next = spaces[i + 1].challenges;
    if (current.length === 1) {
      current[0].next = next.map(ch => ch.id);
      continue;
    }
    const top = current.find(ch => ch.lane === "top");
    const bottom = current.find(ch => ch.lane === "bottom");
    if (next.length === 1) {
      const nextId = next[0].id;
      if (top) top.next = [nextId];
      if (bottom) bottom.next = [nextId];
    } else {
      const nextTop = next.find(ch => ch.lane === "top");
      const nextBottom = next.find(ch => ch.lane === "bottom");
      if (top && nextTop) top.next = [nextTop.id];
      if (bottom && nextBottom) bottom.next = [nextBottom.id];
    }
  }

  return { id: uuid(), spaces, bumperLocks: {}, lastClearedChallengeId: null };
}

function generateZone(genCfg, playerCount) {
  const deckCount = genCfg.deckCounts?.[playerCount] || genCfg.deckCounts?.[2] || 8;
  const deck = [];
  for (let i=0;i<deckCount;i++) deck.push(generateZoneCard(genCfg));
  shuffle(deck);

  const routes = ["Top","Middle","Bottom"].map(name => ({
    id: uuid(),
    name,
    activeCard: deck.shift() || null
  }));

  return { routes, deck, bossFightReady:false };
}

function generateActBoard(genCfg) {
  const routes = ["Top","Middle","Bottom"].map(name => ({
    id: uuid(),
    name,
    reward: genCfg.actBoardRewards?.[name] || { type:"rings", amount:1 }
  }));
  return {
    name: genCfg.actBoardName || "Act 1",
    routes,
    cardGradient: genCfg.cardGradient || null,
    arrowColors: genCfg.actBoardArrowColors || null
  };
}

function buildSecretPassageCard() {
  const card = clone(SECRET_PASSAGE_TEMPLATE);
  card.lastClearedChallengeId = null;
  card.bumperLocks = {};
  for (const space of card.spaces || []) {
    for (const ch of (space.challenges || [])) {
      if (ch.cleared == null) ch.cleared = false;
    }
  }
  return card;
}

function getZoneConfig(zoneId) {
  const zones = CONFIG.zones || {};
  if (zoneId && zones[zoneId]) return zones[zoneId];
  const first = Object.values(zones)[0];
  return first || { id: "default", name: "Act 1", zoneGenerator: {} };
}

function resetBuddyFlightForTurn(state) {
  if (!state?.buddyFlight) return;
  const p = state.players[state.activePlayer];
  if (!p || p.character !== "Tails") return;
  state.buddyFlight.value = 2;
  log(state, "Buddy Flight die set to 2 (Tails' turn).");
}

/* =======================
   Game creation
   ======================= */
function newGame({ playerCount, seedStr, characterSelections, zoneId }) {
  const seed = hashSeed(seedStr);
  initGameRng(seed);

  const charNames = Object.keys(CONFIG.characters);
  const requested = Array.isArray(characterSelections) ? characterSelections : [];
  const used = new Set();
  const finalChars = [];
  for (let i = 0; i < playerCount; i++) {
    let choice = requested[i];
    if (!charNames.includes(choice) || used.has(choice)) {
      choice = charNames.find(c => !used.has(c)) || charNames[i % charNames.length];
    }
    finalChars.push(choice);
    used.add(choice);
  }

  const players = Array.from({length: playerCount}, (_,i) => {
    const character = finalChars[i];
    const rollActions = CONFIG.characters[character].rollActions;
    return {
      id: i,
      name: `P${i+1}`,
      character,
      chosenRollAction: rollActions[0].name,
      rollActionSelectedThisTurn: false,

      lives: 3,
      boost: 1,
      heldRings: 0,
      savedRings: 0,
      zoneCardsCompleted: 0,
      animalTokens: 0,
      timeTokensTaken: 0,
      chaosEmeralds: [],
      hyperRing: false,
      invincible: false,
      shield: null,
      flameShieldArmed: false,
      lightningShieldArmed: false,
      blueShieldLostThisTurn: false,

      badniks: [],
      dicePool: [],
      selectedDieId: null,

      invulnerable: false,
      turnsTaken: 0,
      spentSinceLastReroll: 0,
      hasRerolledThisTurn: false,
      propellerTailBonusGivenSinceReroll: false,
      oncePerTurn: {},
      lastChainSpendRule: null, // used for Glide-like chaining
    };
  });

  const zoneConfig = getZoneConfig(zoneId);
  const zoneGen = { ...CONFIG.zoneGenerator, ...zoneConfig.zoneGenerator };
  const badnikDeckId = zoneConfig.badnikDeckId || "default";
  const badnikDeckSeed = BADNIK_DECKS[badnikDeckId] || BADNIK_DECKS.default || [];
  const badnikDeck = shuffle(clone(badnikDeckSeed));
  const zone = generateZone(zoneGen, playerCount);
  const actBoard = generateActBoard(zoneGen);
  const powerUpDeck = buildPowerUpDeck();
  const chaosEmeraldDeck = buildChaosEmeraldDeck();
  const bonusStage = initBonusStageState();
  const buddyFlight = finalChars.includes("Tails") ? { value: 0 } : null;
  const secretPassage = finalChars.includes("Knuckles")
    ? { card: buildSecretPassageCard(), completed: false }
    : null;

  const state = {
    phase: "ROLL_ACTION", // ROLL_ACTION | SPENDING | AVOID | REROLL | END_TURN | GAME_OVER
    activePlayer: 0,
    timeTokens: 7,
    players,
    buddyFlight,
    badnikDeck,
    badnikDiscard: [],
    pendingBadnikReward: null,
    powerUpDeck,
    powerUpDiscard: [],
    chaosEmeraldDeck,
    zone,
    actBoard,
    ui: { spend: null, discard: null, starPost: null },
    pendingPowerUp: null,
    pendingPowerUpQueue: [],
    pendingDamage: null,
    pendingWallClimb: null,
    pendingAvoid: null,
    pendingBonusStage: null,
    bonusStage,
    zoneId: zoneConfig.id,
    secretPassage,
    log: [`Game started (${playerCount}P), seed="${seedStr}"`]
  };
  if (state.players[0]) state.players[0].turnsTaken = 1;
  resetBuddyFlightForTurn(state);
  return state;
}

/* =======================
   Core rules: damage / hazard / badnik draw
   ======================= */
function takeDamage(state, reason) {
  const p = state.players[state.activePlayer];

  if (p.invulnerable) {
    log(state, `No damage (invulnerable): ${reason}`);
    return state;
  }

  if (p.invincible && p.dicePool.length > 0) {
    clearSpendUi(state);
    clearDiscardUi(state);
    clearStarPostUi(state);
    state.pendingDamage = {
      reason,
      selectedDieId: null,
      resumePhase: state.phase,
      resetAfterReroll: state.phase === "REROLL"
    };
    log(state, `${p.name} may discard a die to ignore damage (Invincible).`);
    return state;
  }

  if (p.shield) {
    const shieldType = p.shield.type;
    p.shield = null;
    if (shieldType === "blue") p.blueShieldLostThisTurn = true;
    addPowerUpToDiscard(state, getShieldPowerUpId(shieldType));
    log(state, `${p.name} ignores damage with ${getShieldLabel(shieldType)} (shield discarded).`);
    if (state.phase === "AVOID" || p.dicePool.length === 0) {
      state.phase = "END_TURN";
    }
    return state;
  }

  return applyDamage(state, reason);
}

function applyDamage(state, reason) {
  const p = state.players[state.activePlayer];
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);

  const heldBefore = p.heldRings;
  let lost = 0;
  if (heldBefore > 0 && p.hyperRing) {
    const kept = Math.ceil(heldBefore / 2);
    lost = heldBefore - kept;
    p.heldRings = kept;
    log(state, `DAMAGE (${reason}): Hyper Ring keeps ${kept} Held Rings (lost ${lost}).`);
  } else {
    lost = heldBefore;
    p.heldRings = 0;
    if (heldBefore > 0) {
      log(state, `DAMAGE (${reason}): ${p.name} loses all Held Rings (${heldBefore}).`);
    }
  }

  if (heldBefore > 0) {
    state.pendingDamage = null;
    makeInvulnerable(p);
    state.phase = "SPENDING";
    log(state, `Damage taken: ${p.name} becomes invulnerable and continues turn.`);
    return state;
  }

  if (heldBefore === 0) {
    p.lives -= 1;
    log(state, `DAMAGE (${reason}): No held rings -> ${p.name} loses 1 Life (now ${p.lives}).`);
    if (p.hyperRing) {
      p.hyperRing = false;
      addPowerUpToDiscard(state, "hyper_ring");
      log(state, `${p.name} loses Hyper Ring after losing a Life.`);
    }
  }

  // Clear badniks and dice pool, end turn without time token
  if (p.badniks.length) {
    state.badnikDiscard.push(...p.badniks);
  }
  p.badniks = [];
  p.dicePool = [];
  p.selectedDieId = null;
  p.spentSinceLastReroll = 0;
  p.hasRerolledThisTurn = false;
  p.propellerTailBonusGivenSinceReroll = false;
  p.lastChainSpendRule = null;
  clearInvinciblePowerUps(state, p, "turn end");
  p.flameShieldArmed = false;
  p.lightningShieldArmed = false;
  state.pendingDamage = null;

  makeInvulnerable(p);
  state.phase = "END_TURN";

  const over = isGameOver(state);
  if (over) {
    state.phase = "GAME_OVER";
    log(state, `GAME OVER: ${over}`);
  } else {
    log(state, "Turn ends immediately (no Time Token taken).");
  }
  return state;
}

function hazardRoll(state, count = 1) {
  const p = state.players[state.activePlayer];
  const rolls = [];
  const total = Math.max(1, count || 1);
  for (let i = 0; i < total; i++) rolls.push(rollD6());
  log(state, `Hazard dice rolled (x${total}): ${rolls.join(", ")}`);
  const poolValues = new Set(p.dicePool.map(d => d.value));
  const matchedValues = [...new Set(rolls.filter(v => poolValues.has(v)))];
  if (matchedValues.length) {
    takeDamage(state, `Hazard matched a die value (${matchedValues.join(", ")})`);
  } else {
    log(state, "Hazard did not match Dice Pool -> no damage.");
  }
}

function normalizeBadnikTiming(value) {
  if (!value) return null;
  return value.toString().trim().toUpperCase().replace(/\s+/g, "_").replace(/-/g, "_");
}

function getBadnikAbilityTiming(b) {
  const raw = b?.ability?.timing || b?.ability?.type;
  return normalizeBadnikTiming(raw);
}

function getBadnikHitsRequired(b) {
  if (!b) return 1;
  if (Number.isFinite(b.hitsRequired)) return Math.max(1, b.hitsRequired);
  return 1;
}

function initBadnikState(b) {
  if (!b) return b;
  if (!Number.isFinite(b.hitsTaken)) b.hitsTaken = 0;
  if (b.flipped == null) b.flipped = false;
  if (!Number.isFinite(b.drawnTurn)) b.drawnTurn = -1;
  return b;
}

function getBadnikTargetConstraints(b) {
  return b?.targeting || b?.targetConstraints || b?.constraints || b?.ability?.targeting || null;
}

function isBadnikTargetEligible(state, p, b) {
  const constraints = getBadnikTargetConstraints(b);
  if (!constraints) return true;
  const parity = constraints.diceCountParity || constraints.diceParity || null;
  if (parity) {
    const isEven = p.dicePool.length % 2 === 0;
    if (parity.toString().toLowerCase() === "even" && !isEven) return false;
    if (parity.toString().toLowerCase() === "odd" && isEven) return false;
  }
  const requiresFirst = constraints.requiresFirstSpend ?? constraints.requiresFirstDie ?? constraints.firstDieOnly ?? constraints.firstSpendOnly;
  if (requiresFirst && p.spentSinceLastReroll > 0) return false;
  return true;
}

function discardBadnikFromPlayer(state, p, b, reason) {
  const idx = p.badniks.indexOf(b);
  if (idx === -1) return false;
  p.badniks.splice(idx, 1);
  state.badnikDiscard.push(b);
  if (reason) log(state, reason);
  return true;
}

function applyBadnikAbilityEffect(state, p, b, ability, context = {}) {
  if (!ability) return { halt: false };
  let effect = normalizeBadnikTiming(ability.effect || ability.action || ability.result);
  if (!effect && ability.damage) effect = "DAMAGE";
  if (!effect) return { halt: false };
  if (effect === "DAMAGE") {
    log(state, `Badnik ability (${b.name}): damage.`);
    takeDamage(state, `Badnik ability (${b.name})`);
    if (ability.discardOnTrigger || ability.discardSelf) {
      discardBadnikFromPlayer(state, p, b, `${p.name} discards Badnik "${b.name}" after its ability triggers.`);
    }
    return { halt: true };
  }
  if (effect === "HAZARD_IF_NO_YELLOW") {
    const spentDie = context?.spentDie;
    const remaining = spentDie
      ? p.dicePool.filter(d => d.id !== spentDie.id)
      : p.dicePool;
    const hasYellow = remaining.some(d => d.color === DieColor.YELLOW);
    if (!hasYellow) {
      const count = Number.isFinite(ability.amount) ? ability.amount : 2;
      log(state, `Badnik ability (${b.name}): no yellow dice -> roll ${count} hazard dice.`);
      hazardRoll(state, count);
      if (state.pendingDamage) return { halt: true };
    }
    return { halt: false };
  }
  if (effect === "DISCARD_RING") {
    const before = p.heldRings || 0;
    if (before > 0) {
      p.heldRings = Math.max(0, before - 1);
      log(state, `Badnik ability (${b.name}): discard 1 held ring (${before} -> ${p.heldRings}).`);
    } else {
      log(state, `Badnik ability (${b.name}): discard 1 held ring (none to lose).`);
    }
    return { halt: false };
  }
  if (effect === "LOG") {
    const msg = ability.message || `Badnik ability triggered: ${b.name}.`;
    log(state, msg);
  }
  return { halt: false };
}

function triggerBadnikAbility(state, p, b, timing, context = {}) {
  const abilityTiming = getBadnikAbilityTiming(b);
  const normalizedTiming = normalizeBadnikTiming(timing);
  if (!abilityTiming || abilityTiming !== normalizedTiming) return { halt: false };
  if (normalizedTiming === "END_TURN") {
    const drawnTurn = Number.isFinite(b.drawnTurn) ? b.drawnTurn : -1;
    if (drawnTurn === p.turnsTaken) return { halt: false };
  }
  return applyBadnikAbilityEffect(state, p, b, b.ability, context);
}

function runBadnikAbilities(state, timing, context = {}) {
  const p = getActivePlayer(state);
  const normalizedTiming = normalizeBadnikTiming(timing);
  const phaseBefore = state.phase;
  for (const b of [...p.badniks]) {
    const result = triggerBadnikAbility(state, p, b, normalizedTiming, context);
    if (result?.halt) return { halt: true };
    if (state.pendingDamage || state.phase !== phaseBefore) return { halt: true };
  }
  return { halt: false };
}

function drawBadnik(state, targetPlayer) {
  const p = targetPlayer;
  if (p.badniks.length >= 3) { log(state, `${p.name} cannot draw more Badniks (already 3).`); return; }
  if (!state.badnikDeck.length) {
    state.badnikDeck = shuffle(state.badnikDiscard);
    state.badnikDiscard = [];
    log(state, `Badnik deck reshuffled from discard.`);
  }
  const b = initBadnikState(state.badnikDeck.shift());
  b.drawnTurn = Number.isFinite(p.turnsTaken) ? p.turnsTaken : 0;
  p.badniks.push(b);
  log(state, `${p.name} draws Badnik: ${b.name}`);
}

function getEligibleBadnikTargets(state) {
  return state.players.filter(pl => pl.badniks.length < 3);
}

function queueBadnikRewardChoice(state, count = 1) {
  for (let i = 0; i < count; i++) {
    const eligible = getEligibleBadnikTargets(state);
    if (!eligible.length) {
      log(state, "Badnik reward: no eligible players can draw (all at 3).");
      continue;
    }
    if (state.players.length === 1) {
      drawBadnik(state, eligible[0]);
      log(state, "Badnik reward: solo game -> extra Badnik assigned to the only player.");
      continue;
    }
    if (!state.pendingBadnikReward) {
      state.pendingBadnikReward = { remaining: 0 };
    }
    state.pendingBadnikReward.remaining += 1;
    log(state, "Badnik reward: choose a player with fewer than 3 Badniks to draw.");
  }
}

function resolveBadnikRewardChoice(state, targetPlayerId) {
  const pending = state.pendingBadnikReward;
  if (!pending) return;
  const target = state.players.find(pl => pl.id === targetPlayerId);
  if (!target) return;
  if (target.badniks.length >= 3) {
    log(state, `${target.name} cannot draw more Badniks (already 3).`);
    return;
  }
  drawBadnik(state, target);
  pending.remaining -= 1;
  if (pending.remaining <= 0) {
    state.pendingBadnikReward = null;
    return;
  }
  if (!getEligibleBadnikTargets(state).length) {
    log(state, "Badnik reward: no eligible players can draw (all at 3).");
    state.pendingBadnikReward = null;
  }
}

function queuePowerUp(state, powerUpId) {
  state.pendingPowerUpQueue.push(powerUpId);
  log(state, `Power Up queued: ${getPowerUpLabel(powerUpId)}.`);
}

function processQueuedPowerUps(state) {
  if (state.pendingPowerUp || !state.pendingPowerUpQueue.length) return;
  const next = state.pendingPowerUpQueue.shift();
  applyPowerUp(state, next);
}

function applyPowerUp(state, powerUpId) {
  const p = state.players[state.activePlayer];
  if (powerUpId === "super_ring") {
    p.heldRings += 5;
    log(state, `Power Up: Super Ring (+5 Rings). Held=${p.heldRings}`);
    return;
  }
  if (powerUpId === "hyper_ring") {
    p.hyperRing = true;
    removePowerUpFromDiscard(state, powerUpId);
    log(state, "Power Up: Hyper Ring (keep half held Rings when damaged).");
    return;
  }
  if (powerUpId === "power_sneakers") {
    p.boost += 2;
    log(state, `Power Up: Power Sneakers (+2 Boost). Boost=${p.boost}`);
    return;
  }
  if (powerUpId === "one_up") {
    if (state.pendingPowerUp) return queuePowerUp(state, powerUpId);
    state.pendingPowerUp = { kind: "one_up" };
    log(state, "Power Up: 1-Up. Choose a die color to add to your Dice Pool.");
    return;
  }
  if (powerUpId === "invincible") {
    if (p.invincible) {
      addPowerUpToDiscard(state, powerUpId);
      log(state, "Power Up: Invincible already held -> drawn Invincible discarded.");
      return;
    }
    p.invincible = true;
    removePowerUpFromDiscard(state, powerUpId);
    log(state, "Power Up: Invincible (discard a die to ignore damage this turn).");
    return;
  }
  if (powerUpId === "eggman_mark") {
    if (state.pendingPowerUp) return queuePowerUp(state, powerUpId);
    state.pendingPowerUp = { kind: "eggman_mark" };
    log(state, "Power Up: Eggman Mark. Choose a player to receive a Badnik.");
    return;
  }
  if (isShieldPowerUp(powerUpId)) {
    const newShield = getShieldTypeFromPowerUp(powerUpId);
    if (!p.shield) {
      p.shield = { type: newShield };
      removePowerUpFromDiscard(state, powerUpId);
      log(state, `Power Up: ${getShieldLabel(newShield)} equipped.`);
      return;
    }
    if (state.pendingPowerUp) return queuePowerUp(state, powerUpId);
    state.pendingPowerUp = { kind: "shield_swap", newShield };
    log(state, `${p.name} drew ${getShieldLabel(newShield)} but already has ${getShieldLabel(p.shield.type)}.`);
    return;
  }
  log(state, `Unknown Power Up: ${powerUpId}`);
}

function resolveEggmanMark(state, targetPlayerId) {
  const target = state.players.find(pl => pl.id === targetPlayerId);
  if (!target) return;
  drawBadnik(state, target);
  state.pendingPowerUp = null;
  processQueuedPowerUps(state);
}

function resolveOneUp(state, color) {
  const p = state.players[state.activePlayer];
  const pending = state.pendingPowerUp;
  if (!pending || pending.kind !== "one_up") return;
  const d = makeDie(color, rollD6());
  p.dicePool.push(d);
  log(state, `${p.name} gains a ${color.toUpperCase()} die from 1-Up (${d.value}).`);
  state.pendingPowerUp = null;
  processQueuedPowerUps(state);
}

function resolveAddDice(state, color) {
  const p = state.players[state.activePlayer];
  const pending = state.pendingPowerUp;
  if (!pending || pending.kind !== "add_dice") return;
  const d = makeDie(color, rollD6());
  p.dicePool.push(d);
  log(state, `${p.name} gains a ${color.toUpperCase()} die (${d.value}).`);
  state.pendingPowerUp = null;
  processQueuedPowerUps(state);
}

function resolveShieldSwap(state, keepCurrent) {
  const p = state.players[state.activePlayer];
  const pending = state.pendingPowerUp;
  if (!pending || pending.kind !== "shield_swap") return;
  if (keepCurrent) {
    log(state, `${p.name} keeps ${getShieldLabel(p.shield.type)} and discards ${getShieldLabel(pending.newShield)}.`);
  } else {
    log(state, `${p.name} swaps to ${getShieldLabel(pending.newShield)} (discarded ${getShieldLabel(p.shield.type)}).`);
    addPowerUpToDiscard(state, getShieldPowerUpId(p.shield.type));
    p.shield = { type: pending.newShield };
    removePowerUpFromDiscard(state, getShieldPowerUpId(pending.newShield));
  }
  state.pendingPowerUp = null;
  processQueuedPowerUps(state);
}

function maybeApplyLightningShield(state, reward) {
  const p = state.players[state.activePlayer];
  if (!p.shield || p.shield.type !== "lightning") return reward;
  if (!p.lightningShieldArmed || p.oncePerTurn.lightningShieldUsed) return reward;
  p.lightningShieldArmed = false;
  p.oncePerTurn.lightningShieldUsed = true;
  const amount = reward.type === "rings" ? reward.amount * 2 : 2;
  log(state, `${p.name} Lightning Shield: reward changed to rings x2 (${amount}).`);
  return { type:"rings", amount };
}

function confirmInvincibleDiscard(state) {
  const p = state.players[state.activePlayer];
  const pending = state.pendingDamage;
  if (!pending || !pending.selectedDieId) return;
  const idx = p.dicePool.findIndex(d => d.id === pending.selectedDieId);
  if (idx < 0) return;
  const removed = p.dicePool.splice(idx, 1)[0];
  if (p.selectedDieId === removed.id) p.selectedDieId = null;
  state.pendingDamage = null;
  log(state, `${p.name} uses Invincible: discards ${removed.color.toUpperCase()}-${removed.value} to ignore damage.`);
  if (pending.resetAfterReroll) {
    p.spentSinceLastReroll = 0;
    p.propellerTailBonusGivenSinceReroll = false;
    p.lastChainSpendRule = null;
    state.phase = "SPENDING";
  } else if (pending.resumePhase) {
    state.phase = pending.resumePhase;
  }
}

function declineInvincible(state) {
  const pending = state.pendingDamage;
  if (!pending) return;
  state.pendingDamage = null;
  applyDamage(state, pending.reason);
}

function applyReward(state, reward) {
  const p = state.players[state.activePlayer];
  if (!reward) return;
  const effectiveReward = maybeApplyLightningShield(state, reward);
  if (effectiveReward.type === "power_up" && hasBadnikRule(state, "no_power_ups")) {
    log(state, `Power Up blocked by Badnik ability (no power ups).`);
    return;
  }
  if (effectiveReward.type === "rings") {
    p.heldRings += effectiveReward.amount;
    log(state, `Reward: +${effectiveReward.amount} Rings (Held=${p.heldRings})`);
  } else if (effectiveReward.type === "boost") {
    p.boost += effectiveReward.amount;
    log(state, `Reward: +${effectiveReward.amount} Boost (Boost=${p.boost})`);
  } else if (effectiveReward.type === "time") {
    if (state.timeTokens <= 0) {
      log(state, "Reward: Time Token (none available).");
    } else {
      state.timeTokens -= 1;
      p.timeTokensTaken += 1;
      log(state, `Reward: +1 Time Token (Time left: ${state.timeTokens}).`);
    }
  } else if (effectiveReward.type === "badnik") {
    for (let i=0;i<effectiveReward.amount;i++) {
      drawBadnik(state, p);
      queueBadnikRewardChoice(state, 1);
    }
  } else if (effectiveReward.type === "hazard") {
    hazardRoll(state, effectiveReward.amount);
  } else if (effectiveReward.type === "lose_die") {
    queueLoseDieReward(state, "reward");
  } else if (effectiveReward.type === "star_post") {
    queueStarPostReward(state, "reward");
  } else if (effectiveReward.type === "big_ring") {
    queueBonusStage(state, "Big Ring reward");
  } else if (effectiveReward.type === "add_dice") {
    if (state.pendingPowerUp) {
      log(state, "Add Dice reward pending: resolve current choice first.");
      return;
    }
    state.pendingPowerUp = { kind: "add_dice" };
    log(state, "Reward: Add Dice. Choose a die color to add.");
  } else if (effectiveReward.type === "power_up") {
    const powerUpId = effectiveReward.powerUp || drawPowerUp(state);
    if (!powerUpId) return;
    if (effectiveReward.powerUp) {
      if (!state.powerUpDiscard) state.powerUpDiscard = [];
      state.powerUpDiscard.push(powerUpId);
    }
    if (state.pendingPowerUp) {
      queuePowerUp(state, powerUpId);
    } else {
      applyPowerUp(state, powerUpId);
    }
  }
}

function completeZoneCard(state, route) {
  const card = route.activeCard;
  if (!card) return;
  if (!isCardComplete(card)) return;

  const p = state.players[state.activePlayer];
  p.zoneCardsCompleted = (p.zoneCardsCompleted || 0) + 1;
  log(state, `${p.name} completed a Zone Card on ${route.name} Route (total ${p.zoneCardsCompleted}).`);

  const actReward = getActBoardReward(state, route.name);
  if (actReward) {
    applyReward(state, actReward);
    log(state, `Act Board reward for ${route.name} Route: ${formatRewardLabel(actReward)}.`);
  }

  if (state.zone.deck.length) {
    route.activeCard = state.zone.deck.shift();
    log(state, `New Zone Card dealt to ${route.name} Route. (${state.zone.deck.length} left)`);
  } else {
    route.activeCard = null;
    state.zone.bossFightReady = true;
    log(state, "Zone Card Deck empty -> Boss Fight should begin (not implemented).");
  }
}

function completeSecretPassage(state) {
  const card = state.secretPassage?.card;
  if (!card) return;
  if (!isCardComplete(card)) return;
  const p = getActivePlayer(state);
  p.zoneCardsCompleted = (p.zoneCardsCompleted || 0) + 1;
  log(state, `${p.name} completed the Secret Passage (total ${p.zoneCardsCompleted}).`);
  state.secretPassage.completed = true;
  state.secretPassage.card = null;
  applyReward(state, { type:"big_ring" });
  log(state, "Secret Passage reward: Big Ring.");
}

function clearSpendUi(state) {
  if (state?.ui) state.ui.spend = null;
}

function clearDiscardUi(state) {
  if (state?.ui) state.ui.discard = null;
}

function clearStarPostUi(state) {
  if (state?.ui) state.ui.starPost = null;
}

function startAvoidPhase(state, reason) {
  state.pendingAvoid = { reason };
  state.phase = "AVOID";
  log(state, `AVOID: ${reason}`);
}

function resolveAvoidTakeDamage(state) {
  const pending = state.pendingAvoid;
  if (!pending) return state;
  state.pendingAvoid = null;
  return takeDamage(state, pending.reason);
}

function resolveAvoidBoost(state) {
  const p = getActivePlayer(state);
  if (!state.pendingAvoid) return state;
  if (p.boost <= 0) {
    log(state, `${p.name} has no Boost tokens to avoid damage.`);
    return state;
  }
  p.boost -= 1;
  log(state, `${p.name} spends 1 Boost to avoid damage and reroll the Dice Pool.`);
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);
  state.pendingAvoid = null;
  state.phase = "REROLL";
  return rerollStep(state);
}

function resolveAvoidBubble(state) {
  const p = getActivePlayer(state);
  if (!state.pendingAvoid) return state;
  if (!p.shield || p.shield.type !== "bubble") {
    log(state, "Bubble Shield not available.");
    return state;
  }
  if (p.oncePerTurn.bubbleShieldUsed) {
    log(state, "Bubble Shield already used this turn.");
    return state;
  }
  const target = p.dicePool.find(d => d.id === p.selectedDieId) || (p.dicePool.length === 1 ? p.dicePool[0] : null);
  if (!target) {
    log(state, `${p.name} Bubble Shield: select a die to reroll.`);
    return state;
  }
  target.value = rollD6();
  p.oncePerTurn.bubbleShieldUsed = true;
  log(state, `${p.name} Bubble Shield rerolls ${target.color.toUpperCase()}-${target.value}.`);
  state.pendingAvoid = null;
  state.phase = "SPENDING";
  return state;
}

function formatRewardLabel(reward) {
  if (!reward) return "none";
  if (reward.type === "lose_die") return "lose die";
  if (reward.type === "time") return "time";
  if (reward.type === "add_dice") return "add dice";
  if (reward.type === "star_post") return "star post";
  if (reward.type === "big_ring") return "big ring";
  if (reward.type === "power_up") return "power up";
  if (reward.amount != null) return `${reward.type} x${reward.amount}`;
  return `${reward.type}`;
}

function formatRewardDisplayHtml(reward) {
  if (!reward) return "none";
  if (reward.type === "power_up") {
    return `<span class="reward-icon" title="power up"><img src="img/power_up.png" alt="Power Up"></span>`;
  }
  if (reward.type === "boost") {
    return `<span class="reward-icon" title="boost"><img src="img/boost.png" alt="Boost"></span>`;
  }
  if (reward.type === "star_post") {
    return `<span class="reward-icon" title="star post"><img src="img/star_post.png" alt="Star Post"></span>`;
  }
  if (reward.type === "time") {
    return `<span class="reward-icon" title="time"><img src="img/time.png" alt="Time"></span>`;
  }
  return formatRewardLabel(reward);
}

function formatPixelScore(value) {
  const text = String(value ?? 0);
  const parts = [];
  for (const ch of text) {
    if (ch >= "0" && ch <= "9") {
      parts.push(`<img class="score-digit" src="img/${ch}.png" alt="${ch}">`);
    } else if (ch === "-") {
      parts.push(`<img class="score-digit" src="img/-.png" alt="minus">`);
    }
  }
  if (!parts.length) return `<span class="score-digits">0</span>`;
  return `<span class="score-digits">${parts.join("")}</span>`;
}

function formatActRewardHtml(reward) {
  if (!reward) return `<div class="act-reward-circle"><span class="act-reward-text">NONE</span></div>`;
  if (reward.type === "big_ring") {
    return `
      <div class="act-reward-circle">
        <img src="img/big_ring.png" alt="Big Ring" class="reward-big-ring">
      </div>
    `;
  }
  if (reward.type === "rings") {
    const amount = reward.amount ?? 1;
    const ringSrc =
      amount === 2 ? "img/ring_2.png" :
      amount === 3 ? "img/ring_3.png" :
      amount === 4 ? "img/ring_4.png" :
      amount === 5 ? "img/ring_5.png" :
      "img/ring.png";
    const ringClass = amount === 2 ? "reward-ring-2" : "";
    return `
      <div class="act-reward-circle">
        <img src="${ringSrc}" alt="Rings" class="${ringClass}">
      </div>
    `;
  }
  if (reward.type === "power_up") {
    return `
      <div class="act-reward-circle">
        <img src="img/power_up.png" alt="Power Up">
      </div>
    `;
  }
  if (reward.type === "badnik") {
    return `
      <div class="act-reward-circle">
        <img src="img/badnik.png" alt="Badnik" class="reward-badnik">
      </div>
    `;
  }
  if (reward.type === "boost") {
    return `
      <div class="act-reward-circle">
        <img src="img/boost.png" alt="Boost">
      </div>
    `;
  }
  if (reward.type === "time") {
    return `
      <div class="act-reward-circle">
        <img src="img/time.png" alt="Time" class="reward-time">
      </div>
    `;
  }
  if (reward.type === "star_post") {
    return `
      <div class="act-reward-circle">
        <div class="reward-inner-mask">
          <img class="reward-star-post" src="img/star_post.png" alt="Star Post">
        </div>
      </div>
    `;
  }
  if (reward.type === "badnik") {
    return `<div class="act-reward-circle"><span class="act-reward-text">BADNIK</span></div>`;
  }
  if (reward.type === "hazard") {
    const amount = reward.amount ?? 1;
    if (amount === 1) {
      return `
        <div class="act-reward-circle">
          <img src="img/dice_black.png" alt="Hazard Die">
        </div>
      `;
    }
    if (amount === 2) {
      return `
        <div class="act-reward-circle">
          <img src="img/hazard_2.png" alt="Hazard x2" class="reward-hazard-2">
        </div>
      `;
    }
    if (amount === 3) {
      return `
        <div class="act-reward-circle">
          <img src="img/hazard_3.png" alt="Hazard x3" class="reward-hazard-3">
        </div>
      `;
    }
    const label = `HAZARD x${amount}`;
    return `<div class="act-reward-circle"><span class="act-reward-text">${label}</span></div>`;
  }
  if (reward.type === "add_dice") {
    return `<div class="act-reward-circle"><span class="act-reward-text">ADD DICE</span></div>`;
  }
  if (reward.type === "lose_die") {
    return `
      <div class="act-reward-circle">
        <img src="img/lose_die.png" alt="Lose Die">
      </div>
    `;
  }
  return `<div class="act-reward-circle"><span class="act-reward-text">${escapeHtml(formatRewardLabel(reward))}</span></div>`;
}

function getActBoardReward(state, routeName) {
  const route = state?.actBoard?.routes?.find(r => r.name === routeName);
  return route?.reward || null;
}

function queueLoseDieReward(state, reason) {
  const p = getActivePlayer(state);
  if (!state.ui) state.ui = { spend: null, discard: null, starPost: null };
  if (state.ui.discard?.open) {
    log(state, `Lose a die (${reason}): discard already pending.`);
    return;
  }
  if (!p.dicePool.length) {
    log(state, `Lose a die (${reason}): no dice in pool.`);
    return;
  }
  if (p.dicePool.length === 1) {
    const removed = p.dicePool.pop();
    log(state, `Lose a die (${reason}): discarded ${removed.color.toUpperCase()}-${removed.value}.`);
    p.selectedDieId = null;
    return;
  }
  state.ui.discard = {
    open: true,
    reason,
    selectedDieId: null,
    postSpend: null
  };
  log(state, `Lose a die (${reason}): choose a die to discard.`);
}

function queueStarPostReward(state, reason) {
  const p = getActivePlayer(state);
  if (!state.ui) state.ui = { spend: null, discard: null, starPost: null };
  if (state.ui.starPost?.open) {
    log(state, `Star Post (${reason}): choice already pending.`);
    return;
  }
  if (p.heldRings <= 0) {
    log(state, `Star Post (${reason}): no held rings to save.`);
    return;
  }
  state.ui.starPost = {
    open: true,
    reason,
    postSpend: null
  };
  log(state, `Star Post (${reason}): choose to save all held rings or keep them held.`);
}

function getBumperLock(card, groupId) {
  if (!card) return null;
  if (!card.bumperLocks) card.bumperLocks = {};
  const value = card.bumperLocks[groupId];
  return value == null ? null : value;
}

function formatChallengeRequirement(ch, card) {
  if (!ch) return "NONE";
  const colorPrefix = ch.color ? `${ch.color.toUpperCase()}-` : "";
  if (ch.bumper) {
    const lock = getBumperLock(card, ch.bumper.id);
    return `${colorPrefix}BUMP-${lock == null ? "ANY" : lock}`;
  }
  const value = ch.n != null ? ch.n : "ANY";
  return `${colorPrefix || "ANY-"}${value}`;
}

function getChallengeColorClass(ch) {
  if (ch?.color === DieColor.BLUE) return "req-blue";
  if (ch?.color === DieColor.YELLOW) return "req-yellow";
  if (ch?.color === DieColor.RED) return "req-red";
  return "req-any";
}

function formatChallengeChip(ch, card) {
  const cls = getChallengeColorClass(ch);
  if (ch?.bumper) {
    const lock = getBumperLock(card, ch.bumper.id);
    const tip = lock == null ? "Bumper: any value" : `Bumper locked to ${lock}`;
    return `<span class="req-chip-stack" title="${tip}"><span class="req-chip-border bumper"></span><span class="req-chip ${cls}"><img src="img/bumper.png" alt="Bumper"></span></span>`;
  }
  if (ch?.n != null) {
    return `<span class="req-chip-stack"><span class="req-chip-border"></span><span class="req-chip ${cls}"><img src="img/${ch.n}.png" alt="${ch.n}"></span></span>`;
  }
  return `<span class="req-chip-stack"><span class="req-chip-border"></span><span class="req-chip ${cls}">ANY</span></span>`;
}

function isDieLegalForChallenge(ch, card, die) {
  if (!ch || !die) return false;
  if (ch.color && ch.color !== die.color) return false;
  if (ch.bumper) {
    if (ch.bumper.index === 0) return true;
    const lock = getBumperLock(card, ch.bumper.id);
    return lock != null && lock === die.value;
  }
  return ch.n === die.value;
}

function applyBumperLock(ch, card, die) {
  if (!ch?.bumper || !card) return;
  if (!card.bumperLocks) card.bumperLocks = {};
  const lock = card.bumperLocks[ch.bumper.id];
  if (lock == null && ch.bumper.index === 0) {
    card.bumperLocks[ch.bumper.id] = die.value;
  }
}

function getCardChallengeMap(card) {
  const map = new Map();
  if (!card?.spaces?.length) return map;
  for (let i = 0; i < card.spaces.length; i++) {
    const space = card.spaces[i];
    for (const ch of (space.challenges || [])) {
      map.set(ch.id, { challenge: ch, spaceIndex: i, spaceId: space.id });
    }
  }
  return map;
}

function getChallengeNextIds(card, entry) {
  if (!card || !entry) return [];
  const explicit = entry.challenge?.next;
  if (Array.isArray(explicit)) return explicit;
  const nextSpace = card.spaces?.[entry.spaceIndex + 1];
  return nextSpace?.challenges?.map(ch => ch.id) || [];
}

function getCardAvailableChallengeIds(card) {
  if (!card?.spaces?.length) return [];
  const map = getCardChallengeMap(card);
  if (!card.lastClearedChallengeId) {
    const first = card.spaces[0];
    return (first?.challenges || [])
      .map(ch => ch.id)
      .filter(id => map.get(id) && !map.get(id).challenge.cleared);
  }
  const entry = map.get(card.lastClearedChallengeId);
  if (!entry) return [];
  return getChallengeNextIds(card, entry)
    .filter(id => map.get(id) && !map.get(id).challenge.cleared);
}

function getCardAvailableChallenges(card) {
  const map = getCardChallengeMap(card);
  return getCardAvailableChallengeIds(card)
    .map(id => map.get(id)?.challenge)
    .filter(Boolean);
}

function renderActBoard(viewEl, { routes, cardGradient, chevronGradient, idPrefix = "act" }) {
  if (!viewEl) return;
  const actGradient = buildGradientCss(cardGradient);
  viewEl.style.background = actGradient || "";
  if (chevronGradient?.top) viewEl.style.setProperty("--act-arrow-start", chevronGradient.top);
  if (chevronGradient?.bottom) viewEl.style.setProperty("--act-arrow-end", chevronGradient.bottom);
  viewEl.innerHTML = `
    <div class="act-board-lanes">
      ${routes.map((route, index) => {
        const gradId = `${idPrefix}-arrow-${route.name.toLowerCase()}-${index}`;
        return `
        <div class="act-lane">
          <div class="act-lane-arrow">
            <svg viewBox="0 0 110 82" aria-hidden="true">
              <defs>
                <linearGradient id="${gradId}" x1="0" y1="0" x2="0" y2="82" gradientUnits="userSpaceOnUse">
                  <stop offset="0%" stop-color="var(--act-arrow-start)" />
                  <stop offset="100%" stop-color="var(--act-arrow-end)" />
                </linearGradient>
                <filter id="${gradId}-shadow" x="-20%" y="-20%" width="140%" height="140%">
                  <feDropShadow dx="0" dy="1.5" stdDeviation="1.2" flood-color="#0a0f1f" flood-opacity="0.55"/>
                </filter>
              </defs>
              <path d="M70 10 L91 10 Q95 10 96.65 13.65 L107.35 37.35 Q109 41 107.35 44.65 L96.65 68.35 Q95 72 91 72 L70 72 Q62 72 65.67 64.89 L76.16 44.56 Q78 41 76.16 37.44 L65.67 17.11 Q62 10 70 10 Z" fill="url(#${gradId})" stroke="#ffffff" stroke-width="3" stroke-linejoin="round" stroke-linecap="round" filter="url(#${gradId}-shadow)"/>
              <path d="M40 10 L61 10 Q65 10 66.65 13.65 L77.35 37.35 Q79 41 77.35 44.65 L66.65 68.35 Q65 72 61 72 L40 72 Q32 72 35.67 64.89 L46.16 44.56 Q48 41 46.16 37.44 L35.67 17.11 Q32 10 40 10 Z" fill="url(#${gradId})" stroke="#ffffff" stroke-width="3" stroke-linejoin="round" stroke-linecap="round" filter="url(#${gradId}-shadow)"/>
              <path d="M10 10 L31 10 Q35 10 36.65 13.65 L47.35 37.35 Q49 41 47.35 44.65 L36.65 68.35 Q35 72 31 72 L10 72 Q2 72 5.67 64.89 L16.16 44.56 Q18 41 16.16 37.44 L5.67 17.11 Q2 10 10 10 Z" fill="url(#${gradId})" stroke="#ffffff" stroke-width="3" stroke-linejoin="round" stroke-linecap="round" filter="url(#${gradId}-shadow)"/>
            </svg>
          </div>
          ${formatActRewardHtml(route.reward)}
        </div>
      `;
      }).join("")}
    </div>
  `;
}

function buildCardTrackHtml(cardData, defaultSpaceBgImage = null) {
  if (!cardData) return { html: `<div class="tiny muted">No active card.</div>`, availableIds: new Set() };
  const spaceCount = cardData?.spaces?.length ?? 0;
  const evenLayout = spaceCount === 5 || spaceCount === 6 || spaceCount === 7;
  const trackClass = evenLayout
    ? `track-list track-list-even${spaceCount === 7 ? " spaces-7" : ""}`
    : "track-list";
  const availableIds = new Set(getCardAvailableChallengeIds(cardData));
  const renderChallenge = (ch) => {
    const laneClass = `lane-${ch.lane || "shared"}`;
    const req = formatChallengeChip(ch, cardData);
    const reward = formatActRewardHtml(ch.reward);
    const isAvailable = availableIds.has(ch.id);
    const labelClasses = ["track-label"];
    const rewardClasses = ["track-reward"];
    labelClasses.push(laneClass);
    rewardClasses.push(laneClass);
    if (ch.cleared) {
      labelClasses.push("cleared");
      rewardClasses.push("cleared");
    } else if (!isAvailable) {
      labelClasses.push("locked");
      rewardClasses.push("locked");
    }
    if (isAvailable) labelClasses.push("clickable");
    const labelHtml = `<div class="${labelClasses.join(" ")}" data-challenge-id="${ch.id}">${req}</div>`;
    const rewardHtml = `<div class="${rewardClasses.join(" ")}">${reward}</div>`;
    return { labelHtml, rewardHtml };
  };
  const html = `<div class="${trackClass}">
      ${cardData.spaces.map(space => {
        const bgImageUrl = space?.backgroundImage || defaultSpaceBgImage;
        const bgImage = bgImageUrl ? ` style="--space-bg-image: url('${bgImageUrl}');"` : "";
        const challenges = space.challenges || [];
        if (challenges.length === 1) {
          const ch = challenges[0];
          const rendered = renderChallenge(ch);
          return `<div class="track-space">
            <div class="space-reward space-reward-top empty"></div>
            <div class="track-item single"${bgImage}>
              ${rendered.labelHtml}
            </div>
            <div class="space-reward space-reward-bottom">
              ${rendered.rewardHtml}
            </div>
          </div>`;
        }
        const top = challenges.find(ch => ch.lane === "top") || challenges[0];
        const bottom = challenges.find(ch => ch.lane === "bottom") || challenges[1];
        const topRendered = renderChallenge(top);
        const bottomRendered = renderChallenge(bottom);
        return `<div class="track-space">
          <div class="space-reward space-reward-top">
            ${topRendered.rewardHtml}
          </div>
          <div class="track-item multi"${bgImage}>
            ${topRendered.labelHtml}
            ${bottomRendered.labelHtml}
          </div>
          <div class="space-reward space-reward-bottom">
            ${bottomRendered.rewardHtml}
          </div>
        </div>`;
      }).join("")}
    </div>`;
  return { html, availableIds };
}

function renderZoneCardConnectors(cardEl, cardData) {
  if (!cardEl || !cardData?.spaces?.length) return;
  if (!cardEl.isConnected) return;
  const challengeMap = getCardChallengeMap(cardData);
  const trackEl = cardEl.querySelector(".track-list");
  if (!trackEl) return;
  const drawPathSegment = (svg, defs, options) => {
    const {
      x1,
      y1,
      x2,
      y2,
      spanSpaces,
      isActivePath,
      chevronColors,
      baseChevronCount,
      gradientIndexRef,
      chevronExtend = 0
    } = options;
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    if (isActivePath) {
      line.classList.add("active");
    }
    line.setAttribute("x1", `${x1}`);
    line.setAttribute("y1", `${y1}`);
    line.setAttribute("x2", `${x2}`);
    line.setAttribute("y2", `${y2}`);
    svg.appendChild(line);

    if (chevronColors?.start && chevronColors?.end) {
      const count = spanSpaces >= 2 ? (spanSpaces * baseChevronCount + 1) : baseChevronCount;
      if (count > 0) {
        const gradId = `chevron-grad-${gradientIndexRef()}`;
        const grad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
        grad.setAttribute("id", gradId);
        grad.setAttribute("gradientUnits", "userSpaceOnUse");
        grad.setAttribute("x1", `${x1}`);
        grad.setAttribute("y1", `${y1}`);
        grad.setAttribute("x2", `${x2}`);
        grad.setAttribute("y2", `${y2}`);
        const stopA = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stopA.setAttribute("offset", "0%");
        stopA.setAttribute("stop-color", chevronColors.start);
        const stopB = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stopB.setAttribute("offset", "100%");
        stopB.setAttribute("stop-color", chevronColors.end);
        grad.appendChild(stopA);
        grad.appendChild(stopB);
        defs.appendChild(grad);

        const segDx = x2 - x1;
        const segDy = y2 - y1;
        const segLen = Math.hypot(segDx, segDy) || 1;
        const chevronHeight = parseFloat(getComputedStyle(svg).getPropertyValue("--chevron-height")) || 10;
        const chevronWidth = parseFloat(getComputedStyle(svg).getPropertyValue("--chevron-width")) || 12;
        const gap = parseFloat(getComputedStyle(svg).getPropertyValue("--chevron-gap")) || 4;
        const angleFactor = parseFloat(getComputedStyle(svg).getPropertyValue("--chevron-angle-factor")) || 0.85;
        const clusterLen = count * chevronWidth + (count - 1) * gap;
        const startOffset = (segLen - clusterLen) / 2;
        const angle = Math.atan2(segDy, segDx) * 180 / Math.PI;
        const halfH = chevronHeight / 2;
        const halfW = chevronWidth / 2;
        const delta = Math.max(chevronWidth * 0.1, Math.min(halfW * 0.98, halfW * angleFactor));
        const back = -halfW;
        const tip = halfW;
        const mid = tip - delta;
        const notch = back + delta;
        const pathD = `M ${back} ${-halfH} L ${mid} ${-halfH} L ${tip} 0 L ${mid} ${halfH} L ${back} ${halfH} L ${notch} 0 Z`;

        for (let i = 0; i < count; i++) {
          const offset = startOffset + i * (chevronWidth + gap) + chevronWidth / 2 + chevronExtend;
          const cx = x1 + (segDx / segLen) * offset;
          const cy = y1 + (segDy / segLen) * offset;
          const chevron = document.createElementNS("http://www.w3.org/2000/svg", "path");
          chevron.setAttribute("d", pathD);
          chevron.setAttribute("fill", isActivePath ? "#f7f7f7" : `url(#${gradId})`);
          chevron.setAttribute("transform", `translate(${cx} ${cy}) rotate(${angle})`);
          svg.appendChild(chevron);
        }
      }
    }
  };
  const chevronColors = cardEl._chevronColors || null;
  const labelNodes = cardEl.querySelectorAll("[data-challenge-id]");
  const clearedIds = new Set();
  for (const [id, entry] of challengeMap.entries()) {
    if (entry.challenge?.cleared) clearedIds.add(id);
  }
  const availableIds = new Set(getCardAvailableChallengeIds(cardData));
  const elById = new Map();
  for (const label of labelNodes) {
    const id = label.getAttribute("data-challenge-id");
    if (!id) continue;
    const chip = label.querySelector(".req-chip") || label.querySelector(".req-chip-stack") || label;
    elById.set(id, chip);
  }

  let svg = trackEl.querySelector(".track-connectors");
  if (!svg) {
    svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.classList.add("track-connectors");
    svg.setAttribute("aria-hidden", "true");
    trackEl.appendChild(svg);
  }

  const strokeWidth = parseFloat(getComputedStyle(svg).getPropertyValue("--connector-stroke")) || 8;
  const connectorInset = strokeWidth / 2;

  const trackRect = trackEl.getBoundingClientRect();
  const width = Math.max(1, trackRect.width);
  const height = Math.max(1, trackRect.height);
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  svg.setAttribute("preserveAspectRatio", "none");
  svg.style.width = "100%";
  svg.style.height = "100%";
  svg.innerHTML = "";

  const originLeft = trackRect.left;
  const originTop = trackRect.top;
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  svg.appendChild(defs);
  let gradientIndex = 0;
  const spaceCount = cardData.spaces.length;
  const baseChevronCount = spaceCount === 5 || spaceCount === 6 ? 4 : 3;

  for (const [id, entry] of challengeMap.entries()) {
    const fromEl = elById.get(id);
    if (!fromEl) continue;
    const nextIds = getChallengeNextIds(cardData, entry);
    if (!Array.isArray(nextIds) || !nextIds.length) continue;
    const fromRect = fromEl.getBoundingClientRect();
    const fromCenter = {
      x: (fromRect.left + fromRect.right) / 2,
      y: (fromRect.top + fromRect.bottom) / 2
    };
    const fromSize = Math.min(fromRect.width, fromRect.height);
    const fromOffset = Math.max(0, fromSize / 2 - connectorInset);

    for (const nextId of nextIds) {
      const toEl = elById.get(nextId);
      if (!toEl) continue;
      const nextEntry = challengeMap.get(nextId);
      const spanSpaces = nextEntry ? Math.max(1, nextEntry.spaceIndex - entry.spaceIndex) : 1;
      const toRect = toEl.getBoundingClientRect();
      const toCenter = {
        x: (toRect.left + toRect.right) / 2,
        y: (toRect.top + toRect.bottom) / 2
      };
      const dx = toCenter.x - fromCenter.x;
      const dy = toCenter.y - fromCenter.y;
      const dist = Math.hypot(dx, dy) || 1;
      const ux = dx / dist;
      const uy = dy / dist;
      const toSize = Math.min(toRect.width, toRect.height);
      const toOffset = Math.max(0, toSize / 2 - connectorInset);
      const x1 = fromCenter.x + ux * fromOffset - originLeft;
      const y1 = fromCenter.y + uy * fromOffset - originTop;
      const x2 = toCenter.x - ux * toOffset - originLeft;
      const y2 = toCenter.y - uy * toOffset - originTop;
      const isActivePath = clearedIds.has(id) && (clearedIds.has(nextId) || availableIds.has(nextId));
      drawPathSegment(svg, defs, {
        x1,
        y1,
        x2,
        y2,
        spanSpaces,
        isActivePath,
        chevronColors,
        baseChevronCount,
        gradientIndexRef: () => gradientIndex++,
        chevronExtend: 0
      });
    }
  }

  const chevronWidthForEdge = parseFloat(getComputedStyle(svg).getPropertyValue("--chevron-width")) || 12;
  for (const [id, entry] of challengeMap.entries()) {
    const fromEl = elById.get(id);
    if (!fromEl) continue;
    const nextIds = getChallengeNextIds(cardData, entry);
    if (Array.isArray(nextIds) && nextIds.length) continue;
    const fromRect = fromEl.getBoundingClientRect();
    const fromCenter = {
      x: (fromRect.left + fromRect.right) / 2,
      y: (fromRect.top + fromRect.bottom) / 2
    };
    const fromSize = Math.min(fromRect.width, fromRect.height);
    const fromOffset = Math.max(0, fromSize / 2 - connectorInset);
    const x1 = fromCenter.x + fromOffset - originLeft;
    const y1 = fromCenter.y - originTop;
    const x2 = width + chevronWidthForEdge;
    const y2 = y1;
    const spanSpaces = Math.max(1, cardData.spaces.length - entry.spaceIndex);
    const isActivePath = clearedIds.has(id) || availableIds.has(id);
    drawPathSegment(svg, defs, {
      x1,
      y1,
      x2,
      y2,
      spanSpaces,
      isActivePath,
      chevronColors,
      baseChevronCount,
      gradientIndexRef: () => gradientIndex++,
      chevronExtend: chevronWidthForEdge
    });
  }
}

function scheduleZoneCardConnectors(cardEl, cardData, chevronColors) {
  if (!cardEl || !cardData) return;
  if (cardEl.dataset.connectorsPending) return;
  cardEl._chevronColors = chevronColors || null;
  cardEl.dataset.connectorsPending = "1";
  const finish = () => {
    delete cardEl.dataset.connectorsPending;
    renderZoneCardConnectors(cardEl, cardData);
  };
  const inner = cardEl.querySelector(".zone-card-inner");
  if (cardEl.classList.contains("flip-in") && inner) {
    inner.addEventListener("animationend", () => {
      cardEl.classList.remove("flip-in");
      finish();
    }, { once: true });
    return;
  }
  requestAnimationFrame(finish);
}

let zoneConnectorResizeBound = false;
function ensureZoneConnectorResizeHandler() {
  if (zoneConnectorResizeBound) return;
  zoneConnectorResizeBound = true;
  window.addEventListener("resize", () => {
    if (typeof render === "function") render();
  });
}

function isChallengeAvailable(card, challengeId) {
  return getCardAvailableChallengeIds(card).includes(challengeId);
}

function isCardComplete(card) {
  if (!card?.spaces?.length) return true;
  if (!card.lastClearedChallengeId) return false;
  return getCardAvailableChallengeIds(card).length === 0;
}

function getBuddyFlightValue(state) {
  return Math.max(0, Number(state?.buddyFlight?.value) || 0);
}

function getBuddyFlightDeltaRange(buddyValue, baseValue) {
  const safeBase = Math.max(1, Math.min(6, Number(baseValue) || 1));
  const available = Math.max(0, Number(buddyValue) || 0);
  if (!available) return { min: 0, max: 0 };
  const min = -Math.min(available, safeBase - 1);
  const max = Math.min(available, 6 - safeBase);
  return { min, max };
}

function clampBuddyFlightDelta(buddyValue, baseValue, delta) {
  const range = getBuddyFlightDeltaRange(buddyValue, baseValue);
  const desired = Math.trunc(delta) || 0;
  return Math.max(range.min, Math.min(range.max, desired));
}

function getBuddyFlightCandidateDeltas(buddyValue, baseValue) {
  const range = getBuddyFlightDeltaRange(buddyValue, baseValue);
  const maxAbs = Math.max(Math.abs(range.min), Math.abs(range.max));
  const deltas = [];
  for (let step = 1; step <= maxAbs; step++) {
    if (-step >= range.min) deltas.push(-step);
    if (step <= range.max) deltas.push(step);
  }
  return deltas;
}

function getEffectiveSpendDie(state, p, die, options = {}) {
  const amyEligible = p.character === "Amy" && die.color === DieColor.RED;
  const useAmyRaise = amyEligible && !!options.useAmyRaise;
  const raisedValue = useAmyRaise ? ((die.value % 6) + 1) : die.value;

  const buddyValue = getBuddyFlightValue(state);
  const buddyFlightDelta = clampBuddyFlightDelta(buddyValue, raisedValue, options.buddyFlightDelta);
  const buddyAdjustedValue = Math.max(1, Math.min(6, raisedValue + buddyFlightDelta));
  const buddyAdjustedDie = { ...die, value: buddyAdjustedValue };

  const canUseFlame = p.shield?.type === "flame" && !p.oncePerTurn.flameShieldUsed;
  const wantsFlame = options.useFlameShieldOverride ?? p.flameShieldArmed;
  const useFlameShield = canUseFlame && wantsFlame && buddyAdjustedDie.color !== DieColor.RED;
  const effectiveDie = useFlameShield ? { ...buddyAdjustedDie, color: DieColor.RED } : buddyAdjustedDie;
  return {
    effectiveDie,
    useFlameShield,
    useAmyRaise,
    buddyFlightDelta,
    buddyFlightBaseValue: raisedValue,
    buddyFlightAdjustedValue: buddyAdjustedValue,
    buddyFlightAvailable: buddyValue > 0
  };
}

function refreshSpendTargets(state, die) {
  const spendUi = state.ui?.spend;
  if (!spendUi || !die) return false;
  const p = getActivePlayer(state);
  const { effectiveDie, buddyFlightDelta } = getEffectiveSpendDie(state, p, die, {
    useFlameShieldOverride: spendUi.useFlameShield,
    useAmyRaise: spendUi.amyRaise,
    buddyFlightDelta: spendUi.buddyFlightDelta
  });
  const targets = buildSpendTargets(state, effectiveDie);
  spendUi.targets = targets;
  spendUi.selectedTargetId = targets[0]?.id || null;
  spendUi.buddyFlightDelta = buddyFlightDelta;
  return targets.length > 0;
}

function buildSpendTargets(state, die) {
  const p = getActivePlayer(state);
  const targets = [];

  for (const route of state.zone.routes) {
    const card = route.activeCard;
    const available = getCardAvailableChallenges(card);
    for (const ch of available) {
      if (!isDieLegalForChallenge(ch, card, die)) continue;
      const rewardLabel = formatRewardLabel(ch.reward);
      const reqLabel = formatChallengeRequirement(ch, card);
      const label = `Zone: ${route.name} ${reqLabel} (reward: ${rewardLabel})`;
      targets.push({
        id: uuid(),
        type: "zone",
        routeId: route.id,
        challengeId: ch.id,
        label
      });
    }
  }

  if (p.character === "Knuckles" && state.secretPassage?.card) {
    const card = state.secretPassage.card;
    const available = getCardAvailableChallenges(card);
    for (const ch of available) {
      if (!isDieLegalForChallenge(ch, card, die)) continue;
      const rewardLabel = formatRewardLabel(ch.reward);
      const reqLabel = formatChallengeRequirement(ch, card);
      const label = `Secret Passage: ${reqLabel} (reward: ${rewardLabel})`;
      targets.push({
        id: uuid(),
        type: "secret_passage",
        challengeId: ch.id,
        label
      });
    }
  }

  for (let i=0;i<p.badniks.length;i++) {
    const b = p.badniks[i];
    if (!isBadnikTargetEligible(state, p, b)) continue;
    const avoidOk = b.avoid
      && (b.avoid.value === die.value)
      && (b.avoid.color ? b.avoid.color === die.color : true);
    const destroyOk = b.destroy && (die.color === DieColor.RED && b.destroy.value === die.value);
    if (avoidOk) {
      const avoidColorLabel = b.avoid.color ? b.avoid.color[0].toUpperCase() : "ANY";
      targets.push({
        id: uuid(),
        type: "badnik",
        badnikIndex: i,
        mode: "avoid",
        label: `Badnik: avoid ${b.name} (${avoidColorLabel}${b.avoid.value})`
      });
    }
    if (destroyOk) {
      targets.push({
        id: uuid(),
        type: "badnik",
        badnikIndex: i,
        mode: "destroy",
        label: `Badnik: destroy ${b.name} (R${b.destroy.value})`
      });
    }
  }

  return targets;
}

function openSpendUiForDie(state, die) {
  if (!state.ui) state.ui = { spend: null, discard: null, starPost: null };
  const p = getActivePlayer(state);
  const base = getEffectiveSpendDie(state, p, die, { useAmyRaise: false, buddyFlightDelta: 0 });
  let targets = buildSpendTargets(state, base.effectiveDie);
  let buddyFlightDelta = base.buddyFlightDelta;
  if (!targets.length && base.buddyFlightAvailable) {
    const deltas = getBuddyFlightCandidateDeltas(getBuddyFlightValue(state), base.buddyFlightBaseValue);
    for (const delta of deltas) {
      const adjusted = getEffectiveSpendDie(state, p, die, { useAmyRaise: false, buddyFlightDelta: delta });
      const adjustedTargets = buildSpendTargets(state, adjusted.effectiveDie);
      if (adjustedTargets.length) {
        targets = adjustedTargets;
        buddyFlightDelta = adjusted.buddyFlightDelta;
        break;
      }
    }
  }
  if (!targets.length) return false;
  state.ui.spend = {
    open: true,
    dieId: die.id,
    targets,
    selectedTargetId: targets[0].id,
    useFlameShield: base.useFlameShield,
    amyRaise: false,
    buddyFlightDelta
  };
  return true;
}

function preselectSpendTarget(state, targetInfo) {
  const p = getActivePlayer(state);
  if (state.phase !== "SPENDING") return log(state, "Cannot select spend target outside SPENDING.");
  if (state.bonusStage?.open) return log(state, "Finish the Bonus Stage before selecting a spend target.");
  if (state.ui?.discard?.open) return log(state, "Resolve the discard before selecting a spend target.");
  if (state.ui?.starPost?.open) return log(state, "Resolve the Star Post before selecting a spend target.");
  if (state.pendingPowerUp || state.pendingDamage || state.pendingBadnikReward || state.pendingWallClimb || state.pendingAvoid) {
    return log(state, "Resolve the pending reward before selecting a target.");
  }
  const die = p.dicePool.find(d => d.id === p.selectedDieId) || p.dicePool[0];
  if (!die) return log(state, "Select a die before targeting.");

  if (!openSpendUiForDie(state, die)) {
    return log(state, "No legal spend targets for that die.");
  }

  const spendUi = state.ui?.spend;
  if (!spendUi) return state;

  let match = null;
  if (targetInfo.type === "zone") {
    match = spendUi.targets.find(t =>
      t.type === "zone" &&
      t.routeId === targetInfo.routeId &&
      t.challengeId === targetInfo.challengeId
    );
  } else if (targetInfo.type === "secret_passage") {
    match = spendUi.targets.find(t =>
      t.type === "secret_passage" &&
      t.challengeId === targetInfo.challengeId
    );
  } else if (targetInfo.type === "badnik") {
    const candidates = spendUi.targets.filter(t =>
      t.type === "badnik" && t.badnikIndex === targetInfo.badnikIndex
    );
    if (targetInfo.mode) {
      match = candidates.find(t => t.mode === targetInfo.mode);
    }
    if (!match) {
      match = candidates.find(t => t.mode === "destroy") || candidates[0];
    }
  }

  if (!match) {
    return log(state, "That target is not legal for the selected die.");
  }

  spendUi.selectedTargetId = match.id;
  return state;
}

/* =======================
   Roll Action lookup
   ======================= */
function getActivePlayer(state){ return state.players[state.activePlayer]; }
function getCharCfg(p){ return CONFIG.characters[p.character]; }
function getRollActionCfg(p){
  const c = getCharCfg(p);
  return c.rollActions.find(r=>r.name===p.chosenRollAction) || c.rollActions[0];
}

function rollWallClimbBatch() {
  return [
    makeDie(DieColor.RED, rollD6()),
    makeDie(DieColor.RED, rollD6()),
    makeDie(DieColor.RED, rollD6())
  ];
}

function startWallClimb(state, p) {
  p.dicePool = [];
  p.selectedDieId = null;
  state.pendingWallClimb = {
    rollIndex: 1,
    remaining: 3,
    lastSaved: 0,
    batch: rollWallClimbBatch(),
    selectedIds: []
  };
  state.phase = "WALL_CLIMB";
  log(state, `${p.name} Wall Climb roll 1: ${state.pendingWallClimb.batch.map(d=>`R${d.value}`).join(" ")}. Choose dice to save (> ${state.pendingWallClimb.lastSaved}).`);
}

function confirmWallClimbSelection(state, saveNone = false) {
  const p = getActivePlayer(state);
  const pending = state.pendingWallClimb;
  if (!pending) return;
  if (saveNone) pending.selectedIds = [];
  const selected = pending.batch.filter(d => pending.selectedIds.includes(d.id));
  const values = selected.map(d => d.value).sort((a, b) => a - b);
  let valid = values.every(v => v > pending.lastSaved);
  for (let i = 1; i < values.length; i++) {
    if (values[i] <= values[i - 1]) valid = false;
  }
  if (!valid) {
    log(state, "Wall Climb: selection must be strictly increasing and above the last saved die.");
    return;
  }
  if (selected.length) {
    p.dicePool.push(...selected);
    pending.lastSaved = values[values.length - 1];
    log(state, `${p.name} Wall Climb: saved ${selected.map(d=>`R${d.value}`).join(" ")}.`);
  } else {
    log(state, `${p.name} Wall Climb: saved no dice.`);
  }
  pending.remaining -= 1;
  if (pending.remaining > 0) {
    pending.rollIndex += 1;
    pending.batch = rollWallClimbBatch();
    pending.selectedIds = [];
    log(state, `${p.name} Wall Climb roll ${pending.rollIndex}: ${pending.batch.map(d=>`R${d.value}`).join(" ")}. Choose dice to save (> ${pending.lastSaved}).`);
    return;
  }
  state.pendingWallClimb = null;
  state.phase = "SPENDING";
  makeVulnerable(p);
  log(state, `${p.name} Dice Pool built: ${p.dicePool.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);
  runBadnikAbilities(state, "DICE_ACTION", { state, p, rollAction: getRollActionCfg(p) });
}

/* =======================
   Build dice pool (dashboard-accurate)
   ======================= */
function buildDicePool(state) {
  if (state.phase !== "ROLL_ACTION") return log(state, `Cannot build pool: phase=${state.phase}`);

  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);

  const p = getActivePlayer(state);
  if (!p.rollActionSelectedThisTurn) {
    return log(state, `${p.name} must select a Roll Action before building the Dice Pool.`);
  }
  p.oncePerTurn = {};                 // refresh "once per turn" flags
  p.spentSinceLastReroll = 0;
  p.hasRerolledThisTurn = false;
  p.propellerTailBonusGivenSinceReroll = false;
  p.lastChainSpendRule = null;

  const ra = getRollActionCfg(p);

  p.dicePool = [];
  p.selectedDieId = null;

  function rollBatch(diceSpec) {
    const out = [];
    for (const [color, count] of Object.entries(diceSpec)) {
      for (let i=0;i<count;i++) out.push(makeDie(color, rollD6()));
    }
    return out;
  }

  if (ra.buildMode === "repeatUntilPair") {
    // Roll the action dice repeatedly, add all rolled dice, stop once any pair of values matches in pool.
    let safety = 4;
    while (safety-- > 0) {
      const batch = rollBatch(ra.dice);
      p.dicePool.push(...batch);
      const counts = new Map();
      let hasPair = false;
      for (const d of p.dicePool) {
        counts.set(d.value, (counts.get(d.value)||0)+1);
        if (counts.get(d.value) >= 2) { hasPair = true; break; }
      }
      log(state, `${p.name} Spin Dash roll: ${batch.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")} â†’ pool size ${p.dicePool.length}`);
      if (hasPair) { log(state, `Spin Dash condition met: at least one matching pair exists in Dice Pool.`); break; }
    }
  }
  else if (ra.buildMode === "tailsFlyX2") {
    // x2: each time roll 4 yellows; save matching pairs else save any 1; discard rest.
    for (let rep=1; rep<=2; rep++) {
      const batch = rollBatch(ra.dice); // 4 yellows
      const byVal = new Map();
      for (const d of batch) byVal.set(d.value, (byVal.get(d.value)||[]).concat([d]));
      const pairs = [];
      for (const [val, arr] of byVal.entries()) {
        if (arr.length >= 2) pairs.push(...arr.slice(0,2));
      }
      if (pairs.length > 0) {
        p.dicePool.push(...pairs);
        log(state, `${p.name} Fly (x${rep}): rolled ${batch.map(d=>`Y${d.value}`).join(" ")} â†’ saved pairs ${pairs.map(d=>`Y${d.value}`).join(" ")}.`);
      } else {
        // save any 1 die (choose highest to be practical)
        batch.sort((a,b)=>b.value-a.value);
        p.dicePool.push(batch[0]);
        log(state, `${p.name} Fly (x${rep}): rolled ${batch.map(d=>`Y${d.value}`).join(" ")} â†’ no pairs; saved one die Y${batch[0].value}.`);
      }
    }
  }
    else if (ra.buildMode === "knucklesWallClimbX3") {
    // x3: each repeat roll 3 reds; player chooses which dice to save (strictly increasing).
    startWallClimb(state, p);
    return state;
  }
else {
    // Standard: roll once, add all dice
    const batch = rollBatch(ra.dice);
    p.dicePool.push(...batch);
    log(state, `${p.name} rolled: ${batch.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);
  }

  // Apply any ROLL effect after building pool
  if (typeof ra.onBuildPool === "function") {
    ra.onBuildPool({ state, p });
  }

  makeVulnerable(p); // unless damage happened previously
  state.phase = "SPENDING";
  if (!state.ui) state.ui = { spend: null, discard: null, starPost: null };
  state.ui.rollAnim = true;
  log(state, `${p.name} Dice Pool built: ${p.dicePool.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);
  runBadnikAbilities(state, "DICE_ACTION", { state, p, rollAction: ra });
  return state;
}

/* =======================
   Boost after Roll Action
   ======================= */
function boostAfterRollAction(state) {
  const p = getActivePlayer(state);
  if (p.boost <= 0) return log(state, `${p.name} has no Boost tokens.`);
  if (state.phase !== "SPENDING" || p.dicePool.length === 0) return log(state, `Boost-after-roll-action must be used right after building a Dice Pool.`);

  p.boost -= 1;
  log(state, `${p.name} spends 1 Boost (after Roll Action): reroll Dice Pool and enter REROLL step (Badnik-vulnerable).`);
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);
  state.phase = "REROLL";
  return rerollStep(state, { fromBoost: true });
}

/* =======================
   Spending
   ======================= */
function spendSelectedDie(state) {
  const p = getActivePlayer(state);
  if (state.phase !== "SPENDING") return log(state, `Cannot spend: phase=${state.phase}`);
  if (state.bonusStage?.open) return log(state, "Finish the Bonus Stage before spending.");
  if (state.pendingPowerUp || state.pendingDamage || state.pendingBadnikReward || state.pendingWallClimb || state.pendingAvoid) {
    return log(state, "Resolve the pending reward before spending.");
  }

  if (!p.dicePool.length) { state.phase = "END_TURN"; return log(state, `No dice left â†’ End Turn`); }

  const die = p.dicePool.find(d => d.id === p.selectedDieId) || p.dicePool[0];

  if (!openSpendUiForDie(state, die)) {
    const canSpendAny = p.dicePool.some(candidate => {
      const base = getEffectiveSpendDie(state, p, candidate, { useAmyRaise: false, buddyFlightDelta: 0 });
      if (buildSpendTargets(state, base.effectiveDie).length > 0) return true;
      if (!base.buddyFlightAvailable) return false;
      const deltas = getBuddyFlightCandidateDeltas(getBuddyFlightValue(state), base.buddyFlightBaseValue);
      return deltas.some(delta => {
        const adjusted = getEffectiveSpendDie(state, p, candidate, { useAmyRaise: false, buddyFlightDelta: delta });
        return buildSpendTargets(state, adjusted.effectiveDie).length > 0;
      });
    });
    if (canSpendAny) {
      clearSpendUi(state);
      return log(state, "Selected die has no legal targets. Choose another die to spend.");
    }
    clearSpendUi(state);
    startAvoidPhase(state, "No legal spend available");
    return state;
  }
  return state;
}

function confirmSpendSelection(state) {
  const p = getActivePlayer(state);
  const spendUi = state.ui?.spend;
  if (state.phase !== "SPENDING") { clearSpendUi(state); return state; }
  if (!spendUi || !spendUi.open) return state;

  const die = p.dicePool.find(d => d.id === spendUi.dieId);
  if (!die) {
    log(state, "Spend canceled: selected die is no longer available.");
    clearSpendUi(state);
    return state;
  }

  const target = spendUi.targets.find(t => t.id === spendUi.selectedTargetId);
  if (!target) {
    log(state, "Spend canceled: no target selected.");
    clearSpendUi(state);
    return state;
  }

  const spendMeta = {
    useFlameShield: spendUi.useFlameShield,
    amyRaise: spendUi.amyRaise,
    buddyFlightDelta: spendUi.buddyFlightDelta
  };
  clearSpendUi(state);
  return spendDieOnTarget(state, die, target, spendMeta);
}

function cancelSpendSelection(state) {
  clearSpendUi(state);
  return state;
}

function finalizePostSpend(state, spentDie, ra) {
  const p = getActivePlayer(state);
  if (!spentDie) return state;

  if (!p.dicePool.length) { state.phase = "END_TURN"; return log(state, "Dice Pool empty -> End Turn"); }

  if (spentDie.color === DieColor.BLUE) {
    log(state, `Run die property: ${p.name} may spend another die without rerolling.`);
    state.phase = "SPENDING";
    return state;
  }

  if (p.lastChainSpendRule?.color === DieColor.YELLOW && ra?.name === "Glide") {
    const canChain = p.dicePool.some(d => d.color === DieColor.YELLOW && d.value < p.lastChainSpendRule.lastSpentValue);
    if (canChain) {
      log(state, `Knuckles Glide (SPEND): may spend another YELLOW without reroll if it is lower than last spent (${p.lastChainSpendRule.lastSpentValue}).`);
      state.phase = "SPENDING";
      return state;
    }
  }

  state.phase = "REROLL";
  log(state, "Must REROLL remaining dice before next spend.");
  return state;
}

function confirmDiscardSelection(state) {
  const p = getActivePlayer(state);
  const discardUi = state.ui?.discard;
  if (!discardUi?.open) return state;
  const die = p.dicePool.find(d => d.id === discardUi.selectedDieId);
  if (!die) {
    log(state, "Discard canceled: no die selected.");
    return state;
  }

  p.dicePool = p.dicePool.filter(d => d.id !== die.id);
  p.selectedDieId = null;
  log(state, `Lose a die (${discardUi.reason}): discarded ${die.color.toUpperCase()}-${die.value}.`);

  const post = discardUi.postSpend;
  clearDiscardUi(state);
  if (post?.spentDieColor) {
    const ra = getRollActionCfg(p);
    return finalizePostSpend(state, { color: post.spentDieColor }, ra);
  }
  return state;
}

function confirmStarPostSave(state) {
  const p = getActivePlayer(state);
  const starUi = state.ui?.starPost;
  if (!starUi?.open) return state;

  const savedNow = p.heldRings;
  p.heldRings = 0;
  p.savedRings += savedNow;
  log(state, `Star Post (${starUi.reason}): saved ${savedNow} Rings (Saved=${p.savedRings}).`);
  const triggerBonusStage = savedNow >= 5;

  const post = starUi.postSpend;
  clearStarPostUi(state);
  let outState = state;
  if (post?.spentDieColor) {
    const ra = getRollActionCfg(p);
    outState = finalizePostSpend(state, { color: post.spentDieColor }, ra);
  }
  if (triggerBonusStage) {
    queueBonusStage(outState, "Star Post saved 5+ Rings");
  }
  return outState;
}

function confirmStarPostKeep(state) {
  const p = getActivePlayer(state);
  const starUi = state.ui?.starPost;
  if (!starUi?.open) return state;
  log(state, `Star Post (${starUi.reason}): kept ${p.heldRings} Rings held.`);
  const post = starUi.postSpend;
  clearStarPostUi(state);
  if (post?.spentDieColor) {
    const ra = getRollActionCfg(p);
    return finalizePostSpend(state, { color: post.spentDieColor }, ra);
  }
  return state;
}

function spendDieOnTarget(state, die, target, spendMeta) {
  const p = getActivePlayer(state);
  const ra = getRollActionCfg(p);
  const {
    effectiveDie,
    useFlameShield,
    useAmyRaise,
    buddyFlightDelta,
    buddyFlightBaseValue,
    buddyFlightAdjustedValue
  } = getEffectiveSpendDie(state, p, die, {
    useFlameShieldOverride: spendMeta?.useFlameShield,
    useAmyRaise: spendMeta?.amyRaise,
    buddyFlightDelta: spendMeta?.buddyFlightDelta
  });
  let spendTarget = null;
  let challengeReward = null;
  let completedRoute = null;
  let completedSecretPassage = false;
  let spendLabel = `${die.color.toUpperCase()}-${die.value}`;
  if (useAmyRaise) {
    spendLabel += ` (Piko Piko Hammer -> ${buddyFlightBaseValue})`;
  }
  if (buddyFlightDelta) {
    const deltaLabel = buddyFlightDelta > 0 ? `+${buddyFlightDelta}` : `${buddyFlightDelta}`;
    spendLabel += ` (Buddy Flight ${deltaLabel} -> ${buddyFlightAdjustedValue})`;
  }

  if (target.type === "zone") {
    const route = state.zone.routes.find(r => r.id === target.routeId);
    const card = route?.activeCard;
    const challengeMap = getCardChallengeMap(card);
    const entry = challengeMap.get(target.challengeId);
    const ch = entry?.challenge;
    const availableIds = new Set(getCardAvailableChallengeIds(card));
    const legal = ch && isDieLegalForChallenge(ch, card, effectiveDie);
    if (!route || !ch || !availableIds.has(ch.id) || !legal) {
      log(state, "Spend failed: zone target no longer legal.");
      return state;
    }
    ch.cleared = true;
    if (card) card.lastClearedChallengeId = ch.id;
    applyBumperLock(ch, card, effectiveDie);
    spendTarget = { type:"zone", route: route.name, challengeId: ch.id };
    const reqLabel = formatChallengeRequirement(ch, card);
    log(state, `${p.name} spends ${spendLabel} to clear ${route.name} challenge (${reqLabel}).`);
    challengeReward = ch.reward;
    completedRoute = route;
  } else if (target.type === "secret_passage") {
    const card = state.secretPassage?.card;
    const challengeMap = getCardChallengeMap(card);
    const entry = challengeMap.get(target.challengeId);
    const ch = entry?.challenge;
    const availableIds = new Set(getCardAvailableChallengeIds(card));
    const legal = ch && isDieLegalForChallenge(ch, card, effectiveDie);
    if (!card || !ch || !availableIds.has(ch.id) || !legal) {
      log(state, "Spend failed: Secret Passage target no longer legal.");
      return state;
    }
    ch.cleared = true;
    if (card) card.lastClearedChallengeId = ch.id;
    applyBumperLock(ch, card, effectiveDie);
    spendTarget = { type:"secret_passage", challengeId: ch.id };
    const reqLabel = formatChallengeRequirement(ch, card);
    log(state, `${p.name} spends ${spendLabel} to clear Secret Passage challenge (${reqLabel}).`);
    challengeReward = ch.reward;
    completedSecretPassage = true;
  } else if (target.type === "badnik") {
    const b = p.badniks[target.badnikIndex];
    if (!b) {
      log(state, "Spend failed: badnik target no longer exists.");
      return state;
    }
    initBadnikState(b);
    if (!isBadnikTargetEligible(state, p, b)) {
      log(state, "Spend failed: badnik target not legal for current dice pool.");
      return state;
    }
    const avoidOk = b.avoid
      && (b.avoid.value === effectiveDie.value)
      && (b.avoid.color ? b.avoid.color === effectiveDie.color : true);
    const destroyOk = b.destroy && (effectiveDie.color === DieColor.RED && b.destroy.value === effectiveDie.value);
    if (target.mode === "avoid" && !avoidOk) {
      log(state, "Spend failed: avoid target no longer legal.");
      return state;
    }
    if (target.mode === "destroy" && !destroyOk) {
      log(state, "Spend failed: destroy target no longer legal.");
      return state;
    }
    spendTarget = { type:"badnik", name: b.name, mode: target.mode };
    const hitsRequired = getBadnikHitsRequired(b);
    const hitsTaken = Number.isFinite(b.hitsTaken) ? b.hitsTaken : 0;
    const nextHits = hitsTaken + 1;
    const isFinalHit = nextHits >= hitsRequired;
    if (!isFinalHit) {
      b.hitsTaken = nextHits;
      b.flipped = true;
      b.flipAnim = true;
      log(state, `${p.name} hits Badnik "${b.name}" with ${spendLabel} (${nextHits}/${hitsRequired}).`);
    } else {
      b.hitsTaken = nextHits;
      b.flipped = false;
      if (target.mode === "destroy") {
        p.animalTokens += 1;
        log(state, `${p.name} DESTROYS Badnik "${b.name}" with ${spendLabel} -> gained 1 Animal Token (total ${p.animalTokens}).`);
      } else {
        log(state, `${p.name} AVOIDS Badnik "${b.name}" with ${spendLabel}.`);
      }
      triggerBadnikAbility(state, p, b, "DEFEAT", { mode: target.mode, spentDie: die, effectiveDie });
      discardBadnikFromPlayer(state, p, b);
    }
  } else {
    return state;
  }

  // Remove die from pool
  p.dicePool = p.dicePool.filter(d => d.id !== die.id);
  p.selectedDieId = null;

  // Spending ends invulnerability window
  makeVulnerable(p);

  // Update counters for "since last reroll"
  p.spentSinceLastReroll += 1;

  if (buddyFlightDelta) {
    const spendAmount = Math.abs(buddyFlightDelta);
    if (state.buddyFlight) {
      const before = state.buddyFlight.value;
      state.buddyFlight.value = Math.max(0, before - spendAmount);
      log(state, `Buddy Flight: spent ${spendAmount} (die ${before} -> ${state.buddyFlight.value}).`);
      if (state.buddyFlight.value === 0) {
        log(state, "Buddy Flight die removed (0).");
      }
    }
  }

  const badnikSpendResult = runBadnikAbilities(state, "SPEND", {
    state,
    p,
    spentDie: effectiveDie,
    spendTarget
  });
  if (badnikSpendResult?.halt) return state;

  if (ra.name === "Propeller Tail" && !p.hasRerolledThisTurn && p.spentSinceLastReroll >= 2 && !p.propellerTailBonusGivenSinceReroll) {
    const bonusDie = makeDie(DieColor.YELLOW, rollD6());
    p.dicePool.push(bonusDie);
    p.propellerTailBonusGivenSinceReroll = true;
    log(state, `Tails Propeller Tail (SPEND): spent>=2 after initial roll -> gained a YELLOW die (${bonusDie.value}).`);
  }

  // Core dice properties (from rulebook)
  const spentDie = { ...die, value: effectiveDie.value };

  if (spentDie.color === DieColor.YELLOW) {
    p.heldRings += 1;
    log(state, `Jump die property: +1 Ring (Held=${p.heldRings}).`);
  }

  if (useFlameShield) {
    p.oncePerTurn.flameShieldUsed = true;
    p.flameShieldArmed = false;
    log(state, `${p.name} Flame Shield: spent die treated as RED.`);
  }

  // Apply roll-action SPEND effect hooks
  if (typeof ra.onSpend === "function") {
    const spentDieForEffects = useFlameShield ? { ...spentDie, color: DieColor.RED } : spentDie;
    ra.onSpend({ state, p, spentDie: spentDieForEffects, spendTarget });
  }

  // Knuckles Glide chaining rule: if the action specifies a chain rule, set it up for potential extra spend.
  if (ra.onSpendChainRule && spentDie.color === ra.onSpendChainRule.color) {
    p.lastChainSpendRule = { ...ra.onSpendChainRule, lastSpentValue: spentDie.value };
  } else {
    p.lastChainSpendRule = null;
  }

  if (challengeReward) applyReward(state, challengeReward);
  if (completedRoute && isCardComplete(completedRoute.activeCard)) completeZoneCard(state, completedRoute);
  if (completedSecretPassage && state.secretPassage?.card && isCardComplete(state.secretPassage.card)) {
    completeSecretPassage(state);
  }
  if (state.ui?.discard?.open) {
    state.ui.discard.postSpend = { spentDieColor: spentDie.color };
    return state;
  }
  if (state.ui?.starPost?.open) {
    state.ui.starPost.postSpend = { spentDieColor: spentDie.color };
    return state;
  }
  if (state.phase === "END_TURN" || state.phase === "GAME_OVER") return state;
  return finalizePostSpend(state, spentDie, ra);
}

/* =======================
   Reroll step
   ======================= */
function rerollStep(state, options = {}) {
  const p = getActivePlayer(state);
  const canRerollNow = state.phase === "REROLL"
    || (state.phase === "SPENDING" && p.spentSinceLastReroll > 0)
    || (state.phase === "SPENDING" && p.invulnerable && p.dicePool.length > 0);
  if (!canRerollNow) return log(state, `Cannot reroll: phase=${state.phase}`);
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);
  if (!p.dicePool.length) { state.phase = "END_TURN"; return log(state, `No dice to reroll â†’ End Turn`); }

  const ra = getRollActionCfg(p);
  p.hasRerolledThisTurn = true;

  if (!options.fromBoost) {
    const badnikResult = runBadnikAbilities(state, "REROLL", { state, p, rollAction: ra });
    if (badnikResult?.halt) return state;
  }

  // Apply REROLL effects at the beginning of the reroll step
  if (typeof ra.onRerollStepStart === "function") {
    ra.onRerollStepStart({ state, p });
  }

  // Reroll all remaining dice
  for (const d of p.dicePool) d.value = rollD6();
  log(state, `${p.name} rerolls Dice Pool: ${p.dicePool.map(d=>`${d.color[0].toUpperCase()}${d.value}`).join(" ")}`);
  if (!state.ui) state.ui = { spend: null, discard: null, starPost: null };
  state.ui.rollAnim = true;

  // Reroll ends invulnerability
  makeVulnerable(p);

  // Badnik attacks: if any rerolled die matches an attack, take damage.
  if (p.badniks.length) {
    const hits = [];
    for (const b of p.badniks) {
      for (const atk of (b.attacks||[])) {
        const hit = atk.color
          ? p.dicePool.some(d => d.color === atk.color && d.value === atk.value)
          : p.dicePool.some(d => d.value === atk.value);
        if (hit) hits.push({ b, atk });
      }
    }
    if (hits.length) {
      log(state, `Badnik attack hits: ${hits.map(h=>`${h.b.name}(${h.atk.color ? h.atk.color[0].toUpperCase() : "ANY"}${h.atk.value})`).join(", ")}`);
      takeDamage(state, "Badnik attack");
      if (state.pendingDamage || state.phase !== "REROLL") return state;
    } else {
      log(state, `No Badnik attacks hit.`);
    }
  } else {
    log(state, `No Badniks in front of ${p.name}.`);
  }

  // Reset counters after a reroll happens
  p.spentSinceLastReroll = 0;
  p.propellerTailBonusGivenSinceReroll = false;
  p.lastChainSpendRule = null;

  state.phase = "SPENDING";
  return state;
}

function boostInReroll(state) {
  const p = getActivePlayer(state);
  if (state.phase !== "REROLL") return log(state, `Boost-in-reroll only usable in REROLL phase.`);
  if (p.boost <= 0) return log(state, `${p.name} has no Boost tokens.`);
  p.boost -= 1;
  log(state, `${p.name} spends 1 Boost â†’ immediately reroll Dice Pool again.`);
  return rerollStep(state, { fromBoost: true });
}

/* =======================
   End turn
   ======================= */
function endTurn(state) {
  const p = getActivePlayer(state);
  if (state.phase === "GAME_OVER") return state;
  clearSpendUi(state);
  clearDiscardUi(state);
  clearStarPostUi(state);

  const phaseBefore = state.phase;
  const badnikEndResult = runBadnikAbilities(state, "END_TURN", { state, p });
  if (badnikEndResult?.halt || state.pendingDamage || state.phase !== phaseBefore) return state;

  // If dice remain and player ends normally â†’ discard + take time
  if (p.dicePool.length) {
    p.dicePool = [];
    p.selectedDieId = null;
    if (p.blueShieldLostThisTurn) {
      log(state, `${p.name} ends turn with dice remaining but avoids taking a Time Token (Blue Shield).`);
    } else {
      state.timeTokens -= 1;
      p.timeTokensTaken += 1;
      log(state, `${p.name} ends turn with dice remaining -> discard dice and take 1 Time Token (Time left: ${state.timeTokens}).`);
    }
  } else {
    log(state, `${p.name} ends turn.`);
  }

  makeVulnerable(p);
  p.spentSinceLastReroll = 0;
  p.lastChainSpendRule = null;
  clearInvinciblePowerUps(state, p, "turn end");
  p.flameShieldArmed = false;
  p.lightningShieldArmed = false;
  p.blueShieldLostThisTurn = false;
  state.pendingDamage = null;

  const over = isGameOver(state);
  if (over) {
    state.phase = "GAME_OVER";
    log(state, `GAME OVER: ${over}`);
    return state;
  }

  state.activePlayer = (state.activePlayer + 1) % state.players.length;
  const np = getActivePlayer(state);
  np.turnsTaken = (np.turnsTaken || 0) + 1;
  np.oncePerTurn = {};
  np.rollActionSelectedThisTurn = false;
  state.phase = "ROLL_ACTION";
  log(state, `âž¡ï¸ Turn passes to ${np.name} (${np.character}).`);
  resetBuddyFlightForTurn(state);
  return state;
}

/* =======================
   UI
   ======================= */
let STATE = null;

function escapeHtml(str) {
  return str.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}

function buildRollActionDiceHint(diceSpec) {
  if (!diceSpec) return "none";
  const order = [
    { key: "blue", src: "img/dice_blue.png" },
    { key: "red", src: "img/dice_red.png" },
    { key: "yellow", src: "img/dice_yellow.png" }
  ];
  const icons = [];
  for (const item of order) {
    const count = diceSpec[item.key] || 0;
    for (let i = 0; i < count; i++) {
      icons.push({ src: item.src, key: item.key });
    }
  }
  if (!icons.length) return "none";
  const total = icons.length;
  let out = "";
  for (let i = 0; i < total; i++) {
    const icon = icons[i];
    const isSolo = total % 2 === 1 && i === 0;
    const span = isSolo ? "1 / span 2" : "auto";
    const align = isSolo ? "justify-self:center;" : "";
    out += `<img class="dice-hint-icon" src="${icon.src}" alt="${icon.key} die" style="grid-column:${span};${align}">`;
  }
  return out;
}

function getBadnikDisplayLabels(b) {
  const attacksLabel = (b.attacks || [])
    .map(a => `${a.color ? a.color[0].toUpperCase() : "ANY"}${a.value ?? ""}`)
    .join(", ") || "none";
  const avoidLabel = b.avoid
    ? `${b.avoid.color ? b.avoid.color[0].toUpperCase() : "ANY"}${b.avoid.value ?? ""}`
    : "none";
  const destroyColor = b.destroy?.color ? b.destroy.color[0].toUpperCase() : "R";
  const destroyLabel = b.destroy ? `${destroyColor}${b.destroy.value ?? ""}` : "none";
  return { attacksLabel, avoidLabel, destroyLabel };
}

function getZoneInitials(zoneId) {
  const map = {
    green_hill: "GHZ",
    stardust_speedway: "SSZ",
    lava_reef: "LRZ",
    chemical_plant: "CPZ"
  };
  if (map[zoneId]) return map[zoneId];
  if (!zoneId) return "ZONE";
  return zoneId.replace(/[^a-z]/gi, "").slice(0, 3).toUpperCase() || "ZONE";
}

function normalizeBadnikTypeId(value) {
  if (!value) return "";
  return value
    .toString()
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");
}

function getBadnikTypeDef(b) {
  const typeId = normalizeBadnikTypeId(b?.type || b?.name);
  return BADNIK_TYPE_MAP[typeId] || null;
}

function normalizeBadnikRule(rule) {
  if (!rule) return "";
  return rule
    .toString()
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");
}

function hasBadnikRule(state, ruleKey) {
  const target = normalizeBadnikRule(ruleKey);
  if (!target) return false;
  const p = getActivePlayer(state);
  for (const b of p.badniks || []) {
    const ability = b?.ability || {};
    const directRule = normalizeBadnikRule(ability.rule);
    if (directRule && directRule === target) return true;
    const rules = Array.isArray(ability.rules) ? ability.rules : [];
    for (const entry of rules) {
      const key = normalizeBadnikRule(entry?.rule || entry?.key || entry?.name || entry);
      if (key && key === target) return true;
    }
  }
  return false;
}

function getBadnikPanelColor(zoneId) {
  const zoneConfig = getZoneConfig(zoneId);
  return zoneConfig?.zoneGenerator?.badnikPanelColor || "#3a2315";
}

function formatDieChip(n, color) {
  const cls = color ? `req-${color}` : "req-any";
  const content = n != null
    ? `<img src="img/${n}.png" alt="${n}">`
    : "ANY";
  return `<span class="req-chip-stack"><span class="req-chip-border"></span><span class="req-chip ${cls}">${content}</span></span>`;
}

function buildBadnikConnectorHtml(direction = "horizontal", count = 4) {
  const chevrons = Array.from({ length: count }, () => `<span class="badnik-chevron"></span>`).join("");
  return `
    <div class="badnik-connector ${direction}">
      <div class="badnik-chevrons">${chevrons}</div>
    </div>
  `;
}

function getBadnikAbilityText(b) {
  if (b?.text) return b.text;
  if (!b?.ability?.type) return "Badnik ability: TBD";
  return `Badnik ability: ${b.ability.type.replace(/_/g, " ").toUpperCase()}`;
}

const BADNIK_INLINE_ICON_MAP = {
  ring: { src: "img/ring.png", alt: "Ring" },
  yellow_die: { src: "img/dice_yellow.png", alt: "Yellow die" },
  blue_die: { src: "img/dice_blue.png", alt: "Blue die" },
  red_die: { src: "img/dice_red.png", alt: "Red die" },
  two_hazard_dice: { src: "img/hazard_2.png", alt: "Two hazard dice" },
  hazard_die: { src: "img/dice_black.png", alt: "Hazard die" },
  lose_die: { src: "img/lose_die.png", alt: "Lose die" },
  boost: { src: "img/boost.png", alt: "Boost" }
};

function formatBadnikInlineText(text) {
  if (!text) return "";
  return text.split(/(\{[a-z0-9_]+\})/gi).map(part => {
    const match = part.match(/^\{([a-z0-9_]+)\}$/i);
    if (!match) return escapeHtml(part);
    const key = match[1].toLowerCase();
    const icon = BADNIK_INLINE_ICON_MAP[key];
    if (!icon) return escapeHtml(part);
    return `<img class="inline-icon" src="${icon.src}" alt="${escapeHtml(icon.alt || key)}">`;
  }).join("");
}

function formatBadnikAbilityText(b) {
  const baseText = getBadnikAbilityText(b);
  const abilityType = normalizeBadnikTiming(b?.ability?.type || "");
  const desc = formatBadnikInlineText(baseText || "");
  if (!abilityType || abilityType === "PASSIVE") {
    return desc;
  }
  const label = abilityType.replace(/_/g, " ");
  return `<span class="ability-text"><span class="ability-prefix">${escapeHtml(label)}:</span> ${desc}</span>`;
}

function buildBadnikCardHtml(b, zoneId, index) {
  const attackList = (b.attacks || []).map(a => formatDieChip(a.value ?? null, a.color ?? null));
  const attackTop = attackList[0] || "";
  const attackRest = attackList.slice(1).join("");
  const hasAttacks = attackList.length > 0;
  const avoidChip = b.avoid ? formatDieChip(b.avoid.value ?? null, b.avoid.color ?? null) : "";
  const destroyChip = b.destroy ? formatDieChip(b.destroy.value ?? null, b.destroy.color ?? "red") : "";
  const typeDef = getBadnikTypeDef(b);
  const displayName = b.name || typeDef?.name || "BADNIK";
  const artSrc = b.image || typeDef?.image || "img/badnik.png";
  const abilityText = formatBadnikAbilityText(b);
  const zone = getZoneInitials(zoneId);
  const panelColor = getBadnikPanelColor(zoneId);
  const hitsRequired = getBadnikHitsRequired(b);
  const hitsTaken = Number.isFinite(b.hitsTaken) ? b.hitsTaken : 0;
  const flippedClass = b.flipped ? " flipped" : "";
  const flipAnimClass = b.flipAnim ? " flip-anim" : "";
  if (b.flipAnim) b.flipAnim = false;
  return `
    <div class="badnik-card${flippedClass}${flipAnimClass}" data-badnik-index="${index}" data-badnik-hits="${hitsTaken}" data-badnik-hits-required="${hitsRequired}" style="--badnik-art: url('${artSrc}'); --badnik-panel-base: ${panelColor};">
      <div class="badnik-attack-col">
      <div class="badnik-attack-dice">
        <div class="badnik-attack-top">${attackTop}</div>
        ${attackRest ? `<div class="badnik-attack-overlap">${attackRest}</div>` : ""}
      </div>
      ${hasAttacks ? buildBadnikConnectorHtml("vertical", 7) : ""}
      ${hasAttacks ? `
      <div class="badnik-sonic">
        <img src="img/sonic_damage.png" alt="Sonic damage">
      </div>` : ""}
    </div>
      <div class="badnik-hatch"></div>
      <div class="badnik-main">
        <div class="badnik-name">${escapeHtml(displayName)}</div>
        <div class="badnik-right">
          ${destroyChip ? `
            <div class="badnik-right-row" data-badnik-mode="destroy">
              ${destroyChip}
              ${buildBadnikConnectorHtml("horizontal", 8)}
              <div class="badnik-animal">
                <img src="img/animal_flicky.png" alt="Animal token">
              </div>
            </div>
          ` : ""}
          ${avoidChip ? `
            <div class="badnik-right-row" data-badnik-mode="avoid">
              ${avoidChip}
              ${buildBadnikConnectorHtml("horizontal", 8)}
            </div>
          ` : ""}
        </div>
        <div class="badnik-ability">${abilityText}</div>
        <div class="badnik-zone">${escapeHtml(zone)}</div>
      </div>
    </div>
  `;
}

function getTimeBonusPoints(playerCount, place) {
  const table = {
    2: { 1: 100, 2: 0 },
    3: { 1: 150, 2: 50, 3: 0 },
    4: { 1: 200, 2: 100, 3: 50, 4: 0 }
  };
  return table[playerCount]?.[place] ?? 0;
}

function getSoloTimePoints(timeTokensTaken) {
  if (timeTokensTaken <= 0) return 200;
  if (timeTokensTaken <= 2) return 100;
  if (timeTokensTaken <= 4) return 50;
  return 0;
}

function getRingPoints(p) {
  const heldValue = p.hyperRing ? 15 : 10;
  return (p.heldRings * heldValue) + (p.savedRings * 10);
}

function getAnimalPoints(p) {
  return p.animalTokens * 20;
}

function getLifeLossPoints(p) {
  const startingLives = 3;
  const lost = Math.max(0, startingLives - p.lives);
  return lost * -30;
}

function getChaosEmeraldPoints(p) {
  const counts = getChaosCounts(p);
  return (counts.ready * 50) + (counts.spent * 20);
}

function computeTimeScores(state) {
  const entries = state.players.map(p => ({
    id: p.id,
    name: p.name,
    character: p.character,
    speed: (p.zoneCardsCompleted * 3) - p.timeTokensTaken
  }));

  if (entries.length <= 1) {
    return entries.map(e => ({
      ...e,
      place: null,
      points: getSoloTimePoints(state.players[0]?.timeTokensTaken ?? 0)
    }));
  }

  entries.sort((a, b) => b.speed - a.speed);
  let rank = 1;
  let i = 0;
  while (i < entries.length) {
    let j = i + 1;
    while (j < entries.length && entries[j].speed === entries[i].speed) j++;
    const groupSize = j - i;
    const assignedPlace = rank + groupSize - 1;
    const points = getTimeBonusPoints(entries.length, assignedPlace);
    for (let k = i; k < j; k++) {
      entries[k].place = assignedPlace;
      entries[k].points = points;
    }
    rank += groupSize;
    i = j;
  }
  return entries;
}

function computeScoreSummary(state) {
  const timeScores = computeTimeScores(state);
  const timeById = new Map(timeScores.map(entry => [entry.id, entry]));
  return state.players.map(p => {
    const timeEntry = timeById.get(p.id);
    const ringPoints = getRingPoints(p);
    const animalPoints = getAnimalPoints(p);
    const lifePoints = getLifeLossPoints(p);
    const chaosPoints = getChaosEmeraldPoints(p);
    const timePoints = timeEntry?.points ?? 0;
    return {
      id: p.id,
      name: p.name,
      character: p.character,
      speed: timeEntry?.speed ?? null,
      place: timeEntry?.place ?? null,
      timePoints,
      ringPoints,
      animalPoints,
      lifePoints,
      chaosPoints,
      totalPoints: timePoints + ringPoints + animalPoints + lifePoints + chaosPoints
    };
  });
}

function render() {
  const s = STATE;
  if (!s) return;
  ensureZoneConnectorResizeHandler();

  const animateDice = !!s.ui?.rollAnim;
  if (animateDice && s.ui) s.ui.rollAnim = false;

  if (s.pendingBonusStage && !s.bonusStage?.open && canStartBonusStage(s)) {
    const reason = s.pendingBonusStage.reasons.shift();
    if (!s.pendingBonusStage.reasons.length) s.pendingBonusStage = null;
    enterBonusStage(s, reason);
  }

  const p = getActivePlayer(s);
  const ra = getRollActionCfg(p);
  const chaosCounts = getChaosCounts(p);

  const controlsCard = document.getElementById("controlsCard");
  if (controlsCard) controlsCard.dataset.character = p.character;
  const characterHeading = document.getElementById("characterHeading");
  if (characterHeading) {
    const label = `${p.name} - ${p.character}`;
    const score = computeScoreSummary(s)?.find(entry => entry.id === p.id)?.totalPoints ?? 0;
    characterHeading.innerHTML = `
      <div class="character-heading-row">
        <span class="character-heading-score">
          <img src="img/hud_score.png" alt="Score">
          ${formatPixelScore(score)}
        </span>
        <span class="character-heading-name">${escapeHtml(label)}</span>
      </div>
      <div class="badge badge-tight">Lives ${p.lives} | Boost ${p.boost} | Held ${p.heldRings} | Saved ${p.savedRings} | Animals ${p.animalTokens} | Time Taken ${p.timeTokensTaken}</div>
    `;
  }

  if (s.ui?.spend?.open) {
    const hasDie = p.dicePool.some(d => d.id === s.ui.spend.dieId);
    if (s.phase !== "SPENDING" || !hasDie) clearSpendUi(s);
  }
  if (s.ui?.discard?.open) {
    if (s.phase !== "SPENDING" || p.dicePool.length < 2) clearDiscardUi(s);
  }
  if (s.ui?.starPost?.open) {
    if (p.heldRings <= 0) clearStarPostUi(s);
  }
  if (s.pendingPowerUp || s.pendingDamage || s.pendingBadnikReward || s.pendingWallClimb || s.pendingAvoid || s.bonusStage?.open) {
    clearSpendUi(s);
  }

  document.getElementById("phase").textContent = s.phase;
  document.getElementById("invuln").textContent = p.invulnerable ? "YES" : "NO";
  document.getElementById("spentSinceReroll").textContent = p.spentSinceLastReroll;

  const buddyFlightValue = s.buddyFlight?.value ?? 0;
  const buddyFlightMarkup = buddyFlightValue > 0
    ? `<div><span class="badge buddy-flight">Buddy Flight</span> <span class="buddy-flight-value">${buddyFlightValue}</span></div>`
    : "";
  const buddyFlightBadge = document.getElementById("buddyFlightBadge");
  if (buddyFlightBadge) buddyFlightBadge.innerHTML = buddyFlightMarkup;
  const chainBadge = document.getElementById("chainSpendRuleBadge");
  if (chainBadge) {
    chainBadge.innerHTML = p.lastChainSpendRule
      ? `<div class="pill tiny warn"><b>Chain rule</b> ${p.lastChainSpendRule.color.toUpperCase()} must be lower than ${p.lastChainSpendRule.lastSpentValue}</div>`
      : "";
  }

  const powerStatus = document.getElementById("powerUpStatus");
  if (powerStatus) {
    const shieldImg = getShieldImageSrc(p.shield?.type);
    const hyperImg = p.hyperRing ? "img/power_up_hyper_ring.png" : "img/power_up_hyper_ring_off.png";
    const invImg = p.invincible ? "img/power_up_invincible.png" : "img/power_up_invincible_off.png";
    powerStatus.innerHTML = `
      <div class="power-up-status">
        <div class="power-up-slot" title="Shield">
          <img src="${shieldImg}" alt="Shield">
        </div>
        <div class="power-up-slot" title="Hyper Ring">
          <img src="${hyperImg}" alt="Hyper Ring">
        </div>
        <div class="power-up-slot" title="Invincible">
          <img src="${invImg}" alt="Invincible">
        </div>
      </div>
      ${p.flameShieldArmed ? `<div class="pill tiny warn"><b>Flame Armed</b> yes</div>` : ""}
      ${p.lightningShieldArmed ? `<div class="pill tiny warn"><b>Lightning Armed</b> yes</div>` : ""}
    `;
  }

  const powerPanel = document.getElementById("powerUpPanel");
  if (powerPanel) {
    if (s.pendingAvoid) {
      const canBoost = p.boost > 0;
      const canBubble = p.shield?.type === "bubble" && !p.oncePerTurn.bubbleShieldUsed && p.dicePool.length > 0;
      powerPanel.innerHTML = `
        <div class="pill tiny warn"><b>Avoid Damage</b> ${escapeHtml(s.pendingAvoid.reason || "No legal spend available")}</div>
        <div class="row">
          <button id="avoidBoostBtn">Use Boost Token</button>
          ${canBubble ? `<button id="avoidBubbleBtn">Bubble Shield: Reroll Selected Die</button>` : ""}
          <button id="avoidDamageBtn">Take Damage</button>
        </div>
      `;
      const boostBtn = powerPanel.querySelector("#avoidBoostBtn");
      if (boostBtn) {
        boostBtn.disabled = !canBoost;
        boostBtn.addEventListener("click", () => {
          resolveAvoidBoost(STATE);
          render();
        });
      }
      const bubbleBtn = powerPanel.querySelector("#avoidBubbleBtn");
      if (bubbleBtn) {
        bubbleBtn.disabled = !canBubble;
        bubbleBtn.addEventListener("click", () => {
          resolveAvoidBubble(STATE);
          render();
        });
      }
      const dmgBtn = powerPanel.querySelector("#avoidDamageBtn");
      if (dmgBtn) {
        dmgBtn.addEventListener("click", () => {
          resolveAvoidTakeDamage(STATE);
          render();
        });
      }
    } else if (s.pendingDamage) {
      powerPanel.innerHTML = `
        <div class="pill tiny warn"><b>Invincible</b> Discard a die to ignore damage.</div>
        <div id="invincibleDice"></div>
        <div class="row">
          <button id="invincibleConfirm">Discard Selected Die</button>
          <button id="invincibleDecline">Take Damage</button>
        </div>
      `;
      const diceWrap = powerPanel.querySelector("#invincibleDice");
      for (const d of p.dicePool) {
        const el = document.createElement("div");
        el.className = `die ${d.color}` + (s.pendingDamage.selectedDieId === d.id ? " selected" : "");
        el.innerHTML = buildDieFaceHtml(d.value);
        el.title = d.color;
        el.addEventListener("click", () => {
          s.pendingDamage.selectedDieId = d.id;
          render();
        });
        diceWrap.appendChild(el);
      }
      const confirmBtn = powerPanel.querySelector("#invincibleConfirm");
      confirmBtn.disabled = !s.pendingDamage.selectedDieId;
      confirmBtn.addEventListener("click", () => {
        confirmInvincibleDiscard(STATE);
        render();
      });
      powerPanel.querySelector("#invincibleDecline").addEventListener("click", () => {
        declineInvincible(STATE);
        render();
      });
    } else if (s.pendingPowerUp) {
      if (s.pendingPowerUp.kind === "eggman_mark") {
        powerPanel.innerHTML = `
          <div class="pill tiny warn"><b>Eggman Mark</b> Choose a player to receive a Badnik.</div>
          <div id="eggmanTargets" class="row"></div>
        `;
        const targetWrap = powerPanel.querySelector("#eggmanTargets");
        for (const pl of s.players) {
          const btn = document.createElement("button");
          btn.textContent = `${pl.name} (${pl.character})`;
          btn.addEventListener("click", () => {
            resolveEggmanMark(STATE, pl.id);
            render();
          });
          targetWrap.appendChild(btn);
        }
      } else if (s.pendingPowerUp.kind === "one_up") {
        powerPanel.innerHTML = `
          <div class="pill tiny warn"><b>1-Up</b> Choose a die color to add.</div>
          <div class="row">
            <button id="oneUpBlue">Blue Die</button>
            <button id="oneUpYellow">Yellow Die</button>
            <button id="oneUpRed">Red Die</button>
          </div>
        `;
        powerPanel.querySelector("#oneUpBlue").addEventListener("click", () => {
          resolveOneUp(STATE, DieColor.BLUE);
          render();
        });
        powerPanel.querySelector("#oneUpYellow").addEventListener("click", () => {
          resolveOneUp(STATE, DieColor.YELLOW);
          render();
        });
        powerPanel.querySelector("#oneUpRed").addEventListener("click", () => {
          resolveOneUp(STATE, DieColor.RED);
          render();
        });
      } else if (s.pendingPowerUp.kind === "add_dice") {
        powerPanel.innerHTML = `
          <div class="pill tiny warn"><b>Add Dice</b> Choose a die color to add.</div>
          <div class="row">
            <button id="addDiceBlue">Blue Die</button>
            <button id="addDiceYellow">Yellow Die</button>
            <button id="addDiceRed">Red Die</button>
          </div>
        `;
        powerPanel.querySelector("#addDiceBlue").addEventListener("click", () => {
          resolveAddDice(STATE, DieColor.BLUE);
          render();
        });
        powerPanel.querySelector("#addDiceYellow").addEventListener("click", () => {
          resolveAddDice(STATE, DieColor.YELLOW);
          render();
        });
        powerPanel.querySelector("#addDiceRed").addEventListener("click", () => {
          resolveAddDice(STATE, DieColor.RED);
          render();
        });
      } else if (s.pendingPowerUp.kind === "shield_swap") {
        const pendingShield = s.pendingPowerUp.newShield;
        powerPanel.innerHTML = `
          <div class="pill tiny warn"><b>Shield Choice</b> Keep current or swap.</div>
          <div class="tiny">Current: ${p.shield ? getShieldLabel(p.shield.type) : "None"}</div>
          <div class="tiny">New: ${getShieldLabel(pendingShield)}</div>
          <div class="row">
            <button id="shieldKeepBtn">Keep Current</button>
            <button id="shieldSwapBtn">Take New</button>
          </div>
        `;
        powerPanel.querySelector("#shieldKeepBtn").addEventListener("click", () => {
          resolveShieldSwap(STATE, true);
          render();
        });
        powerPanel.querySelector("#shieldSwapBtn").addEventListener("click", () => {
          resolveShieldSwap(STATE, false);
          render();
        });
      }
    } else if (s.pendingBadnikReward) {
      const eligible = getEligibleBadnikTargets(s);
      powerPanel.innerHTML = `
        <div class="pill tiny warn"><b>Badnik Reward</b> Choose a player to draw a Badnik.</div>
        <div class="tiny">Remaining selections: ${s.pendingBadnikReward.remaining}</div>
        <div id="badnikRewardTargets" class="row"></div>
      `;
      const targetWrap = powerPanel.querySelector("#badnikRewardTargets");
      for (const pl of eligible) {
        const btn = document.createElement("button");
        btn.textContent = `${pl.name} (${pl.character})`;
        btn.addEventListener("click", () => {
          resolveBadnikRewardChoice(STATE, pl.id);
          render();
        });
        targetWrap.appendChild(btn);
      }
    } else {
      powerPanel.innerHTML = "";
      const actions = [];
      if (p.shield && p.shield.type === "flame") {
        actions.push(`<button id="flameShieldBtn">${p.flameShieldArmed ? "Flame Shield Armed" : "Use Flame Shield"}</button>`);
      }
      if (p.shield && p.shield.type === "bubble") {
        actions.push(`<button id="bubbleShieldBtn">Bubble Shield: Reroll Selected Die</button>`);
      }
      if (p.shield && p.shield.type === "lightning") {
        actions.push(`<button id="lightningShieldBtn">${p.lightningShieldArmed ? "Lightning Armed" : "Arm Lightning Shield"}</button>`);
      }
      if (actions.length) {
        powerPanel.innerHTML = `<div class="row">${actions.join("")}</div>`;
      } else {
        powerPanel.innerHTML = `<div class="muted">No pending Power Ups.</div>`;
      }

      const flameBtn = powerPanel.querySelector("#flameShieldBtn");
      if (flameBtn) {
        flameBtn.disabled = s.phase !== "SPENDING" || p.oncePerTurn.flameShieldUsed;
        flameBtn.addEventListener("click", () => {
          p.flameShieldArmed = !p.flameShieldArmed;
          log(s, `${p.name} ${p.flameShieldArmed ? "arms" : "disarms"} Flame Shield for the next spend.`);
          render();
        });
      }

      const bubbleBtn = powerPanel.querySelector("#bubbleShieldBtn");
      if (bubbleBtn) {
        bubbleBtn.disabled = p.oncePerTurn.bubbleShieldUsed || p.dicePool.length === 0;
        bubbleBtn.addEventListener("click", () => {
          const target = p.dicePool.find(d => d.id === p.selectedDieId) || (p.dicePool.length === 1 ? p.dicePool[0] : null);
          if (!target) {
            log(s, `${p.name} Bubble Shield: select a die to reroll.`);
            return;
          }
          const newValue = rollD6();
          target.value = newValue;
          p.oncePerTurn.bubbleShieldUsed = true;
          log(s, `${p.name} Bubble Shield rerolls ${target.color.toUpperCase()}-${newValue}.`);
          render();
        });
      }

      const lightningBtn = powerPanel.querySelector("#lightningShieldBtn");
      if (lightningBtn) {
        lightningBtn.disabled = p.oncePerTurn.lightningShieldUsed || p.lightningShieldArmed;
        lightningBtn.addEventListener("click", () => {
          p.lightningShieldArmed = true;
          log(s, `${p.name} arms Lightning Shield to change the next reward to rings x2.`);
          render();
        });
      }
    }
  }

  const chaosPanel = document.getElementById("chaosEmeraldPanel");
  if (chaosPanel) {
    const emeralds = p.chaosEmeralds || [];
    if (!emeralds.length) {
      chaosPanel.textContent = "No Chaos Emeralds.";
    } else {
      const chaosBlocked = !!s.ui?.discard?.open || !!s.ui?.starPost?.open ||
        s.pendingPowerUp || s.pendingDamage || s.pendingBadnikReward || s.pendingWallClimb || s.bonusStage?.open;
      chaosPanel.innerHTML = `<div class="chaos-emerald-list"></div>`;
      const list = chaosPanel.querySelector(".chaos-emerald-list");
      emeralds.forEach(card => {
        const cardEl = document.createElement("div");
        cardEl.className = `chaos-emerald-card ${card.spent ? "spent" : ""}`;
        cardEl.innerHTML = `
          <img src="${card.img}" alt="${escapeHtml(getChaosEmeraldLabel(card))}">
          <div>${escapeHtml(getChaosEmeraldLabel(card))}</div>
        `;
        if (!card.spent) {
          const canSpend = Array.isArray(card.diceBonusColors) && card.diceBonusColors.length === 2;
          const btn = document.createElement("button");
          btn.textContent = canSpend ? "Spend" : "Spend (TBD)";
          btn.disabled = chaosBlocked || !canSpend;
          btn.addEventListener("click", () => {
            spendChaosEmerald(STATE, card.id);
            render();
          });
          cardEl.appendChild(btn);
        } else {
          const tag = document.createElement("div");
          tag.className = "muted";
          tag.textContent = "Spent";
          cardEl.appendChild(tag);
        }
        list.appendChild(cardEl);
      });
    }
  }

  // Buttons
  const dis = (id, v) => document.getElementById(id).disabled = !!v;
  const discardOpen = !!s.ui?.discard?.open;
  const starPostOpen = !!s.ui?.starPost?.open;
  const powerOpen = !!s.pendingPowerUp;
  const damageOpen = !!s.pendingDamage;
  const badnikRewardOpen = !!s.pendingBadnikReward;
  const wallClimbOpen = !!s.pendingWallClimb;
  const bonusStageOpen = !!s.bonusStage?.open;
  const avoidOpen = !!s.pendingAvoid;
  const actionBlocked = discardOpen || starPostOpen || powerOpen || damageOpen || badnikRewardOpen || wallClimbOpen || avoidOpen || bonusStageOpen;
  dis("btnBuildPool", s.phase !== "ROLL_ACTION" || actionBlocked || !p.rollActionSelectedThisTurn);
  dis("btnSpendDie", s.phase !== "SPENDING" || !p.dicePool.length || actionBlocked);
  const canOptionalReroll = s.phase === "SPENDING" && p.spentSinceLastReroll > 0 && p.dicePool.length > 0;
  const canInvulnReroll = s.phase === "SPENDING" && p.invulnerable && p.dicePool.length > 0;
  dis("btnRerollStep", !(s.phase === "REROLL" || canOptionalReroll || canInvulnReroll) || actionBlocked);
  const canUseBoost =
    (s.phase === "SPENDING" && p.boost > 0 && p.dicePool.length > 0);
  dis("btnUseBoostToken", !canUseBoost || actionBlocked);
  dis("btnEndTurn", !(s.phase==="SPENDING" || s.phase==="REROLL" || s.phase==="END_TURN") || actionBlocked);
  dis("btnForceBonusStage", bonusStageOpen);

  // Roll action buttons
  const raWrap = document.getElementById("rollActionButtons");
  raWrap.innerHTML = "";
  for (const a of getCharCfg(p).rollActions) {
    const btn = document.createElement("button");
    const hint = buildRollActionDiceHint(a.dice);
    btn.className = `roll-action-btn ${p.rollActionSelectedThisTurn && p.chosenRollAction === a.name ? "active" : ""}`;
    btn.innerHTML = `
      <div class="roll-action-icon-box">
        <div class="roll-action-icon">${hint === "none" ? "" : hint}</div>
      </div>
      <div class="roll-action-label">${escapeHtml(a.name)}</div>
    `;
    btn.disabled = s.phase !== "ROLL_ACTION" || actionBlocked;
    btn.addEventListener("click", () => {
      p.chosenRollAction = a.name;
      p.rollActionSelectedThisTurn = true;
      log(s, `${p.name} set Roll Action to: ${p.chosenRollAction}`);
      render();
    });
    raWrap.appendChild(btn);
  }
  // Dice pool
  const dp = document.getElementById("dicePool");
  dp.innerHTML = "";
  const discardUi = s.ui?.discard;
  const selectedDieId = discardUi?.open ? discardUi.selectedDieId : p.selectedDieId;
  for (const d of p.dicePool) {
    const el = document.createElement("div");
    el.className = `die ${d.color}` + (selectedDieId === d.id ? " selected" : "") + (animateDice ? " roll-shake" : "");
    el.innerHTML = buildDieFaceHtml(d.value);
    el.title = d.color;
    el.addEventListener("click", () => {
      if (damageOpen || powerOpen || badnikRewardOpen || wallClimbOpen || avoidOpen || bonusStageOpen) return;
      if (discardUi?.open) {
        discardUi.selectedDieId = d.id;
      } else {
        p.selectedDieId = d.id;
      }
      render();
    });
    dp.appendChild(el);
  }

  // Wall Climb panel
  const wallSection = document.getElementById("wallClimbSection");
  const wallPanel = document.getElementById("wallClimbPanel");
  const pendingWall = s.pendingWallClimb;
  if (wallPanel) {
    if (!pendingWall) {
      if (wallSection) wallSection.style.display = "none";
      wallPanel.textContent = "";
    } else {
      if (wallSection) wallSection.style.display = "";
      const lastLabel = pendingWall.lastSaved > 0 ? pendingWall.lastSaved : "-";
      wallPanel.innerHTML = `
        <div class="pill tiny">Roll ${pendingWall.rollIndex}/3 | Last Saved ${lastLabel}</div>
        <div id="wallClimbDice" class="row"></div>
        <div class="row target-actions">
          <button id="wallClimbConfirm">Save Selected Dice</button>
          <button id="wallClimbSaveNone">Save None</button>
        </div>
      `;
      const diceWrap = wallPanel.querySelector("#wallClimbDice");
      for (const d of pendingWall.batch) {
        const disabled = d.value <= pendingWall.lastSaved;
        const selected = pendingWall.selectedIds.includes(d.id);
        const el = document.createElement("div");
        el.className = `die ${d.color}` + (selected ? " selected" : "") + (disabled ? " disabled" : "");
        el.innerHTML = buildDieFaceHtml(d.value);
        el.title = d.color;
        el.addEventListener("click", () => {
          if (disabled) return;
          if (pendingWall.selectedIds.includes(d.id)) {
            pendingWall.selectedIds = pendingWall.selectedIds.filter(id => id !== d.id);
          } else {
            pendingWall.selectedIds.push(d.id);
          }
          render();
        });
        diceWrap.appendChild(el);
      }
      const selectedDice = pendingWall.batch.filter(d => pendingWall.selectedIds.includes(d.id));
      const values = selectedDice.map(d => d.value).sort((a, b) => a - b);
      let valid = values.every(v => v > pendingWall.lastSaved);
      for (let i = 1; i < values.length; i++) {
        if (values[i] <= values[i - 1]) valid = false;
      }
      const confirmBtn = wallPanel.querySelector("#wallClimbConfirm");
      const saveNoneBtn = wallPanel.querySelector("#wallClimbSaveNone");
      confirmBtn.disabled = !valid;
      confirmBtn.addEventListener("click", () => {
        confirmWallClimbSelection(STATE);
        render();
      });
      saveNoneBtn.addEventListener("click", () => {
        confirmWallClimbSelection(STATE, true);
        render();
      });
    }
  }

  // Discard panel
  const discardSection = document.getElementById("discardSection");
  const discardPanel = document.getElementById("discardPanel");
  if (discardPanel) {
    if (!discardUi || !discardUi.open) {
      if (discardSection) discardSection.style.display = "none";
      discardPanel.textContent = "";
    } else {
      if (discardSection) discardSection.style.display = "";
      const selected = p.dicePool.find(d => d.id === discardUi.selectedDieId);
      const label = selected ? `${selected.color.toUpperCase()}-${selected.value}` : "Select a die to discard.";
      discardPanel.innerHTML = `
        <div class="pill tiny">Discard: ${label}</div>
        <div class="row target-actions">
          <button id="btnConfirmDiscard">Discard Selected Die</button>
        </div>
      `;
      const btn = discardPanel.querySelector("#btnConfirmDiscard");
      if (btn) {
        btn.disabled = !selected;
        btn.addEventListener("click", () => { confirmDiscardSelection(STATE); render(); });
      }
    }
  }

  // Star Post panel
  const starPostSection = document.getElementById("starPostSection");
  const starPostPanel = document.getElementById("starPostPanel");
  const starUi = s.ui?.starPost;
  if (starPostPanel) {
    if (!starUi || !starUi.open) {
      if (starPostSection) starPostSection.style.display = "none";
      starPostPanel.textContent = "";
    } else {
      if (starPostSection) starPostSection.style.display = "";
      starPostPanel.innerHTML = `
        <div class="pill tiny">Held Rings: ${p.heldRings}</div>
        <div class="row target-actions">
          <button id="btnStarPostSave">Save All Rings</button>
          <button id="btnStarPostKeep">Keep Held Rings</button>
        </div>
      `;
      const btnSave = starPostPanel.querySelector("#btnStarPostSave");
      const btnKeep = starPostPanel.querySelector("#btnStarPostKeep");
      if (btnSave) btnSave.addEventListener("click", () => { confirmStarPostSave(STATE); render(); });
      if (btnKeep) btnKeep.addEventListener("click", () => { confirmStarPostKeep(STATE); render(); });
    }
  }

  // Spend target selection
  const spendPanel = document.getElementById("spendTargetPanel");
  const spendUi = s.ui?.spend;
  if (!spendUi || !spendUi.open) {
    spendPanel.textContent = `Select a die and click "Spend Selected Die" to choose a target. Tip: click a Zone/Badnik card to preselect.`;
  } else {
    const die = p.dicePool.find(d => d.id === spendUi.dieId);
    const dieLabel = die ? `${die.color.toUpperCase()}-${die.value}` : "Unknown";
    const canAmyRaise = p.character === "Amy" && die && die.color === DieColor.RED;
    const buddyFlightValue = s.buddyFlight?.value ?? 0;
    const buddyFlightAvailable = buddyFlightValue > 0 && !!die;
    const buddyInfo = buddyFlightAvailable ? getEffectiveSpendDie(s, p, die, {
      useFlameShieldOverride: spendUi.useFlameShield,
      useAmyRaise: spendUi.amyRaise,
      buddyFlightDelta: spendUi.buddyFlightDelta
    }) : null;
    const buddyDeltaLabel = buddyInfo
      ? (buddyInfo.buddyFlightDelta > 0 ? `+${buddyInfo.buddyFlightDelta}` : `${buddyInfo.buddyFlightDelta}`)
      : "0";
    const buddyRange = buddyInfo ? getBuddyFlightDeltaRange(buddyFlightValue, buddyInfo.buddyFlightBaseValue) : { min: 0, max: 0 };
    spendPanel.innerHTML = `
      <div class="pill tiny">Die: ${dieLabel}</div>
      ${canAmyRaise ? `<div class="row target-actions">
        <button id="btnAmyRaise">${spendUi.amyRaise ? "Piko Piko Hammer (+1) ON" : "Use Piko Piko Hammer (+1)"}</button>
      </div>` : ""}
      ${buddyFlightAvailable ? `
        <div class="pill tiny">
          <b>Buddy Flight</b>
          <div class="die yellow">${buildDieFaceHtml(buddyFlightValue)}</div>
          <span class="muted">Adjust ${buddyInfo.buddyFlightBaseValue} â†’ ${buddyInfo.buddyFlightAdjustedValue} (${buddyDeltaLabel})</span>
        </div>
        <div class="row target-actions">
          <button id="buddyFlightDown">-1</button>
          <button id="buddyFlightReset">Reset</button>
          <button id="buddyFlightUp">+1</button>
        </div>
      ` : ""}
      <div class="target-list"></div>
      <div class="row target-actions">
        <button id="btnConfirmSpend">Confirm Spend</button>
        <button id="btnCancelSpend">Cancel</button>
      </div>
    `;
    if (canAmyRaise) {
      const btnAmy = spendPanel.querySelector("#btnAmyRaise");
      btnAmy.addEventListener("click", () => {
        spendUi.amyRaise = !spendUi.amyRaise;
        const ok = refreshSpendTargets(STATE, die);
        if (!ok) {
          log(s, "No legal spend targets with Piko Piko Hammer.");
        }
        render();
      });
    }
    if (buddyFlightAvailable) {
      const btnDown = spendPanel.querySelector("#buddyFlightDown");
      const btnUp = spendPanel.querySelector("#buddyFlightUp");
      const btnReset = spendPanel.querySelector("#buddyFlightReset");
      if (btnDown) {
        btnDown.disabled = buddyInfo.buddyFlightDelta <= buddyRange.min;
        btnDown.addEventListener("click", () => {
          spendUi.buddyFlightDelta = buddyInfo.buddyFlightDelta - 1;
          const ok = refreshSpendTargets(STATE, die);
          if (!ok) {
            log(s, "No legal spend targets with Buddy Flight adjustment.");
          }
          render();
        });
      }
      if (btnUp) {
        btnUp.disabled = buddyInfo.buddyFlightDelta >= buddyRange.max;
        btnUp.addEventListener("click", () => {
          spendUi.buddyFlightDelta = buddyInfo.buddyFlightDelta + 1;
          const ok = refreshSpendTargets(STATE, die);
          if (!ok) {
            log(s, "No legal spend targets with Buddy Flight adjustment.");
          }
          render();
        });
      }
      if (btnReset) {
        btnReset.disabled = buddyInfo.buddyFlightDelta === 0;
        btnReset.addEventListener("click", () => {
          spendUi.buddyFlightDelta = 0;
          const ok = refreshSpendTargets(STATE, die);
          if (!ok) {
            log(s, "No legal spend targets with Buddy Flight adjustment.");
          }
          render();
        });
      }
    }
    const list = spendPanel.querySelector(".target-list");
    for (const t of spendUi.targets) {
      const item = document.createElement("div");
      item.className = `target-item ${t.id === spendUi.selectedTargetId ? "selected" : ""}`;
      item.textContent = t.label;
      item.addEventListener("click", () => { spendUi.selectedTargetId = t.id; render(); });
      list.appendChild(item);
    }
    const btnConfirm = spendPanel.querySelector("#btnConfirmSpend");
    const btnCancel = spendPanel.querySelector("#btnCancelSpend");
    if (btnConfirm) {
      btnConfirm.disabled = !die || !spendUi.selectedTargetId;
      btnConfirm.addEventListener("click", () => { confirmSpendSelection(STATE); render(); });
    }
    if (btnCancel) {
      btnCancel.addEventListener("click", () => { cancelSpendSelection(STATE); render(); });
    }
  }

  // Zone view
  const zv = document.getElementById("zoneView");
  zv.innerHTML = "";
  const zoneHeader = document.getElementById("zoneHeaderInfo");
  if (zoneHeader) {
    const deckRemaining = s.zone?.deck?.length ?? 0;
    const actName = s.actBoard?.name || "Act 1";
    zoneHeader.innerHTML = `
      <div class="zone-level-name">
        <span class="zone-title">${escapeHtml(actName)}</span>
        <span class="zone-deck">Deck ${deckRemaining}</span>
      </div>
    `;
  }
  const zoneConfig = getZoneConfig(s.zoneId);
  const zoneSpaceBg = zoneConfig?.zoneGenerator?.spaceBackground
    || CONFIG.zoneGenerator?.spaceBackground
    || "#0f1733";
  const zoneSpaceBgImage = zoneConfig?.zoneGenerator?.spaceBackgroundImage
    || zoneConfig?.zoneGenerator?.spaceBackgroundImages?.[0]
    || CONFIG.zoneGenerator?.spaceBackgroundImage
    || CONFIG.zoneGenerator?.spaceBackgroundImages?.[0]
    || null;
  const chevronGradient = getChevronGradient(zoneConfig);
  const actBoardView = document.getElementById("actBoardView");
  if (actBoardView) {
    const actChevron = getActChevronGradient(zoneConfig);
    const routes = ["Top","Middle","Bottom"].map(name => ({
      name,
      reward: getActBoardReward(s, name)
    }));
    renderActBoard(actBoardView, {
      routes,
      cardGradient: s.actBoard?.cardGradient,
      chevronGradient: actChevron,
      idPrefix: "act"
    });
  }
  for (const route of s.zone.routes) {
    const cardData = route.activeCard;
    const card = document.createElement("div");
    card.className = "card zone-card secret-passage";
    const gradient = buildGradientCss(s.actBoard?.cardGradient);
    if (zoneSpaceBg) card.style.setProperty("--zone-space-bg", zoneSpaceBg);
    if (gradient) card.style.setProperty("--zone-card-gradient", gradient);
    const { html: trackHtml, availableIds } = buildCardTrackHtml(cardData, zoneSpaceBgImage);
    const zoneName = zoneConfig?.name || "Zone";
    card.innerHTML = `
      <div class="zone-card-inner">
        <div class="zone-card-face zone-card-front">
          ${trackHtml}
        </div>
        <div class="zone-card-face zone-card-back">
          <div>${escapeHtml(zoneName)}</div>
        </div>
      </div>
    `;
    if (cardData && !cardData.revealed) {
      card.classList.add("flip-in");
      cardData.revealed = true;
    }
    if (cardData) {
      card.title = "Click a challenge to preselect spend target";
      card.addEventListener("click", (event) => {
        const target = event.target.closest("[data-challenge-id]");
        if (!target) return;
        const challengeId = target.getAttribute("data-challenge-id");
        if (!availableIds.has(challengeId)) return;
        preselectSpendTarget(STATE, { type:"zone", routeId: route.id, challengeId });
        render();
      });
    }
    zv.appendChild(card);
    scheduleZoneCardConnectors(card, cardData, chevronGradient);
  }

  const secretRow = document.getElementById("secretPassageRow");
  const secretView = document.getElementById("secretPassageView");
  const secretActBoardView = document.getElementById("secretActBoardView");
  if (secretRow && secretView) {
    secretView.innerHTML = "";
  }
  if (p.character === "Knuckles" && s.secretPassage?.card && secretRow && secretView) {
    secretRow.style.display = "";
    const cardData = s.secretPassage.card;
    const card = document.createElement("div");
    card.className = "card zone-card";
    const gradient = buildGradientCss(SECRET_PASSAGE_STYLE.cardGradient);
    if (SECRET_PASSAGE_STYLE.spaceBackground) {
      card.style.setProperty("--zone-space-bg", SECRET_PASSAGE_STYLE.spaceBackground);
    }
    if (gradient) card.style.setProperty("--zone-card-gradient", gradient);
      const { html: trackHtml, availableIds } = buildCardTrackHtml(cardData, null);
    const zoneName = SECRET_PASSAGE_TEMPLATE.name || "Secret Passage";
    card.innerHTML = `
      <div class="zone-card-inner">
        <div class="zone-card-face zone-card-front">
          ${trackHtml}
        </div>
        <div class="zone-card-face zone-card-back secret-passage-back">
          <div>${escapeHtml(zoneName)}</div>
        </div>
      </div>
    `;
    if (cardData && !cardData.revealed) {
      card.classList.add("flip-in");
      cardData.revealed = true;
    }
    if (cardData) {
      card.title = "Click a challenge to preselect spend target";
      card.addEventListener("click", (event) => {
        const target = event.target.closest("[data-challenge-id]");
        if (!target) return;
        const challengeId = target.getAttribute("data-challenge-id");
        if (!availableIds.has(challengeId)) return;
        preselectSpendTarget(STATE, { type:"secret_passage", challengeId });
        render();
      });
    }
    secretView.appendChild(card);
    const secretChevron = getGradientEndpoints(SECRET_PASSAGE_STYLE.cardGradient);
    scheduleZoneCardConnectors(card, cardData, secretChevron);
    if (secretActBoardView) {
      const routes = [{ name: "Secret", reward: { type:"big_ring" } }];
      const gradient = SECRET_PASSAGE_STYLE.cardGradient;
      const chevronGradient = secretChevron ? { top: secretChevron.start, bottom: secretChevron.end } : null;
      renderActBoard(secretActBoardView, {
        routes,
        cardGradient: gradient,
        chevronGradient,
        idPrefix: "secret"
      });
    }
  } else if (secretRow) {
    secretRow.style.display = "none";
    if (secretActBoardView) secretActBoardView.innerHTML = "";
  }

  // Badniks
  const bv = document.getElementById("badnikView");
  bv.innerHTML = "";
  if (!p.badniks.length) {
    bv.innerHTML = `<div class="tiny muted">No Badniks.</div>`;
  } else {
    bv.innerHTML = p.badniks.map((b, i) => buildBadnikCardHtml(b, s.zoneId, i)).join("");
    const cards = bv.querySelectorAll(".badnik-card");
    cards.forEach(card => {
      const idx = Number(card.getAttribute("data-badnik-index"));
      if (!Number.isFinite(idx)) return;
      card.title = "Click to preselect spend target";
      card.addEventListener("click", () => {
        preselectSpendTarget(STATE, { type:"badnik", badnikIndex: idx });
        render();
      });
      const modes = card.querySelectorAll("[data-badnik-mode]");
      modes.forEach(el => {
        const mode = el.getAttribute("data-badnik-mode");
        el.addEventListener("click", (event) => {
          event.stopPropagation();
          preselectSpendTarget(STATE, { type:"badnik", badnikIndex: idx, mode });
          render();
        });
      });
    });
  }

  // Log
  const logEl = document.getElementById("log");
  logEl.innerHTML = s.log.slice(-400).map(line => `<div>${escapeHtml(line)}</div>`).join("");
  logEl.scrollTop = logEl.scrollHeight;

  // Discards
  const powerDiscardEl = document.getElementById("powerUpDiscardView");
  if (powerDiscardEl) {
    const discards = s.powerUpDiscard || [];
    powerDiscardEl.innerHTML = discards.length
      ? `<div class="power-up-discard-grid">${
          discards.map(id => `<img src="img/power_up_${id}.png" alt="${escapeHtml(getPowerUpLabel(id))}" title="${escapeHtml(getPowerUpLabel(id))}">`).join("")
        }</div>`
      : "No discarded Power Ups.";
  }
  const badnikDiscardEl = document.getElementById("badnikDiscardView");
  if (badnikDiscardEl) {
    const discards = s.badnikDiscard || [];
    badnikDiscardEl.innerHTML = discards.length
      ? discards.map(b => {
          const labels = getBadnikDisplayLabels(b);
          return `<div class="pill tiny"><b>${escapeHtml(b.name)}</b>
            <span class="muted">attacks:</span> ${labels.attacksLabel}
            <span class="muted">avoid:</span> ${labels.avoidLabel}
            <span class="muted">defeat:</span> ${labels.destroyLabel}</div>`;
        }).join("")
      : `<div class="tiny muted">No discarded Badniks.</div>`;
  }

  const timeScoreEl = document.getElementById("timeScoringView");
  if (timeScoreEl) {
    if (s.players.length <= 1) {
      const solo = computeTimeScores(s)[0];
      const summary = computeScoreSummary(s)[0];
      timeScoreEl.innerHTML = `
        <div class="muted">Solo time scoring by Time Tokens taken.</div>
        <div class="pill tiny">
          <b>${escapeHtml(solo.name)} (${escapeHtml(solo.character)})</b>
          Time Taken ${s.players[0].timeTokensTaken} | Time Points ${solo.points}
        </div>
        <div class="pill tiny">Rings Points ${summary.ringPoints} | Animal Points ${summary.animalPoints} | Chaos ${summary.chaosPoints} | Life Loss ${summary.lifePoints} | Total ${summary.totalPoints}</div>
      `;
    } else {
      const scores = computeTimeScores(s);
      const summary = computeScoreSummary(s);
      timeScoreEl.innerHTML = `
        <div class="muted">Speed = (Zone Cards x3) - (Time Tokens taken)</div>
        ${scores.map(entry => {
          const extra = summary.find(sx => sx.id === entry.id);
          return `
          <div class="pill tiny">
            <b>${escapeHtml(entry.name)} (${escapeHtml(entry.character)})</b>
            Speed ${entry.speed} | Place ${entry.place} | Time Points ${entry.points}
            | Rings ${extra?.ringPoints ?? 0} | Animals ${extra?.animalPoints ?? 0} | Chaos ${extra?.chaosPoints ?? 0} | Life ${extra?.lifePoints ?? 0} | Total ${extra?.totalPoints ?? entry.points}
          </div>
        `;
        }).join("")}
      `;
    }
  }

  const bonusModal = document.getElementById("bonusStageModal");
  if (bonusModal) {
    const stage = s.bonusStage;
    if (!stage || !stage.open) {
      bonusModal.classList.remove("open");
    } else {
      bonusModal.classList.add("open");
      const statusEl = document.getElementById("bonusStageStatus");
      const gridEl = document.getElementById("bonusStageGrid");
      const exitBtn = document.getElementById("bonusStageExit");
      const activeName = s.players[stage.activePlayerId ?? s.activePlayer]?.name || p.name;
      const remaining = stage.tiles.filter(t => !t.revealed).length;
      if (statusEl) {
        const baseMsg = stage.message || `Bonus Stage: ${activeName} is flipping tiles.`;
        statusEl.textContent = `${baseMsg} (Unflipped: ${remaining})`;
      }
      if (gridEl) {
        gridEl.innerHTML = "";
        for (const tile of stage.tiles) {
          const tileEl = document.createElement("div");
          const classes = ["bonus-tile"];
          let label = "Blue Sphere";
          let icon = "\u{1F535}";
          if (tile.revealed) {
            classes.push("revealed");
            if (tile.type === "red") {
              classes.push("red");
              label = "Red Sphere";
              icon = "\u{1F534}";
            } else if (tile.type === "bumper") {
              classes.push("bumper");
              label = "Bumper Sphere";
              icon = "\u{26AA}";
            } else if (tile.type === "chaos") {
              classes.push("chaos");
              label = "Chaos Emerald";
              icon = "\u{1F48E}";
            }
          }
          if (stage.awaitingExit) classes.push("disabled");
          tileEl.className = classes.join(" ");
          tileEl.title = label;
          const iconEl = document.createElement("div");
          iconEl.className = "bonus-icon";
          iconEl.textContent = icon;
          tileEl.appendChild(iconEl);
          if (tile.revealed && tile.reward) {
            const badge = document.createElement("div");
            badge.className = "bonus-reward";
            if (tile.reward.type === "rings") {
              const img = document.createElement("img");
              img.src = "img/ring.png";
              img.alt = "Ring";
              badge.appendChild(img);
            } else if (tile.reward.type === "power_up") {
              const img = document.createElement("img");
              img.src = "img/power_up.png";
              img.alt = "Power Up";
              badge.appendChild(img);
            } else if (tile.reward.type === "boost") {
              const img = document.createElement("img");
              img.src = "img/boost.png";
              img.alt = "Boost";
              badge.appendChild(img);
            } else {
              badge.textContent = formatBonusStageRewardLabel(tile.reward);
            }
            tileEl.appendChild(badge);
          }
          tileEl.addEventListener("click", () => {
            flipBonusStageTile(STATE, tile.id);
            render();
          });
          gridEl.appendChild(tileEl);
        }
      }
      if (exitBtn) {
        exitBtn.disabled = !stage.awaitingExit;
        exitBtn.textContent = stage.awaitingExit ? "Return to Zone" : "Finish Bonus Stage";
        exitBtn.onclick = () => {
          if (!stage.awaitingExit) return;
          closeBonusStage(STATE);
          render();
        };
      }
    }
  }
}

/* =======================
   UI events
   ======================= */
function openNewGameModal() {
  const modal = document.getElementById("newGameModal");
  if (modal) modal.classList.add("open");
}

function closeNewGameModal() {
  const modal = document.getElementById("newGameModal");
  if (modal) modal.classList.remove("open");
}

function openZoneJsonModal(state) {
  const modal = document.getElementById("zoneJsonModal");
  const text = document.getElementById("zoneJsonText");
  if (!modal || !text) return;
  const data = state?.zone || null;
  text.value = data ? JSON.stringify(data, null, 2) : "No zone data.";
  text.scrollTop = 0;
  modal.classList.add("open");
}

function closeZoneJsonModal() {
  const modal = document.getElementById("zoneJsonModal");
  if (modal) modal.classList.remove("open");
}

function generateSeed() {
  return Math.floor(Math.random() * 1000000000).toString();
}

function getSeedFromQuery() {
  const params = new URLSearchParams(window.location.search || "");
  const raw = params.get("seed");
  if (!raw) return null;
  const value = Number.parseInt(raw, 10);
  if (!Number.isFinite(value) || value <= 0) return null;
  return value.toString();
}

function ensureSeedValue() {
  const seedInput = document.getElementById("seed");
  const querySeed = getSeedFromQuery();
  if (!seedInput) return querySeed || generateSeed();
  if (querySeed) {
    seedInput.value = querySeed;
    return seedInput.value;
  }
  if (!seedInput.value.trim()) seedInput.value = generateSeed();
  return seedInput.value;
}

function startNewGame({ closeModal = false } = {}) {
  const playerCount = parseInt(document.getElementById("playerCount").value, 10);
  const seedStr = ensureSeedValue();
  const characterSelections = readCharacterSelections(playerCount);
  const zoneId = readZoneSelection();
  STATE = newGame({ playerCount, seedStr, characterSelections, zoneId });
  if (closeModal) closeNewGameModal();
  render();
}

const menuWrapper = document.getElementById("menuWrapper");
const menuBtn = document.getElementById("menuBtn");
const menuDropdown = document.getElementById("menuDropdown");
const menuNewGame = document.getElementById("menuNewGame");
if (menuBtn && menuDropdown) {
  menuBtn.addEventListener("click", (event) => {
    event.stopPropagation();
    menuDropdown.classList.toggle("open");
  });
}
if (menuNewGame) {
  menuNewGame.addEventListener("click", () => {
    menuDropdown?.classList.remove("open");
    renderCharacterSelectors();
    renderZoneSelector();
    openNewGameModal();
  });
}
document.addEventListener("click", (event) => {
  if (!menuWrapper) return;
  if (!menuWrapper.contains(event.target)) {
    menuDropdown?.classList.remove("open");
  }
});

const confirmNewGameBtn = document.getElementById("confirmNewGameBtn");
if (confirmNewGameBtn) {
  confirmNewGameBtn.addEventListener("click", () => {
    startNewGame({ closeModal: true });
  });
}

const cancelNewGameBtn = document.getElementById("cancelNewGameBtn");
if (cancelNewGameBtn) {
  cancelNewGameBtn.addEventListener("click", () => {
    closeNewGameModal();
  });
}

document.getElementById("playerCount").addEventListener("change", () => {
  renderCharacterSelectors();
});

document.getElementById("btnBuildPool").addEventListener("click", () => {
  buildDicePool(STATE);
  render();
});

document.getElementById("btnUseBoostToken").addEventListener("click", () => {
  if (STATE?.phase === "REROLL") {
    boostInReroll(STATE);
  } else {
    boostAfterRollAction(STATE);
  }
  render();
});

document.getElementById("btnSpendDie").addEventListener("click", () => {
  spendSelectedDie(STATE);
  render();
});

document.getElementById("btnRerollStep").addEventListener("click", () => {
  rerollStep(STATE);
  render();
});

document.getElementById("btnEndTurn").addEventListener("click", () => {
  endTurn(STATE);
  render();
});

const forceBonusBtn = document.getElementById("btnForceBonusStage");
if (forceBonusBtn) {
  forceBonusBtn.addEventListener("click", () => {
    if (!STATE) return;
    if (STATE.pendingPowerUp || STATE.pendingDamage || STATE.pendingBadnikReward || STATE.pendingWallClimb) {
      log(STATE, "Resolve the pending reward before forcing the Bonus Stage.");
      render();
      return;
    }
    enterBonusStage(STATE, "Debug trigger");
    render();
  });
}

const showPowerUpDeckBtn = document.getElementById("btnShowPowerUpDeck");
if (showPowerUpDeckBtn) {
  showPowerUpDeckBtn.addEventListener("click", () => {
    if (!STATE) return;
    const deck = STATE.powerUpDeck || [];
    if (!deck.length) {
      log(STATE, "Power-Up Deck is empty.");
    } else {
      const labels = deck.map(id => getPowerUpLabel(id)).join(", ");
      log(STATE, `Power-Up Deck order: ${labels}`);
    }
    render();
  });
}

const showZoneJsonBtn = document.getElementById("btnShowZoneJson");
if (showZoneJsonBtn) {
  showZoneJsonBtn.addEventListener("click", () => {
    if (!STATE) return;
    openZoneJsonModal(STATE);
  });
}

const zoneJsonCloseBtn = document.getElementById("zoneJsonClose");
if (zoneJsonCloseBtn) {
  zoneJsonCloseBtn.addEventListener("click", () => closeZoneJsonModal());
}

const zoneJsonCopyBtn = document.getElementById("zoneJsonCopy");
if (zoneJsonCopyBtn) {
  zoneJsonCopyBtn.addEventListener("click", () => {
    const text = document.getElementById("zoneJsonText");
    if (!text) return;
    const value = text.value || "";
    if (navigator?.clipboard?.writeText) {
      navigator.clipboard.writeText(value).then(() => {
        log(STATE, "Zone JSON copied to clipboard.");
      }).catch(() => {
        text.select();
        document.execCommand("copy");
      });
    } else {
      text.select();
      document.execCommand("copy");
    }
  });
}

// Auto-start
renderCharacterSelectors();
renderZoneSelector();
ensureSeedValue();
startNewGame();
</script>
</body>
</html>







